Directory structure:
└── packages/
    ├── parser/
    │   ├── CHANGELOG.md
    │   ├── package.json
    │   ├── rollup.config.js
    │   ├── tsconfig.json
    │   ├── tsconfig.node.json
    │   ├── .babelrc
    │   ├── .npmignore
    │   ├── .prettierrc
    │   ├── src/
    │   │   ├── index.ts
    │   │   ├── sceneParser.ts
    │   │   ├── sceneTextPreProcessor.ts
    │   │   ├── config/
    │   │   │   └── scriptConfig.ts
    │   │   ├── configParser/
    │   │   │   └── configParser.ts
    │   │   ├── interface/
    │   │   │   ├── assets.ts
    │   │   │   ├── runtimeInterface.ts
    │   │   │   └── sceneInterface.ts
    │   │   ├── parser4/
    │   │   │   └── index.ts
    │   │   ├── scriptParser/
    │   │   │   ├── argsParser.ts
    │   │   │   ├── assetsScanner.ts
    │   │   │   ├── commandParser.ts
    │   │   │   ├── contentParser.ts
    │   │   │   ├── scriptParser.ts
    │   │   │   └── subSceneScanner.ts
    │   │   └── styleParser/
    │   │       └── index.ts
    │   └── test/
    │       ├── debug-linebreak.ts
    │       ├── debug.ts
    │       ├── debugCssParser.ts
    │       ├── parser.test.ts
    │       ├── parserMultiline.test.ts
    │       └── test-resources/
    │           ├── choose.txt
    │           ├── debug.scss
    │           ├── line-break.txt
    │           ├── long-script.txt
    │           ├── start.txt
    │           └── var.txt
    ├── server/
    │   ├── README.md
    │   ├── index-linux
    │   ├── index-macos
    │   ├── index.js
    │   ├── LICENSE
    │   ├── myLLMProvider.js
    │   ├── package.json
    │   └── runtimeSceneProvider.js
    ├── webgal/
    │   ├── index.html
    │   ├── LICENSE
    │   ├── package.json
    │   ├── tsconfig.json
    │   ├── tsconfig.node.json
    │   ├── vite.config.ts
    │   ├── .eslintignore
    │   ├── .eslintrc.js
    │   ├── .npmignore
    │   ├── .prettierignore
    │   ├── .prettierrc.js
    │   ├── public/
    │   │   ├── games.json
    │   │   ├── manifest.json
    │   │   ├── webgal-serviceworker.js
    │   │   └── games/
    │   │       ├── defaultgame/
    │   │       │   ├── config.txt
    │   │       │   ├── userStyleSheet.css
    │   │       │   ├── animation/
    │   │       │   │   ├── animationTable.json
    │   │       │   │   ├── blur.json
    │   │       │   │   ├── dotFilm.json
    │   │       │   │   ├── enter-from-bottom.json
    │   │       │   │   ├── enter-from-left.json
    │   │       │   │   ├── enter-from-right.json
    │   │       │   │   ├── enter.json
    │   │       │   │   ├── exit.json
    │   │       │   │   ├── glitchFilm.json
    │   │       │   │   ├── godrayFilm.json
    │   │       │   │   ├── move-front-and-back.json
    │   │       │   │   ├── oldFilm.json
    │   │       │   │   ├── reflectionFilm.json
    │   │       │   │   ├── removeFilm.json
    │   │       │   │   ├── rgbFilm.json
    │   │       │   │   ├── shake.json
    │   │       │   │   ├── shockwaveIn.json
    │   │       │   │   └── shockwaveOut.json
    │   │       │   ├── background/
    │   │       │   │   ├── bg.webp
    │   │       │   │   ├── WebGAL_New_Enter_Image.webp
    │   │       │   │   └── WebGalEnter.webp
    │   │       │   ├── figure/
    │   │       │   │   ├── miniavatar.webp
    │   │       │   │   ├── stand.webp
    │   │       │   │   ├── stand2.webp
    │   │       │   │   ├── 1/
    │   │       │   │   │   ├── closed_eyes.webp
    │   │       │   │   │   ├── closed_mouth.webp
    │   │       │   │   │   ├── halfopen_mouth.webp
    │   │       │   │   │   ├── open_eyes.webp
    │   │       │   │   │   └── open_mouth.webp
    │   │       │   │   ├── 2/
    │   │       │   │   │   ├── closed_eyes.webp
    │   │       │   │   │   ├── closed_mouth.webp
    │   │       │   │   │   ├── halfopen_mouth.webp
    │   │       │   │   │   ├── open_eyes.webp
    │   │       │   │   │   └── open_mouth.webp
    │   │       │   │   └── 3/
    │   │       │   │       ├── closed_eyes.webp
    │   │       │   │       ├── closed_mouth.webp
    │   │       │   │       ├── halfopen_mouth.webp
    │   │       │   │       ├── open_eyes.webp
    │   │       │   │       └── open_mouth.webp
    │   │       │   ├── scene/
    │   │       │   │   ├── demo_animation.txt
    │   │       │   │   ├── demo_changeConfig.txt
    │   │       │   │   ├── demo_en.txt
    │   │       │   │   ├── demo_escape.txt
    │   │       │   │   ├── demo_ja.txt
    │   │       │   │   ├── demo_performs.txt
    │   │       │   │   ├── demo_var.txt
    │   │       │   │   ├── demo_zh_cn.txt
    │   │       │   │   ├── function_test.txt
    │   │       │   │   └── start.txt
    │   │       │   ├── template/
    │   │       │   │   ├── template.json
    │   │       │   │   ├── Stage/
    │   │       │   │   │   ├── Choose/
    │   │       │   │   │   │   └── choose.scss
    │   │       │   │   │   └── TextBox/
    │   │       │   │   │       └── textbox.scss
    │   │       │   │   └── UI/
    │   │       │   │       └── Title/
    │   │       │   │           └── title.scss
    │   │       │   └── tex/
    │   │       │       └── cherryBlossoms.webp
    │   │       └── story-lab/
    │   │           ├── config.txt
    │   │           ├── userStyleSheet.css
    │   │           ├── animation/
    │   │           │   └── animationTable.json
    │   │           ├── scene/
    │   │           │   ├── start.txt
    │   │           │   └── chapter_01/
    │   │           │       └── shop.txt
    │   │           └── template/
    │   │               ├── template.json
    │   │               ├── Stage/
    │   │               │   ├── Choose/
    │   │               │   │   └── choose.scss
    │   │               │   └── TextBox/
    │   │               │       └── textbox.scss
    │   │               └── UI/
    │   │                   └── Title/
    │   │                       └── title.scss
    │   └── src/
    │       ├── App.tsx
    │       ├── index.scss
    │       ├── main.tsx
    │       ├── vite-env.d.ts
    │       ├── assets/
    │       │   ├── fonts/
    │       │   │   ├── LXGWWenKai-Regular.ttf
    │       │   │   ├── OPPOSans-R.ttf
    │       │   │   └── SourceHanSerifCN-Regular.ttf
    │       │   ├── se/
    │       │   │   └── license.txt
    │       │   └── style/
    │       │       └── animation.scss
    │       ├── config/
    │       │   ├── index.ts
    │       │   ├── info.ts
    │       │   └── language.ts
    │       ├── Core/
    │       │   ├── constants.ts
    │       │   ├── gameState.ts
    │       │   ├── initializeScript.ts
    │       │   ├── live2DCore.ts
    │       │   ├── WebGAL.ts
    │       │   ├── webgalCore.ts
    │       │   ├── controller/
    │       │   │   ├── customUI/
    │       │   │   │   └── scss2cssinjsParser.ts
    │       │   │   ├── gamePlay/
    │       │   │   │   ├── autoPlay.ts
    │       │   │   │   ├── backToTitle.ts
    │       │   │   │   ├── fastSkip.ts
    │       │   │   │   ├── nextSentence.ts
    │       │   │   │   ├── runScript.ts
    │       │   │   │   ├── scriptExecutor.ts
    │       │   │   │   ├── startContinueGame.ts
    │       │   │   │   ├── stopAllPerform.ts
    │       │   │   │   └── strIf.ts
    │       │   │   ├── scene/
    │       │   │   │   ├── callScene.ts
    │       │   │   │   ├── changeScene.ts
    │       │   │   │   ├── restoreScene.ts
    │       │   │   │   ├── sceneFetcher.ts
    │       │   │   │   └── sceneInterface.ts
    │       │   │   ├── stage/
    │       │   │   │   ├── playBgm.ts
    │       │   │   │   ├── resetStage.ts
    │       │   │   │   ├── setVolume.ts
    │       │   │   │   └── pixi/
    │       │   │   │       ├── PixiController.ts
    │       │   │   │       ├── spine.ts
    │       │   │   │       ├── WebGALPixiContainer.ts
    │       │   │   │       ├── animations/
    │       │   │   │       │   ├── generateTransformAnimationObj.ts
    │       │   │   │       │   ├── index.ts
    │       │   │   │       │   ├── template.ts
    │       │   │   │       │   ├── testblur.ts
    │       │   │   │       │   ├── timeline.ts
    │       │   │   │       │   ├── universalSoftIn.ts
    │       │   │   │       │   └── universalSoftOff.ts
    │       │   │   │       └── shaders/
    │       │   │   │           ├── BevelFilter.ts
    │       │   │   │           └── RadiusAlphaFilter.ts
    │       │   │   └── storage/
    │       │   │       ├── fastSaveLoad.ts
    │       │   │       ├── jumpFromBacklog.ts
    │       │   │       ├── loadGame.ts
    │       │   │       ├── saveGame.ts
    │       │   │       ├── savesController.ts
    │       │   │       └── storageController.ts
    │       │   ├── gameScripts/
    │       │   │   ├── applyStyle.ts
    │       │   │   ├── bgm.ts
    │       │   │   ├── callSceneScript.ts
    │       │   │   ├── changeFigure.ts
    │       │   │   ├── changeSceneScript.ts
    │       │   │   ├── comment.ts
    │       │   │   ├── end.ts
    │       │   │   ├── filmMode.ts
    │       │   │   ├── intro.tsx
    │       │   │   ├── jumpLabel.ts
    │       │   │   ├── miniAvatar.ts
    │       │   │   ├── playEffect.ts
    │       │   │   ├── playVideo.tsx
    │       │   │   ├── say.ts
    │       │   │   ├── setAnimation.ts
    │       │   │   ├── setComplexAnimation.ts
    │       │   │   ├── setFilter.ts
    │       │   │   ├── setTempAnimation.ts
    │       │   │   ├── setTextbox.ts
    │       │   │   ├── setTransform.ts
    │       │   │   ├── setTransition.ts
    │       │   │   ├── setVar.ts
    │       │   │   ├── showVars.ts
    │       │   │   ├── template.ts
    │       │   │   ├── unlockBgm.ts
    │       │   │   ├── unlockCg.ts
    │       │   │   ├── wait.ts
    │       │   │   ├── changeBg/
    │       │   │   │   ├── index.ts
    │       │   │   │   └── setEbg.ts
    │       │   │   ├── choose/
    │       │   │   │   ├── choose.module.scss
    │       │   │   │   └── index.tsx
    │       │   │   ├── getUserInput/
    │       │   │   │   ├── getUserInput.module.scss
    │       │   │   │   └── index.tsx
    │       │   │   ├── label/
    │       │   │   │   ├── index.ts
    │       │   │   │   └── jmp.ts
    │       │   │   ├── pixi/
    │       │   │   │   ├── index.ts
    │       │   │   │   ├── pixiInit.ts
    │       │   │   │   └── performs/
    │       │   │   │       ├── cherryBlossoms.ts
    │       │   │   │       ├── rain.ts
    │       │   │   │       └── snow.ts
    │       │   │   └── vocal/
    │       │   │       ├── conentsCash.ts
    │       │   │       ├── index.ts
    │       │   │       └── vocalAnimation.ts
    │       │   ├── Modules/
    │       │   │   ├── animationFunctions.ts
    │       │   │   ├── animations.ts
    │       │   │   ├── backlog.ts
    │       │   │   ├── events.ts
    │       │   │   ├── gamePlay.ts
    │       │   │   ├── scene.ts
    │       │   │   └── perform/
    │       │   │       ├── performController.ts
    │       │   │       └── performInterface.ts
    │       │   ├── parser/
    │       │   │   ├── sceneParser.ts
    │       │   │   └── utils.ts
    │       │   └── util/
    │       │       ├── constants.scss
    │       │       ├── constants.ts
    │       │       ├── getSentenceArg.ts
    │       │       ├── logger.ts
    │       │       ├── match.ts
    │       │       ├── toSafeType.ts
    │       │       ├── coreInitialFunction/
    │       │       │   ├── bindExtraFunc.ts
    │       │       │   └── infoFetcher.ts
    │       │       ├── gameAssetsAccess/
    │       │       │   └── assetSetter.ts
    │       │       ├── pixiPerformManager/
    │       │       │   ├── initRegister.ts
    │       │       │   └── pixiPerformManager.ts
    │       │       ├── prefetcher/
    │       │       │   ├── assetsPrefetcher.ts
    │       │       │   └── scenePrefetcher.ts
    │       │       └── syncWithEditor/
    │       │           ├── syncWithOrigine.ts
    │       │           └── webSocketFunc.ts
    │       ├── Gallery/
    │       │   └── Gallery.tsx
    │       ├── hooks/
    │       │   ├── useApplyStyle.ts
    │       │   ├── useConfigData.ts
    │       │   ├── useEscape.ts
    │       │   ├── useFontFamily.ts
    │       │   ├── useFullScreen.ts
    │       │   ├── useGenSyncRef.ts
    │       │   ├── useHotkey.tsx
    │       │   ├── useLanguage.ts
    │       │   ├── useLifeCycle.ts
    │       │   ├── useNotFirstEffect.ts
    │       │   ├── useSoundEffect.ts
    │       │   ├── useTextOptions.ts
    │       │   ├── useTrans.ts
    │       │   └── useValue.ts
    │       ├── Stage/
    │       │   ├── stage.module.scss
    │       │   ├── Stage.tsx
    │       │   ├── themeInterface.ts
    │       │   ├── AudioContainer/
    │       │   │   └── AudioContainer.tsx
    │       │   ├── FigureContainer/
    │       │   │   ├── figureContainer.module.scss
    │       │   │   └── FigureContainer.tsx
    │       │   ├── FullScreenPerform/
    │       │   │   ├── fullScreenPerform.module.scss
    │       │   │   └── FullScreenPerform.tsx
    │       │   ├── introContainer/
    │       │   │   ├── introContainer.module.scss
    │       │   │   └── IntroContainer.tsx
    │       │   ├── MainStage/
    │       │   │   ├── MainStage.tsx
    │       │   │   ├── useSetBg.ts
    │       │   │   ├── useSetEffects.ts
    │       │   │   └── useSetFigure.ts
    │       │   ├── OldStage/
    │       │   │   └── OldStage.tsx
    │       │   └── TextBox/
    │       │       ├── IMSSTextbox.tsx
    │       │       ├── textbox.module.scss
    │       │       ├── TextBox.tsx
    │       │       ├── textboxFilm.module.scss
    │       │       ├── TextBoxFilm.tsx
    │       │       ├── types.ts
    │       │       └── legacy-themes/
    │       │           └── legacy-standard/
    │       │               ├── standard.module.scss
    │       │               └── StandardTextbox.tsx
    │       ├── store/
    │       │   ├── guiInterface.ts
    │       │   ├── GUIReducer.ts
    │       │   ├── savesReducer.ts
    │       │   ├── stageInterface.ts
    │       │   ├── stageReducer.ts
    │       │   ├── store.ts
    │       │   ├── userDataInterface.ts
    │       │   └── userDataReducer.ts
    │       ├── translations/
    │       │   ├── de.ts
    │       │   ├── en.ts
    │       │   ├── fr.ts
    │       │   ├── jp.ts
    │       │   ├── zh-cn.ts
    │       │   └── zh-tw.ts
    │       ├── types/
    │       │   ├── angular-expressions.d.ts
    │       │   └── debugProtocol.ts
    │       └── UI/
    │           ├── getTextSize.ts
    │           ├── Backlog/
    │           │   ├── backlog.module.scss
    │           │   └── Backlog.tsx
    │           ├── BottomControlPanel/
    │           │   ├── bottomControlPanel.module.scss
    │           │   ├── BottomControlPanel.tsx
    │           │   ├── bottomControlPanelFilm.module.scss
    │           │   └── BottomControlPanelFilm.tsx
    │           ├── DevPanel/
    │           │   ├── devPanel.module.scss
    │           │   ├── DevPanel.tsx
    │           │   └── devFunctions/
    │           │       └── getPixiSscreenshot.ts
    │           ├── etc/
    │           │   └── QuickSL.tsx
    │           ├── Extra/
    │           │   ├── extra.module.scss
    │           │   ├── Extra.tsx
    │           │   ├── ExtraBgm.tsx
    │           │   ├── ExtraCg.tsx
    │           │   ├── extraCG_animation_List.scss
    │           │   └── ExtraCgElement.tsx
    │           ├── GlobalDialog/
    │           │   ├── globalDialog.module.scss
    │           │   └── GlobalDialog.tsx
    │           ├── Logo/
    │           │   ├── logo.module.scss
    │           │   └── Logo.tsx
    │           ├── Menu/
    │           │   ├── menu.module.scss
    │           │   ├── Menu.tsx
    │           │   ├── MenuPanel/
    │           │   │   ├── MenuIconMap.tsx
    │           │   │   ├── menuPanel.module.scss
    │           │   │   ├── MenuPanel.tsx
    │           │   │   ├── MenuPanelButton.tsx
    │           │   │   └── menuPanelInterface.ts
    │           │   ├── Options/
    │           │   │   ├── normalButton.module.scss
    │           │   │   ├── NormalButton.tsx
    │           │   │   ├── normalOption.module.scss
    │           │   │   ├── NormalOption.tsx
    │           │   │   ├── OptionInterface.ts
    │           │   │   ├── options.module.scss
    │           │   │   ├── Options.tsx
    │           │   │   ├── OptionSlider.tsx
    │           │   │   ├── slider.css
    │           │   │   ├── Display/
    │           │   │   │   └── Display.tsx
    │           │   │   ├── Sound/
    │           │   │   │   └── Sound.tsx
    │           │   │   ├── System/
    │           │   │   │   ├── about.module.scss
    │           │   │   │   ├── About.tsx
    │           │   │   │   └── System.tsx
    │           │   │   └── TextPreview/
    │           │   │       ├── textPreview.module.scss
    │           │   │       └── TextPreview.tsx
    │           │   └── SaveAndLoad/
    │           │       ├── SaveAndLoad.module.scss
    │           │       ├── Load/
    │           │       │   └── Load.tsx
    │           │       └── Save/
    │           │           └── Save.tsx
    │           ├── PanicOverlay/
    │           │   ├── panicOverlay.module.scss
    │           │   ├── PanicOverlay.tsx
    │           │   ├── PanicImage/
    │           │   │   ├── panicImage.module.scss
    │           │   │   └── PanicImage.tsx
    │           │   └── PanicYoozle/
    │           │       ├── panicYoozle.module.scss
    │           │       └── PanicYoozle.tsx
    │           ├── Title/
    │           │   ├── title.module.scss
    │           │   └── Title.tsx
    │           └── Translation/
    │               ├── translation.module.scss
    │               └── Translation.tsx
    └── yukimi/
        └── libwebgal-base.ykm

================================================
FILE: parser/CHANGELOG.md
================================================
# WebGAL Parser Changelog

## [4.5.13] - 2025-07-05

### Fixed
- Fixed interface consistency between `webgal-parser` and main WebGAL project
- Added missing trailing comma in `commandType` enum to match WebGAL main project
- Updated `ISceneData` interface to use `ISceneEntry` instead of `sceneEntry` for better type consistency

### Added
- Added `ISceneEntry` interface as compatibility alias for `sceneEntry`
- Added comprehensive test cases for new animation parameters:
  - `wait` command testing
  - `changeFigure` with `duration`, `enter`, `exit` parameters
  - `changeBg` with animation and transform parameters

### Improved
- Enhanced type safety and consistency with main WebGAL project
- Better test coverage for animation-related features
- Improved interface documentation

### Technical Notes
- The parser already supports all animation parameters (`duration`, `enter`, `exit`, `transform`) through its generic argument parsing system
- No changes to core parsing logic were needed - the parser was already compatible with the latest WebGAL features
- This update focuses on interface consistency and test coverage improvements

## [4.5.12] - Previous Version
- Previous stable release with `wait` command support


================================================
FILE: parser/package.json
================================================
{
  "name": "webgal-parser",
  "version": "4.5.13",
  "description": "WebGAL script parser",
  "scripts": {
    "test": "vitest",
    "coverage": "vitest run --coverage",
    "build": "rimraf -rf ./build && rollup --config",
    "build-ci": "rollup --config",
    "debug": "tsx test/debug.ts",
    "debug-scss-parser": "tsx test/debugCssParser.ts",
    "debug-linebreak-parser": "tsx test/debug-linebreak.ts"
  },
  "types": "./build/types/index.d.ts",
  "module": "./build/es/index.js",
  "main": "./build/cjs/index.cjs",
  "author": "Mahiru <Mahiru_@outlook.com>",
  "license": "MPL-2.0",
  "dependencies": {
    "chevrotain": "^10.5.0",
    "cloudlogjs": "^1.0.11",
    "lodash": "^4.17.21",
    "tsx": "^3.12.7"
  },
  "devDependencies": {
    "@rollup/plugin-commonjs": "^23.0.2",
    "@rollup/plugin-json": "^5.0.1",
    "@rollup/plugin-node-resolve": "^15.0.1",
    "@rollup/plugin-typescript": "^9.0.2",
    "@types/lodash": "^4.14.189",
    "@types/node": "^18.14.0",
    "@vitest/coverage-c8": "^0.28.5",
    "rollup": "^3.29.5",
    "rollup-plugin-babel": "^4.4.0",
    "rollup-plugin-terser": "^7.0.2",
    "rollup-plugin-typescript2": "^0.34.1",
    "ts-node": "^10.9.1",
    "tslib": "^2.4.1",
    "typescript": "^4.9.3",
    "vitest": "^0.28.5"
  },
  "type": "module"
}



================================================
FILE: parser/rollup.config.js
================================================
import typescript from "rollup-plugin-typescript2";
import resolve from "@rollup/plugin-node-resolve";
import commonjs from "@rollup/plugin-commonjs";

const mode = process.env.MODE ?? 'prod';
const isProd = mode === "prod";

export default [
  {
    input: `./src/index.ts`,
    output:
      {
        file: "./build/es/index.js",
        format: "es",
        sourcemap: !isProd
      },
    plugins: [
      resolve(), commonjs(), typescript({
        useTsconfigDeclarationDir: true,
        tsconfigOverride: {
          compilerOptions: {
            sourceMap: !isProd,
            declarationDir: "build/es"
          }, include: ["src"]
        }
      })]
  }, {
    input: `./src/index.ts`,
    output: [
      {
        file: "./build/cjs/index.cjs",
        exports: "named",
        format: "cjs",
        sourcemap: !isProd
      },
    ],
    plugins: [
      resolve(), commonjs(), typescript({
        useTsconfigDeclarationDir: true,
        tsconfigOverride: {
          compilerOptions: {
            sourceMap: !isProd,
            declarationDir: "build/cjs"
          }, include: ["src"]
        }
      })],
  },
  {
    input: `./src/index.ts`,
    output: [
      {
        file: "./build/umd/index.global.js",
        name: 'webgalParser',
        format: 'iife',
        sourcemap: !isProd
      },
    ],
    plugins: [
      resolve(), commonjs(), typescript({
        useTsconfigDeclarationDir: true,
        tsconfigOverride: {
          compilerOptions: {
            sourceMap: !isProd,
            declarationDir: "build/types"
          }, include: ["src"]
        }
      })],
  }
];



================================================
FILE: parser/tsconfig.json
================================================
{
  "compilerOptions": {
    "declaration": true,
    "declarationDir": "build/types",
    "target": "ESNext",
    "useDefineForClassFields": true,
    "lib": ["DOM", "DOM.Iterable", "ESNext"],
    "allowJs": false,
    "skipLibCheck": false,
    "esModuleInterop": false,
    "allowSyntheticDefaultImports": true,
    "strict": true,
    "forceConsistentCasingInFileNames": true,
    "module": "ESNext",
    "noImplicitAny": false,
    "moduleResolution": "Node",
    "resolveJsonModule": true,
    "isolatedModules": true,
    "noEmit": true,
    "jsx": "react-jsx",
    "paths": {
      "@/*": ["./src/*"]
    }
  },
  "include": [
    "src"
  ],
  "references": [{ "path": "./tsconfig.node.json"}]
}



================================================
FILE: parser/tsconfig.node.json
================================================
{
    "compilerOptions": {
        "composite": true,
        "module": "esnext",
        "moduleResolution": "node"
    },
    "include": [
      "vite.config.ts"
    ]
}



================================================
FILE: parser/.babelrc
================================================
{
  "presets": [
    [
      "@babel/preset-env",
      {
        "useBuiltIns": "entry",
        "corejs": "3.6.4",
        "modules": false
      },
      "@babel/preset-typescript"
    ]
  ],
  "exclude": "node_modules/**"
}



================================================
FILE: parser/.npmignore
================================================
coverage
test
.babelrc
rollup.config.js
tsconfig.json
tsconfig.node.json



================================================
FILE: parser/.prettierrc
================================================
{
  "printWidth": 80,
  "tabWidth": 2,
  "useTabs": false,
  "semi": true,
  "singleQuote": true,
  "quoteProps": "as-needed",
  "jsxSingleQuote": false,
  "trailingComma": "all",
  "bracketSpacing": true,
  "bracketSameLine": false,
  "arrowParens": "always",
  "requirePragma": false,
  "insertPragma": false,
  "proseWrap": "preserve",
  "htmlWhitespaceSensitivity": "css",
  "endOfLine": "lf",
  "embeddedLanguageFormatting": "auto"
}



================================================
FILE: parser/src/index.ts
================================================
import {
  ADD_NEXT_ARG_LIST,
  SCRIPT_CONFIG,
  ConfigMap,
  ConfigItem,
} from './config/scriptConfig';
import { configParser, WebgalConfig } from './configParser/configParser';
import { fileType } from './interface/assets';
import { IAsset } from './interface/sceneInterface';
import { sceneParser } from './sceneParser';
import { IWebGALStyleObj, scss2cssinjsParser } from "./styleParser";
import { sceneTextPreProcess } from "./sceneTextPreProcessor";

export default class SceneParser {
  private readonly SCRIPT_CONFIG_MAP: ConfigMap;
  constructor(
    private readonly assetsPrefetcher: (assetList: IAsset[]) => void,
    private readonly assetSetter: (
      fileName: string,
      assetType: fileType,
    ) => string,
    private readonly ADD_NEXT_ARG_LIST: number[],
    SCRIPT_CONFIG_INPUT: ConfigItem[] | ConfigMap,
  ) {
    if (Array.isArray(SCRIPT_CONFIG_INPUT)) {
      this.SCRIPT_CONFIG_MAP = new Map();
      SCRIPT_CONFIG_INPUT.forEach((config) => {
        this.SCRIPT_CONFIG_MAP.set(config.scriptString, config);
      });
    } else {
      this.SCRIPT_CONFIG_MAP = SCRIPT_CONFIG_INPUT;
    }
  }
  /**
   * 解析场景
   * @param rawScene 原始场景
   * @param sceneName 场景名称
   * @param sceneUrl 场景url
   * @return 解析后的场景
   */
  parse(rawScene: string, sceneName: string, sceneUrl: string) {
    return sceneParser(
      rawScene,
      sceneName,
      sceneUrl,
      this.assetsPrefetcher,
      this.assetSetter,
      this.ADD_NEXT_ARG_LIST,
      this.SCRIPT_CONFIG_MAP,
    );
  }

  parseConfig(configText: string) {
    return configParser(configText);
  }

  stringifyConfig(config: WebgalConfig) {
    return config.reduce(
      (previousValue, curr) =>
        previousValue +
        `${curr.command}:${curr.args.join('|')}${
          curr.options.length <= 0
            ? ''
            : curr.options.reduce(
                (p, c) => p + ' -' + c.key + '=' + c.value,
                '',
              )
        };\n`,
      '',
    );
  }

  parseScssToWebgalStyleObj(scssString: string): IWebGALStyleObj{
    return scss2cssinjsParser(scssString);
  }

}

export { ADD_NEXT_ARG_LIST, SCRIPT_CONFIG };
export { sceneTextPreProcess };



================================================
FILE: parser/src/sceneParser.ts
================================================
import {
  commandType,
  IAsset,
  IScene,
  ISentence,
} from './interface/sceneInterface';
import { scriptParser } from './scriptParser/scriptParser';
import uniqWith from 'lodash/uniqWith';
import { fileType } from './interface/assets';
import { ConfigMap } from './config/scriptConfig';

/**
 * 场景解析器
 * @param rawScene 原始场景
 * @param sceneName 场景名称
 * @param sceneUrl 场景url
 * @param assetsPrefetcher
 * @param assetSetter
 * @param ADD_NEXT_ARG_LIST
 * @param SCRIPT_CONFIG_MAP
 * @return {IScene} 解析后的场景
 */
export const sceneParser = (
  rawScene: string,
  sceneName: string,
  sceneUrl: string,
  assetsPrefetcher: (assetList: Array<IAsset>) => void,
  assetSetter: (fileName: string, assetType: fileType) => string,
  ADD_NEXT_ARG_LIST: commandType[],
  SCRIPT_CONFIG_MAP: ConfigMap,
): IScene => {
  const rawSentenceList = rawScene.split('\n'); // 原始句子列表

  // 去分号留到后面去做了，现在注释要单独处理
  const rawSentenceListWithoutEmpty = rawSentenceList;
  // .map((sentence) => sentence.split(";")[0])
  // .filter((sentence) => sentence.trim() !== "");
  let assetsList: Array<IAsset> = []; // 场景资源列表
  let subSceneList: Array<string> = []; // 子场景列表
  const sentenceList: Array<ISentence> = rawSentenceListWithoutEmpty.map(
    (sentence) => {
      const returnSentence: ISentence = scriptParser(
        sentence,
        assetSetter,
        ADD_NEXT_ARG_LIST,
        SCRIPT_CONFIG_MAP,
      );
      // 在这里解析出语句可能携带的资源和场景，合并到 assetsList 和 subSceneList
      assetsList = [...assetsList, ...returnSentence.sentenceAssets];
      subSceneList = [...subSceneList, ...returnSentence.subScene];
      return returnSentence;
    },
  );

  // 开始资源的预加载
  assetsList = uniqWith(assetsList); // 去重
  assetsPrefetcher(assetsList);

  return {
    sceneName: sceneName, // 场景名称
    sceneUrl: sceneUrl,
    sentenceList: sentenceList, // 语句列表
    assetsList: assetsList, // 资源列表
    subSceneList: subSceneList, // 子场景列表
  };
};



================================================
FILE: parser/src/sceneTextPreProcessor.ts
================================================
/**
 * Preprocessor for scene text.
 *
 * Use two-pass to generate a new scene text that concats multiline sequences
 * into a single line and add placeholder lines to preserve the original number
 * of lines.
 *
 * @param sceneText The original scene text
 * @returns The processed scene text
 */
export function sceneTextPreProcess(sceneText: string): string {
  let lines = sceneText.replaceAll('\r', '').split('\n');

  lines = sceneTextPreProcessPassOne(lines);
  lines = sceneTextPreProcessPassTwo(lines);

  return lines.join('\n');
}

/**
 * Pass one.
 *
 * Add escape character to all lines that should be multiline.
 *
 * @param lines The original lines
 * @returns The processed lines
 */
function sceneTextPreProcessPassOne(lines: string[]): string[] {
  const processedLines: string[] = [];
  let lastLineIsMultiline = false;
  let thisLineIsMultiline = false;

  for (const line of lines) {
    thisLineIsMultiline = false;

    if (canBeMultiline(line)) {
      thisLineIsMultiline = true;
    }

    if (shouldNotBeMultiline(line, lastLineIsMultiline)) {
      thisLineIsMultiline = false;
    }

    if (thisLineIsMultiline) {
      processedLines[processedLines.length - 1] += '\\';
    }

    processedLines.push(line);

    lastLineIsMultiline = thisLineIsMultiline;
  }

  return processedLines;
}

function canBeMultiline(line: string): boolean {
  if (!line.startsWith(' ')) {
    return false;
  }

  const trimmedLine = line.trimStart();
  return trimmedLine.startsWith('|') || trimmedLine.startsWith('-');
}

/**
 * Logic to check if a line should not be multiline.
 *
 * @param line The line to check
 * @returns If the line should not be multiline
 */
function shouldNotBeMultiline(line: string, lastLineIsMultiline: boolean): boolean {
  if (!lastLineIsMultiline && isEmptyLine(line)) {
    return true;
  }

  // Custom logic: if the line contains -concat, it should not be multiline
  if (line.indexOf('-concat') !== -1) {
    return true;
  }

  return false;
}

function isEmptyLine(line: string): boolean {
  return line.trim() === '';
}


/**
 * Pass two.
 *
 * Traverse the lines to
 * - remove escape characters
 * - add placeholder lines to preserve the original number of lines.
 *
 * @param lines The lines in pass one
 * @returns The processed lines
 */
function sceneTextPreProcessPassTwo(lines: string[]): string[] {
  const processedLines: string[] = [];
  let currentMultilineContent = "";
  let placeHolderLines: string[] = [];

  function concat(line: string) {
    let trimmed = line.trim();
    if (trimmed.startsWith('-')) {
      trimmed = " " + trimmed;
    }
    currentMultilineContent = currentMultilineContent + trimmed;
    placeHolderLines.push(placeholderLine(line));
  }

  for (const line of lines) {
    console.log(line);
    if (line.endsWith('\\')) {
      const trueLine = line.slice(0, -1);

      if (currentMultilineContent === "") {
        // first line
        currentMultilineContent = trueLine;
      } else {
        // middle line
        concat(trueLine);
      }
      continue;
    }

    if (currentMultilineContent !== "") {
      // end line
      concat(line);
      processedLines.push(currentMultilineContent);
      processedLines.push(...placeHolderLines);

      placeHolderLines = [];
      currentMultilineContent = "";
      continue;
    }

    processedLines.push(line);
  }

  return processedLines;
}

/**
 * Placeholder Line. Adding this line preserves the original number of lines
 * in the scene text, so that it can be compatible with the graphical editor.
 *
 * @param content The original content on this line
 * @returns The placeholder line
 */
function placeholderLine(content = "") {
  return ";_WEBGAL_LINE_BREAK_" + content;
}

// export function sceneTextPreProcess(sceneText: string): string {
//   const lines = sceneText.replaceAll('\r', '').split('\n');
//   const processedLines: string[] = [];
//   let lastNonMultilineIndex = -1;
//   let isInMultilineSequence = false;

//   function isMultiline(line: string): boolean {
//     if (!line.startsWith(' ')) return false;
//     const trimmedLine = line.trimStart();
//     return trimmedLine.startsWith('|') || trimmedLine.startsWith('-');
//   }

//   for (let i = 0; i < lines.length; i++) {
//     const line = lines[i];

//     if (line.trim() === '') {
//       // Empty line handling
//       if (isInMultilineSequence) {
//         // Check if the next line is a multiline line

//         let isStillInMulti = false;
//         for (let j = i + 1; j < lines.length; j++) {
//           const lookForwardLine = lines[j] || '';
//           // 遇到正常语句了，直接中断
//           if (lookForwardLine.trim() !== '' && !isMultiline(lookForwardLine)) {
//             isStillInMulti = false;
//             break;
//           }
//           // 必须找到后面接的是参数，并且中间没有遇到任何正常语句才行
//           if (lookForwardLine.trim() !== '' && isMultiline(lookForwardLine)) {
//             isStillInMulti = true;
//             break;
//           }
//         }
//         if (isStillInMulti) {
//           // Still within a multiline sequence
//           processedLines.push(';_WEBGAL_LINE_BREAK_');
//         } else {
//           // End of multiline sequence
//           isInMultilineSequence = false;
//           processedLines.push(line);
//         }
//       } else {
//         // Preserve empty lines outside of multiline sequences
//         processedLines.push(line);
//       }
//     } else if (isMultiline(line)) {
//       // Multiline statement handling
//       if (lastNonMultilineIndex >= 0) {
//         // Concatenate to the previous non-multiline statement
//         const trimedLine = line.trimStart();
//         const addBlank = trimedLine.startsWith('-') ? ' ' : '';
//         processedLines[lastNonMultilineIndex] += addBlank + trimedLine;
//       }

//       // Add the special comment line
//       processedLines.push(';_WEBGAL_LINE_BREAK_' + line);
//       isInMultilineSequence = true;
//     } else {
//       // Non-multiline statement handling
//       processedLines.push(line);
//       lastNonMultilineIndex = processedLines.length - 1;
//       isInMultilineSequence = false;
//     }
//   }

//   return processedLines.join('\n');
// }


================================================
FILE: parser/src/config/scriptConfig.ts
================================================
import {commandType} from '../interface/sceneInterface';

export const SCRIPT_CONFIG = [
  { scriptString: 'say', scriptType: commandType.say },
  { scriptString: 'changeBg', scriptType: commandType.changeBg },
  { scriptString: 'changeFigure', scriptType: commandType.changeFigure },
  { scriptString: 'bgm', scriptType: commandType.bgm },
  { scriptString: 'playVideo', scriptType: commandType.video },
  { scriptString: 'pixiPerform', scriptType: commandType.pixi },
  { scriptString: 'pixiInit', scriptType: commandType.pixiInit },
  { scriptString: 'intro', scriptType: commandType.intro },
  { scriptString: 'miniAvatar', scriptType: commandType.miniAvatar },
  { scriptString: 'changeScene', scriptType: commandType.changeScene },
  { scriptString: 'choose', scriptType: commandType.choose },
  { scriptString: 'end', scriptType: commandType.end },
  {
    scriptString: 'setComplexAnimation',
    scriptType: commandType.setComplexAnimation,
  },
  { scriptString: 'setFilter', scriptType: commandType.setFilter },
  { scriptString: 'label', scriptType: commandType.label },
  { scriptString: 'jumpLabel', scriptType: commandType.jumpLabel },
  { scriptString: 'chooseLabel', scriptType: commandType.chooseLabel },
  { scriptString: 'setVar', scriptType: commandType.setVar },
  { scriptString: 'if', scriptType: commandType.if },
  { scriptString: 'callScene', scriptType: commandType.callScene },
  { scriptString: 'showVars', scriptType: commandType.showVars },
  { scriptString: 'unlockCg', scriptType: commandType.unlockCg },
  { scriptString: 'unlockBgm', scriptType: commandType.unlockBgm },
  { scriptString: 'filmMode', scriptType: commandType.filmMode },
  { scriptString: 'setTextbox', scriptType: commandType.setTextbox },
  { scriptString: 'setAnimation', scriptType: commandType.setAnimation },
  { scriptString: 'playEffect', scriptType: commandType.playEffect },
  { scriptString: 'setTempAnimation', scriptType: commandType.setTempAnimation },
  // comment?
  { scriptString: 'setTransform', scriptType: commandType.setTransform },
  { scriptString: 'setTransition', scriptType: commandType.setTransition },
  { scriptString: 'getUserInput', scriptType: commandType.getUserInput },
  { scriptString: 'applyStyle', scriptType: commandType.applyStyle },
  { scriptString: 'wait', scriptType: commandType.wait },
];
export const ADD_NEXT_ARG_LIST = [
  commandType.bgm,
  commandType.pixi,
  commandType.pixiInit,
  commandType.miniAvatar,
  commandType.label,
  commandType.if,
  commandType.setVar,
  commandType.unlockCg,
  commandType.unlockBgm,
  commandType.filmMode,
  commandType.playEffect,
  commandType.setTransition,
  commandType.applyStyle,
];

export type ConfigMap = Map<string, ConfigItem>;
export type ConfigItem = { scriptString: string; scriptType: commandType };



================================================
FILE: parser/src/configParser/configParser.ts
================================================
import { argsParser } from '../scriptParser/argsParser';

interface IOptionItem {
  key: string;
  value: string | number | boolean;
}
interface IConfigItem {
  command: string;
  args: string[];
  options: IOptionItem[];
}

export type WebgalConfig = IConfigItem[];

function configLineParser(inputLine: string): IConfigItem {
  const options: Array<IOptionItem> = [];
  let command: string;

  let newSentenceRaw = inputLine.split(';')[0];
  if (newSentenceRaw === '') {
    // 注释提前返回
    return {
      command: '',
      args: [],
      options: [],
    };
  }
  // 截取命令
  const getCommandResult = /\s*:\s*/.exec(newSentenceRaw);

  // 没有command
  if (getCommandResult === null) {
    command = '';
  } else {
    command = newSentenceRaw.substring(0, getCommandResult.index);
    // 划分命令区域和content区域
    newSentenceRaw = newSentenceRaw.substring(
      getCommandResult.index + 1,
      newSentenceRaw.length,
    );
  }
  // 截取 Options 区域
  const getOptionsResult = / -/.exec(newSentenceRaw);
  // 获取到参数
  if (getOptionsResult) {
    const optionsRaw = newSentenceRaw.substring(
      getOptionsResult.index,
      newSentenceRaw.length,
    );
    newSentenceRaw = newSentenceRaw.substring(0, getOptionsResult.index);
    for (const e of argsParser(optionsRaw, (name, _) => {
      return name;
    })) {
      options.push(e);
    }
  }
  return {
    command,
    args: newSentenceRaw
      .split('|')
      .map((e) => e.trim())
      .filter((e) => e !== ''),
    options,
  };
}

export function configParser(configText: string): WebgalConfig {
  const configLines = configText.replaceAll(`\r`, '').split('\n');
  return configLines
    .map((e) => configLineParser(e))
    .filter((e) => e.command !== '');
}



================================================
FILE: parser/src/interface/assets.ts
================================================
/**
 * 内置资源类型的枚举
 */
export enum fileType {
  background,
  bgm,
  figure,
  scene,
  tex,
  vocal,
  video,
}



================================================
FILE: parser/src/interface/runtimeInterface.ts
================================================
/**
 * 子场景结束后回到父场景的入口
 * @interface sceneEntry
 */
export interface sceneEntry {
  sceneName: string; // 场景名称
  sceneUrl: string; // 场景url
  continueLine: number; // 继续原场景的行号
}

/**
 * 场景栈条目接口 (兼容性别名)
 * @interface ISceneEntry
 */
export interface ISceneEntry extends sceneEntry {}



================================================
FILE: parser/src/interface/sceneInterface.ts
================================================
/**
 * 语句类型
 */
import { sceneEntry, ISceneEntry } from './runtimeInterface';
import { fileType } from './assets';

export enum commandType {
  say, // 对话
  changeBg, // 更改背景
  changeFigure, // 更改立绘
  bgm, // 更改背景音乐
  video, // 播放视频
  pixi, // pixi演出
  pixiInit, // pixi初始化
  intro, // 黑屏文字演示
  miniAvatar, // 小头像
  changeScene, // 切换场景
  choose, // 分支选择
  end, // 结束游戏
  setComplexAnimation, // 动画演出
  setFilter, // 设置效果
  label, // 标签
  jumpLabel, // 跳转标签
  chooseLabel, // 选择标签
  setVar, // 设置变量
  if, // 条件跳转
  callScene, // 调用场景
  showVars,
  unlockCg,
  unlockBgm,
  filmMode,
  setTextbox,
  setAnimation,
  playEffect,
  setTempAnimation,
  comment,
  setTransform,
  setTransition,
  getUserInput,
  applyStyle,
  wait,
}

/**
 * 单个参数接口
 * @interface arg
 */
export interface arg {
  key: string; // 参数键
  value: string | boolean | number; // 参数值
}

/**
 * 资源接口
 * @interface IAsset
 */
export interface IAsset {
  name: string; // 资源名称
  type: fileType; // 资源类型
  url: string; // 资源url
  lineNumber: number; // 触发资源语句的行号
}

/**
 * 单条语句接口
 * @interface ISentence
 */
export interface ISentence {
  command: commandType; // 语句类型
  commandRaw: string; // 命令的原始内容，方便调试
  content: string; // 语句内容
  args: Array<arg>; // 参数列表
  sentenceAssets: Array<IAsset>; // 语句携带的资源列表
  subScene: Array<string>; // 语句包含子场景列表
}

/**
 * 场景接口
 * @interface IScene
 */
export interface IScene {
  sceneName: string; // 场景名称
  sceneUrl: string; // 场景url
  sentenceList: Array<ISentence>; // 语句列表
  assetsList: Array<IAsset>; // 资源列表
  subSceneList: Array<string>; // 子场景的url列表
}

/**
 * 当前的场景数据
 * @interface ISceneData
 */
export interface ISceneData {
  currentSentenceId: number; // 当前语句ID
  sceneStack: Array<ISceneEntry>; // 场景栈
  currentScene: IScene; // 当前场景数据
}

/**
 * 处理后的命令接口
 * @interface parsedCommand
 */
export interface parsedCommand {
  type: commandType;
  additionalArgs: Array<arg>;
}



================================================
FILE: parser/src/parser4/index.ts
================================================
// (function jsonGrammarOnlyExample() {
//   // ----------------- Lexer -----------------
//   const createToken = chevrotain.createToken;
//   const Lexer = chevrotain.Lexer;
//
//   const True = createToken({ name: "True", pattern: /true/ });
//   const False = createToken({ name: "False", pattern: /false/ });
//   const LCurly = createToken({ name: "LCurly", pattern: /{/ });
//   const RCurly = createToken({ name: "RCurly", pattern: /}/ });
//   const LSquare = createToken({ name: "LSquare", pattern: /\[/ });
//   const RSquare = createToken({ name: "RSquare", pattern: /]/ });
//   const Comma = createToken({ name: "Comma", pattern: /,/ });
//   const Colon = createToken({ name: "Colon", pattern: /:/ });
//   const Lf = createToken({ name: "LF", pattern: /\n/ });
//   const Semi = createToken({ name: ";", pattern: /;/ });
//   const Command = createToken({ name: "Command", pattern: /Command/ });
//   const ArgS = createToken({ name: " -", pattern: / -/ });
//   const StringLiteral = createToken({
//     name: "StringLiteral", pattern: /(?!(?:true|false|Command)\b)\w+/
//   });
//   const NumberLiteral = createToken({
//     name: "NumberLiteral", pattern: /-?(0|[1-9]\d*)(\.\d+)?([eE][+-]?\d+)?/
//   });
//
//   const Equal = createToken({
//     name: "=",
//     pattern: /=/
//   });
//
//   const webgalTokens = [NumberLiteral, StringLiteral, RCurly, LCurly,
//     LSquare, RSquare, Comma, Colon, True, False, Equal, Command, ArgS, Lf, Semi];
//
//   const WebGalLexer = new Lexer(webgalTokens, {
//     // Less position info tracked, reduces verbosity of the playground output.
//     positionTracking: "onlyStart"
//   });
//
//   // Labels only affect error messages and Diagrams.
//   LCurly.LABEL = "'{'";
//   RCurly.LABEL = "'}'";
//   LSquare.LABEL = "'['";
//   RSquare.LABEL = "']'";
//   Comma.LABEL = "','";
//   Colon.LABEL = "':'";
//
//
//   // ----------------- parser -----------------
//   const CstParser = chevrotain.CstParser;
//
//   class webgalScriptParser extends CstParser {
//     constructor() {
//       super(webgalTokens, {
//         recoveryEnabled: true
//       });
//
//       const $ = this;
//
//       $.RULE("scene", () => {
//         $.MANY_SEP({
//           SEP: Lf, DEF: () => {
//             $.SUBRULE($.sentence);
//           }
//         });
//       });
//
//       $.RULE("sentence", () => {
//         $.OR([
//           { ALT: () => $.SUBRULE($.commonSentence) },
//           { ALT: () => $.SUBRULE($.comment) }
//         ]);
//       });
//
//       $.RULE("commonSentence", () => {
//         $.OR([
//           { ALT: () => $.SUBRULE($.commandSentence) },
//           { ALT: () => $.SUBRULE($.dialog) }
//         ]);
//         $.OPTION(() => {
//           $.CONSUME(Semi);
//         });
//       });
//
//       $.RULE("comment", () => {
//         $.CONSUME(Semi);
//         $.CONSUME(StringLiteral);
//       });
//
//       $.RULE("dialog", () => {
//         $.CONSUME(StringLiteral);
//
//       });
//
//
//       $.RULE("commandSentence", () => {
//         $.CONSUME(Command);
//         $.CONSUME(Colon);
//         $.CONSUME(StringLiteral);
//         $.OPTION(() => {
//           $.SUBRULE($.args);
//         });
//       });
//
//       $.RULE("args", () => {
//         $.CONSUME(ArgS);
//         $.MANY_SEP({
//           SEP: ArgS, DEF: () => {
//             $.SUBRULE($.arg);
//           }
//         });
//       });
//
//       $.RULE("arg", () => {
//         $.CONSUME(StringLiteral);
//         $.CONSUME(Equal);
//         $.SUBRULE($.argv);
//       });
//
//       $.RULE("argv", () => {
//         $.OR([
//           {
//             ALT: () => {
//               this.CONSUME(StringLiteral);
//             }
//           },
//           {
//             ALT: () => {
//               this.CONSUME(NumberLiteral);
//             }
//           },
//           {
//             ALT: () => {
//               this.CONSUME(True);
//             }
//           },
//           {
//             ALT: () => {
//               this.CONSUME(False);
//             }
//           }]);
//       });
//
//       // very important to call this after all the rules have been setup.
//       // otherwise the parser may not work correctly as it will lack information
//       // derived from the self analysis.
//       this.performSelfAnalysis();
//     }
//
//   }
//
//
//   // for the playground to work the returned object must contain these fields
//   return {
//     lexer: WebGalLexer,
//     parser: webgalScriptParser,
//     defaultRule: "scene"
//   };
// }());
export const parser4 = 'unreleased';



================================================
FILE: parser/src/scriptParser/argsParser.ts
================================================
import { arg } from '../interface/sceneInterface';
import { fileType } from '../interface/assets';

/**
 * 参数解析器
 * @param argsRaw 原始参数字符串
 * @param assetSetter
 * @return {Array<arg>} 解析后的参数列表
 */
export function argsParser(
  argsRaw: string,
  assetSetter: (fileName: string, assetType: fileType) => string,
): Array<arg> {
  const returnArrayList: Array<arg> = [];
  // 处理参数
  // 不要去空格
  let newArgsRaw = argsRaw.replace(/ /g, ' ');
  // 分割参数列表
  let rawArgsList: Array<string> = newArgsRaw.split(' -');
  // 去除空字符串
  rawArgsList = rawArgsList.filter((e) => {
    return e !== '';
  });
  rawArgsList.forEach((e) => {
    const equalSignIndex = e.indexOf('=');
    let argName = e.slice(0, equalSignIndex);
    let argValue: string | undefined = e.slice(equalSignIndex + 1);
    if (equalSignIndex < 0) {
      argName = e;
      argValue = undefined;
    }
    // 判断是不是语音参数
    if (argName.toLowerCase().match(/.ogg|.mp3|.wav/)) {
      returnArrayList.push({
        key: 'vocal',
        value: assetSetter(e, fileType.vocal),
      });
    } else {
      // 判断是不是省略参数
      if (argValue === undefined) {
        returnArrayList.push({
          key: argName,
          value: true,
        });
      } else {
        // 是字符串描述的布尔值
        if (argValue === 'true' || argValue === 'false') {
          returnArrayList.push({
            key: argName,
            value: argValue === 'true',
          });
        } else {
          // 是数字
          if (!isNaN(Number(argValue))) {
            returnArrayList.push({
              key: argName,
              value: Number(argValue),
            });
          } else {
            // 是普通参数
            returnArrayList.push({
              key: argName,
              value: argValue,
            });
          }
        }
      }
    }
  });
  return returnArrayList;
}



================================================
FILE: parser/src/scriptParser/assetsScanner.ts
================================================
import { arg, commandType, IAsset } from '../interface/sceneInterface';
import { fileType } from '../interface/assets';

/**
 * 根据语句类型、语句内容、参数列表，扫描该语句可能携带的资源
 * @param command 语句类型
 * @param content 语句内容
 * @param args 参数列表
 * @return {Array<IAsset>} 语句携带的参数列表
 */
export const assetsScanner = (
  command: commandType,
  content: string,
  args: Array<arg>,
): Array<IAsset> => {
  let hasVocalArg = false;
  const returnAssetsList: Array<IAsset> = [];
  if (command === commandType.say) {
    args.forEach((e) => {
      if (e.key === 'vocal') {
        hasVocalArg = true;
        returnAssetsList.push({
          name: e.value as string,
          url: e.value as string,
          lineNumber: 0,
          type: fileType.vocal,
        });
      }
    });
  }
  if (content === 'none' || content === '') {
    return returnAssetsList;
  }
  // 处理语句携带的资源
  if (command === commandType.changeBg) {
    returnAssetsList.push({
      name: content,
      url: content,
      lineNumber: 0,
      type: fileType.background,
    });
  }
  if (command === commandType.changeFigure) {
    returnAssetsList.push({
      name: content,
      url: content,
      lineNumber: 0,
      type: fileType.figure,
    });
  }
  if (command === commandType.miniAvatar) {
    returnAssetsList.push({
      name: content,
      url: content,
      lineNumber: 0,
      type: fileType.figure,
    });
  }
  if (command === commandType.video) {
    returnAssetsList.push({
      name: content,
      url: content,
      lineNumber: 0,
      type: fileType.video,
    });
  }
  if (command === commandType.bgm) {
    returnAssetsList.push({
      name: content,
      url: content,
      lineNumber: 0,
      type: fileType.bgm,
    });
  }
  return returnAssetsList;
};



================================================
FILE: parser/src/scriptParser/commandParser.ts
================================================
import { ConfigMap } from '../config/scriptConfig';
import { commandType, parsedCommand } from '../interface/sceneInterface';

/**
 * 处理命令
 * @param commandRaw
 * @param ADD_NEXT_ARG_LIST
 * @param SCRIPT_CONFIG_MAP
 * @return {parsedCommand} 处理后的命令
 */
export const commandParser = (
  commandRaw: string,
  ADD_NEXT_ARG_LIST: commandType[],
  SCRIPT_CONFIG_MAP: ConfigMap,
): parsedCommand => {
  let returnCommand: parsedCommand = {
    type: commandType.say, // 默认是say
    additionalArgs: [],
  };
  // 开始处理命令内容
  const type: commandType = getCommandType(
    commandRaw,
    ADD_NEXT_ARG_LIST,
    SCRIPT_CONFIG_MAP,
  );
  returnCommand.type = type;
  // 如果是对话，加上额外的参数
  if (type === commandType.say && commandRaw !== 'say') {
    returnCommand.additionalArgs.push({
      key: 'speaker',
      value: commandRaw,
    });
  }
  returnCommand = addNextArg(returnCommand, type, ADD_NEXT_ARG_LIST);
  return returnCommand;
};

/**
 * 根据command原始值判断是什么命令
 * @param command command原始值
 * @param ADD_NEXT_ARG_LIST
 * @param SCRIPT_CONFIG_MAP
 * @return {commandType} 得到的command类型
 */
function getCommandType(
  command: string,
  ADD_NEXT_ARG_LIST: commandType[],
  SCRIPT_CONFIG_MAP: ConfigMap,
): commandType {
  return SCRIPT_CONFIG_MAP.get(command)?.scriptType ?? commandType.say;
}

function addNextArg(
  commandToParse: parsedCommand,
  thisCommandType: commandType,
  ADD_NEXT_ARG_LIST: commandType[],
) {
  if (ADD_NEXT_ARG_LIST.includes(thisCommandType)) {
    commandToParse.additionalArgs.push({
      key: 'next',
      value: true,
    });
  }
  return commandToParse;
}



================================================
FILE: parser/src/scriptParser/contentParser.ts
================================================
import { commandType } from '../interface/sceneInterface';
import { fileType } from '../interface/assets';

/**
 * 解析语句内容的函数，主要作用是把文件名改为绝对地址或相对地址（根据使用情况而定）
 * @param contentRaw 原始语句内容
 * @param type 语句类型
 * @param assetSetter
 * @return {string} 解析后的语句内容
 */
export const contentParser = (
  contentRaw: string,
  type: commandType,
  assetSetter: any,
) => {
  if (contentRaw === 'none' || contentRaw === '') {
    return '';
  }
  switch (type) {
    case commandType.playEffect:
      return assetSetter(contentRaw, fileType.vocal);
    case commandType.changeBg:
      return assetSetter(contentRaw, fileType.background);
    case commandType.changeFigure:
      return assetSetter(contentRaw, fileType.figure);
    case commandType.bgm:
      return assetSetter(contentRaw, fileType.bgm);
    case commandType.callScene:
      return assetSetter(contentRaw, fileType.scene);
    case commandType.changeScene:
      return assetSetter(contentRaw, fileType.scene);
    case commandType.miniAvatar:
      return assetSetter(contentRaw, fileType.figure);
    case commandType.video:
      return assetSetter(contentRaw, fileType.video);
    case commandType.choose:
      return getChooseContent(contentRaw, assetSetter);
    case commandType.unlockBgm:
      return assetSetter(contentRaw, fileType.bgm);
    case commandType.unlockCg:
      return assetSetter(contentRaw, fileType.background);
    default:
      return contentRaw;
  }
};

function getChooseContent(contentRaw: string, assetSetter: any): string {
  const chooseList = contentRaw.split(/(?<!\\)\|/);
  const chooseKeyList: Array<string> = [];
  const chooseValueList: Array<string> = [];
  for (const e of chooseList) {
    chooseKeyList.push(e.split(/(?<!\\):/)[0] ?? '');
    chooseValueList.push(e.split(/(?<!\\):/)[1] ?? '');
  }
  const parsedChooseList = chooseValueList.map((e) => {
    if (e.match(/\./)) {
      return assetSetter(e, fileType.scene);
    } else {
      return e;
    }
  });
  let ret = '';
  for (let i = 0; i < chooseKeyList.length; i++) {
    if (i !== 0) {
      ret = ret + '|';
    }
    ret = ret + `${chooseKeyList[i]}:${parsedChooseList[i]}`;
  }
  return ret;
}



================================================
FILE: parser/src/scriptParser/scriptParser.ts
================================================
import {
  arg,
  commandType,
  IAsset,
  ISentence,
  parsedCommand,
} from '../interface/sceneInterface';
import { commandParser } from './commandParser';
import { argsParser } from './argsParser';
import { contentParser } from './contentParser';
import { assetsScanner } from './assetsScanner';
import { subSceneScanner } from './subSceneScanner';
import { ConfigMap } from '../config/scriptConfig';

/**
 * 语句解析器
 * @param sentenceRaw 原始语句
 * @param assetSetter
 * @param ADD_NEXT_ARG_LIST
 * @param SCRIPT_CONFIG_MAP
 */
export const scriptParser = (
  sentenceRaw: string,
  assetSetter: any,
  ADD_NEXT_ARG_LIST: commandType[],
  SCRIPT_CONFIG_MAP: ConfigMap,
): ISentence => {
  let command: commandType; // 默认为对话
  let content: string; // 语句内容
  let subScene: Array<string>; // 语句携带的子场景（可能没有）
  const args: Array<arg> = []; // 语句参数列表
  let sentenceAssets: Array<IAsset>; // 语句携带的资源列表
  let parsedCommand: parsedCommand; // 解析后的命令
  let commandRaw: string;

  // 正式开始解析

  // 去分号
  let newSentenceRaw = sentenceRaw.split(/(?<!\\);/)[0];
  newSentenceRaw = newSentenceRaw.replaceAll('\\;',';');
  if (newSentenceRaw === '') {
    // 注释提前返回
    return {
      command: commandType.comment, // 语句类型
      commandRaw: 'comment', // 命令原始内容，方便调试
      content: sentenceRaw.split(';')[1] ?? '', // 语句内容
      args: [{ key: 'next', value: true }], // 参数列表
      sentenceAssets: [], // 语句携带的资源列表
      subScene: [], // 语句携带的子场景
    };
  }
  // 截取命令
  const getCommandResult = /:/.exec(newSentenceRaw);
  /**
   * 拆分命令和语句，同时处理连续对话。
   */
  // 没有command，说明这是一条连续对话或单条语句
  if (getCommandResult === null) {
    commandRaw = newSentenceRaw;
    parsedCommand = commandParser(
      commandRaw,
      ADD_NEXT_ARG_LIST,
      SCRIPT_CONFIG_MAP,
    );
    command = parsedCommand.type;
    for (const e of parsedCommand.additionalArgs) {
      // 由于是连续对话，所以我们去除 speaker 参数。
      if (command === commandType.say && e.key === 'speaker') {
        continue;
      }
      args.push(e);
    }
  } else {
    commandRaw = newSentenceRaw.substring(0, getCommandResult.index);
    // 划分命令区域和content区域
    newSentenceRaw = newSentenceRaw.substring(
      getCommandResult.index + 1,
      newSentenceRaw.length,
    );
    parsedCommand = commandParser(
      commandRaw,
      ADD_NEXT_ARG_LIST,
      SCRIPT_CONFIG_MAP,
    );
    command = parsedCommand.type;
    for (const e of parsedCommand.additionalArgs) {
      args.push(e);
    }
  }
  // 截取参数区域
  const getArgsResult = / -/.exec(newSentenceRaw);
  // 获取到参数
  if (getArgsResult) {
    const argsRaw = newSentenceRaw.substring(
      getArgsResult.index,
      sentenceRaw.length,
    );
    newSentenceRaw = newSentenceRaw.substring(0, getArgsResult.index);
    for (const e of argsParser(argsRaw, assetSetter)) {
      args.push(e);
    }
  }
  content = contentParser(newSentenceRaw.trim(), command, assetSetter); // 将语句内容里的文件名转为相对或绝对路径
  sentenceAssets = assetsScanner(command, content, args); // 扫描语句携带资源
  subScene = subSceneScanner(command, content); // 扫描语句携带子场景
  return {
    command: command, // 语句类型
    commandRaw: commandRaw.trim(), // 命令原始内容，方便调试
    content: content, // 语句内容
    args: args, // 参数列表
    sentenceAssets: sentenceAssets, // 语句携带的资源列表
    subScene: subScene, // 语句携带的子场景
  };
};



================================================
FILE: parser/src/scriptParser/subSceneScanner.ts
================================================
/**
 * 扫描子场景
 * @param content 语句内容
 * @return {Array<string>} 子场景列表
 */
import { commandType } from '../interface/sceneInterface';

export const subSceneScanner = (
  command: commandType,
  content: string,
): Array<string> => {
  const subSceneList: Array<string> = [];
  if (
    command === commandType.changeScene ||
    command === commandType.callScene
  ) {
    subSceneList.push(content);
  }
  if (command === commandType.choose) {
    const chooseList = content.split('|');
    const chooseValue = chooseList.map((e) => e.split(':')[1] ?? '');
    chooseValue.forEach((e) => {
      if (e.match(/\./)) {
        subSceneList.push(e);
      }
    });
  }
  return subSceneList;
};



================================================
FILE: parser/src/styleParser/index.ts
================================================
export interface IWebGALStyleObj {
  classNameStyles: Record<string, string>;
  others: string;
}

export function scss2cssinjsParser(scssString: string): IWebGALStyleObj {
  const [classNameStyles, others] = parseCSS(scssString);
  return {
    classNameStyles,
    others,
  };
}

/**
 * GPT 4 写的，临时用，以后要重构！！！
 * TODO：用人类智能重构，要是用着一直没问题，也不是不可以 trust AI
 * @param css
 */
function parseCSS(css: string): [Record<string, string>, string] {
  const result: Record<string, string> = {};
  let specialRules = '';
  let matches;

  // 使用非贪婪匹配，尝试正确处理任意层次的嵌套
  const classRegex = /\.([^{\s]+)\s*{((?:[^{}]*|{[^}]*})*)}/g;
  const specialRegex = /(@[^{]+{\s*(?:[^{}]*{[^}]*}[^{}]*)+\s*})/g;

  while ((matches = classRegex.exec(css)) !== null) {
    const key = matches[1];
    const value = matches[2].trim().replace(/\s*;\s*/g, ';\n');
    result[key] = value;
  }

  while ((matches = specialRegex.exec(css)) !== null) {
    specialRules += matches[1].trim() + '\n';
  }

  return [result, specialRules.trim()];
}



================================================
FILE: parser/test/debug-linebreak.ts
================================================
import {sceneTextPreProcess} from "../src/sceneTextPreProcessor";
import *  as fsp from "fs/promises";


async function debug() {
  const sceneRaw = await fsp.readFile('test/test-resources/line-break.txt');
  const sceneText = sceneRaw.toString();
  const result = sceneTextPreProcess(sceneText)
  console.log(result)
  console.log(result.split('\n').length)
}

debug();



================================================
FILE: parser/test/debug.ts
================================================
import *  as fsp from "fs/promises";
import SceneParser, {ADD_NEXT_ARG_LIST, SCRIPT_CONFIG} from "../src";


async function debug() {
  const sceneRaw = await fsp.readFile('test/test-resources/var.txt');
  const sceneText = sceneRaw.toString();

  const parser = new SceneParser((assetList) => {
  }, (fileName, assetType) => {
    return fileName;
  }, ADD_NEXT_ARG_LIST, SCRIPT_CONFIG);

  const result = parser.parse(sceneText, "var", "/var.txt");
  console.log(result)
  const configFesult = parser.parseConfig(`
Game_name:欢迎使用WebGAL！;
Game_key:0f86dstRf;
Title_img:WebGAL_New_Enter_Image.webp;
Title_bgm:s_Title.mp3;
Title_logos: 1.png | 2.png | Image Logo.png| -show -active=false -add=op! -count=3;This is a fake config, do not reference anything.
  `)
  console.log(configFesult)
  console.log(parser.stringifyConfig(configFesult))
}

debug();



================================================
FILE: parser/test/debugCssParser.ts
================================================
import *  as fsp from "fs/promises";
import SceneParser, {ADD_NEXT_ARG_LIST, SCRIPT_CONFIG} from "../src";


async function debug() {
  const sceneRaw = await fsp.readFile('test/test-resources/debug.scss');
  const sceneText = sceneRaw.toString();

  const parser = new SceneParser((assetList) => {
  }, (fileName, assetType) => {
    return fileName;
  }, ADD_NEXT_ARG_LIST, SCRIPT_CONFIG);

  const configFesult = parser.parseScssToWebgalStyleObj(sceneText)
  console.log(configFesult)
}

debug();



================================================
FILE: parser/test/parser.test.ts
================================================
import SceneParser from "../src/index";
import { ADD_NEXT_ARG_LIST, SCRIPT_CONFIG } from "../src/config/scriptConfig";
import { expect, test } from "vitest";
import { commandType, ISentence } from "../src/interface/sceneInterface";
import * as fsp from 'fs/promises';
import { fileType } from "../src/interface/assets";

test("label", async () => {

  const sceneRaw = await fsp.readFile('test/test-resources/start.txt');
  const sceneText = sceneRaw.toString();

  const parser = new SceneParser((assetList) => {
  }, (fileName, assetType) => {
    return fileName;
  }, ADD_NEXT_ARG_LIST, SCRIPT_CONFIG);

  const result = parser.parse(sceneText, "start", "/start.txt");
  const expectSentenceItem: ISentence = {
    command: commandType.label,
    commandRaw: "label",
    content: "end",
    args: [
      { key: "next", value: true }
    ],
    sentenceAssets: [],
    subScene: []
  };
  expect(result.sentenceList).toContainEqual(expectSentenceItem);
});

test("args", async () => {

  const sceneRaw = await fsp.readFile('test/test-resources/start.txt');
  const sceneText = sceneRaw.toString();

  const parser = new SceneParser((assetList) => {
  }, (fileName, assetType) => {
    return fileName;
  }, ADD_NEXT_ARG_LIST, SCRIPT_CONFIG);

  const result = parser.parse(sceneText, "start", "/start.txt");
  const expectSentenceItem: ISentence = {
    command: commandType.changeFigure,
    commandRaw: "changeFigure",
    content: "m2.png",
    args: [
      { key: "left", value: true },
      { key: "next", value: true }
    ],
    sentenceAssets: [{ name: "m2.png", url: 'm2.png', type: fileType.figure, lineNumber: 0 }],
    subScene: []
  };
  expect(result.sentenceList).toContainEqual(expectSentenceItem);
});

test("choose", async () => {

  const sceneRaw = await fsp.readFile('test/test-resources/choose.txt');
  const sceneText = sceneRaw.toString();

  const parser = new SceneParser((assetList) => {
  }, (fileName, assetType) => {
    return fileName;
  }, ADD_NEXT_ARG_LIST, SCRIPT_CONFIG);

  const result = parser.parse(sceneText, "choose", "/choose.txt");
  const expectSentenceItem: ISentence = {
    command: commandType.choose,
    commandRaw: "choose",
    content: "",
    args: [],
    sentenceAssets: [],
    subScene: []
  };
  expect(result.sentenceList).toContainEqual(expectSentenceItem);
});

test("long-script", async () => {

  const sceneRaw = await fsp.readFile('test/test-resources/long-script.txt');
  const sceneText = sceneRaw.toString();

  const parser = new SceneParser((assetList) => {
  }, (fileName, assetType) => {
    return fileName;
  }, ADD_NEXT_ARG_LIST, SCRIPT_CONFIG);

  console.log('line count:', sceneText.split('\n').length);
  console.time('parse-time-consumed');
  const result = parser.parse(sceneText, "start", "/start.txt");
  console.timeEnd('parse-time-consumed');
  const expectSentenceItem: ISentence = {
    command: commandType.label,
    commandRaw: "label",
    content: "end",
    args: [
      { key: "next", value: true }
    ],
    sentenceAssets: [],
    subScene: []
  };
  expect(result.sentenceList).toContainEqual(expectSentenceItem);
});

test("var", async () => {

  const sceneRaw = await fsp.readFile('test/test-resources/var.txt');
  const sceneText = sceneRaw.toString();

  const parser = new SceneParser((assetList) => {
  }, (fileName, assetType) => {
    return fileName;
  }, ADD_NEXT_ARG_LIST, SCRIPT_CONFIG);

  const result = parser.parse(sceneText, "var", "/var.txt");
  const expectSentenceItem: ISentence = {
    command: commandType.say,
    commandRaw: "WebGAL",
    content: "a=1?",
    args: [{ key: 'speaker', value: 'WebGAL' }, { key: 'when', value: "a==1" }],
    sentenceAssets: [],
    subScene: []
  };
  expect(result.sentenceList).toContainEqual(expectSentenceItem);
});

test("config", async () => {
  const parser = new SceneParser((assetList) => {
  }, (fileName, assetType) => {
    return fileName;
  }, ADD_NEXT_ARG_LIST, SCRIPT_CONFIG);

  const configFesult = parser.parseConfig(`
Game_name:欢迎使用WebGAL！;
Game_key:0f86dstRf;
Title_img:WebGAL_New_Enter_Image.webp;
Title_bgm:s_Title.mp3;
Title_logos: 1.png | 2.png | Image Logo.png| -show -active=false -add=op! -count=3;This is a fake config, do not reference anything.
  `);
  expect(configFesult).toContainEqual({
    command: 'Title_logos',
    args: ['1.png', '2.png', 'Image Logo.png'],
    options: [
      { key: 'show', value: true },
      { key: 'active', value: false },
      { key: 'add', value: 'op!' },
      { key: 'count', value: 3 },
    ]
  });
});

test("config-stringify", async () => {
  const parser = new SceneParser((assetList) => {
  }, (fileName, assetType) => {
    return fileName;
  }, ADD_NEXT_ARG_LIST, SCRIPT_CONFIG);

  const configFesult = parser.parseConfig(`
Game_name:欢迎使用WebGAL！;
Game_key:0f86dstRf;
Title_img:WebGAL_New_Enter_Image.webp;
Title_bgm:s_Title.mp3;
Title_logos: 1.png | 2.png | Image Logo.png| -show -active=false -add=op! -count=3;This is a fake config, do not reference anything.
  `);
  const stringifyResult = parser.stringifyConfig(configFesult);
  const configResult2 = parser.parseConfig(stringifyResult);
  expect(configResult2).toContainEqual({
    command: 'Title_logos',
    args: ['1.png', '2.png', 'Image Logo.png'],
    options: [
      { key: 'show', value: true },
      { key: 'active', value: false },
      { key: 'add', value: 'op!' },
      { key: 'count', value: 3 },
    ]
  });
});


test("say statement", async () => {
  const parser = new SceneParser((assetList) => {
  }, (fileName, assetType) => {
    return fileName;
  }, ADD_NEXT_ARG_LIST, SCRIPT_CONFIG);

  const result = parser.parse(`say:123 -speaker=xx;`, 'test', 'test');
  expect(result.sentenceList).toContainEqual({
    command: commandType.say,
    commandRaw: "say",
    content: "123",
    args: [{ key: 'speaker', value: 'xx' }],
    sentenceAssets: [],
    subScene: []
  });
});

test("wait command", async () => {
  const parser = new SceneParser((assetList) => {
  }, (fileName, assetType) => {
    return fileName;
  }, ADD_NEXT_ARG_LIST, SCRIPT_CONFIG);

  const result = parser.parse(`wait:1000;`, 'test', 'test');
  expect(result.sentenceList).toContainEqual({
    command: commandType.wait,
    commandRaw: "wait",
    content: "1000",
    args: [],
    sentenceAssets: [],
    subScene: []
  });
});

test("changeFigure with duration and animation args", async () => {
  const parser = new SceneParser((assetList) => {
  }, (fileName, assetType) => {
    return fileName;
  }, ADD_NEXT_ARG_LIST, SCRIPT_CONFIG);

  const result = parser.parse(`changeFigure:stand.webp -duration=1000 -enter=fadeIn -exit=fadeOut;`, 'test', 'test');
  expect(result.sentenceList).toContainEqual({
    command: commandType.changeFigure,
    commandRaw: "changeFigure",
    content: "stand.webp",
    args: [
      { key: 'duration', value: 1000 },
      { key: 'enter', value: 'fadeIn' },
      { key: 'exit', value: 'fadeOut' }
    ],
    sentenceAssets: [{ name: "stand.webp", url: 'stand.webp', type: fileType.figure, lineNumber: 0 }],
    subScene: []
  });
});

test("changeBg with animation parameters", async () => {
  const parser = new SceneParser((assetList) => {
  }, (fileName, assetType) => {
    return fileName;
  }, ADD_NEXT_ARG_LIST, SCRIPT_CONFIG);

  const result = parser.parse(`changeBg:background.jpg -duration=2000 -enter=slideIn -transform={"alpha":0.8};`, 'test', 'test');
  expect(result.sentenceList).toContainEqual({
    command: commandType.changeBg,
    commandRaw: "changeBg",
    content: "background.jpg",
    args: [
      { key: 'duration', value: 2000 },
      { key: 'enter', value: 'slideIn' },
      { key: 'transform', value: '{"alpha":0.8}' }
    ],
    sentenceAssets: [{ name: "background.jpg", url: 'background.jpg', type: fileType.background, lineNumber: 0 }],
    subScene: []
  });
});



================================================
FILE: parser/test/parserMultiline.test.ts
================================================
import { sceneTextPreProcess } from "../src/sceneTextPreProcessor";
import { expect, test } from "vitest";

test("parser-multiline-basic", async () => {
    const testScene = `changeFigure:a.png -left
  -next
  -id=id1

saySomething`;
    const expected = `changeFigure:a.png -left -next -id=id1
;_WEBGAL_LINE_BREAK_  -next
;_WEBGAL_LINE_BREAK_  -id=id1

saySomething`;

    const preprocessedScene = sceneTextPreProcess(testScene);
    expect(preprocessedScene).toEqual(expected);
});


test("parser-multiline-disable-when-encounter-concat-1", async () => {
    const testScene = `intro:aaa
  |bbb -concat
`;
    const expected = `intro:aaa
  |bbb -concat
`;

    const preprocessedScene = sceneTextPreProcess(testScene);
    expect(preprocessedScene).toEqual(expected);
});


test("parser-multiline-disable-when-encounter-concat-2", async () => {
    const testScene = `intro:aaa
  |bbb
  |ccc -concat
`;
    const expected = `intro:aaa|bbb
;_WEBGAL_LINE_BREAK_  |bbb
  |ccc -concat
`;

    const preprocessedScene = sceneTextPreProcess(testScene);
    expect(preprocessedScene).toEqual(expected);
});

test("parser-multiline-user-force-allow-multiline-in-concat", async () => {
    const testScene = String.raw`intro:aaa\
|bbb\
|ccc -concat
`;
    const expected = `intro:aaa|bbb|ccc -concat
;_WEBGAL_LINE_BREAK_|bbb
;_WEBGAL_LINE_BREAK_|ccc -concat
`;

    const preprocessedScene = sceneTextPreProcess(testScene);
    expect(preprocessedScene).toEqual(expected);
});

test("parser-multiline-others-same-as-before", async () => {
    const testScene = `听起来是不是非常吸引人？ -v4.wav;
changeFigure:none -right -next;
setAnimation:l2c -target=fig-left -next;
WebGAL 引擎也具有动画系统和特效系统，使用 WebGAL 开发的游戏可以拥有很好的表现效果。 -v5.wav;
`;

    const preprocessedScene = sceneTextPreProcess(testScene);
    expect(preprocessedScene).toEqual(testScene);
});

test("parser-multiline-full", async () => {
    const testScene = `changeFigure:a.png -left
  -next
  -id=id1

intro:aaa
  |bbb|ccc
  |ddd
  -next;

; WebGAL 引擎会默认读取 start.txt 作为初始场景，因此请不要删除，并在初始场景内跳转到其他场景
bgm:s_Title.mp3;
unlockBgm:s_Title.mp3 -name=雲を追いかけて;
intro:你好
|欢迎来到 WebGAL 的世界;
changeBg:bg.webp -next;
unlockCg:bg.webp -name=良夜; // 解锁CG并赋予名称
changeFigure:stand.webp -left -next;
setAnimation:enter-from-left
  -target=fig-left -next;
WebGAL:欢迎使用 WebGAL！这是一款全新的网页端视觉小说引擎。
  -v1.wav;
changeFigure:stand2.webp
  -right -next;
WebGAL 是使用 Web 技术开发的引擎，因此在网页端有良好的表现。 -v2.wav;
由于这个特性，如果你将 WebGAL 部署到服务器或网页托管平台上，玩家只需要一串链接就可以开始游玩！ -v3.wav;
setAnimation:move-front-and-back
  -target=fig-left
  -next;

听起来是不是非常吸引人？ -v4.wav;
changeFigure:none -right -next;
setAnimation:l2c -target=fig-left -next;
WebGAL 引擎也具有动画系统和特效系统，使用 WebGAL 开发的游戏可以拥有很好的表现效果。
  -v5.wav;
`;

    const expected = `changeFigure:a.png -left -next -id=id1
;_WEBGAL_LINE_BREAK_  -next
;_WEBGAL_LINE_BREAK_  -id=id1

intro:aaa|bbb|ccc|ddd -next;
;_WEBGAL_LINE_BREAK_  |bbb|ccc
;_WEBGAL_LINE_BREAK_  |ddd
;_WEBGAL_LINE_BREAK_  -next;

; WebGAL 引擎会默认读取 start.txt 作为初始场景，因此请不要删除，并在初始场景内跳转到其他场景
bgm:s_Title.mp3;
unlockBgm:s_Title.mp3 -name=雲を追いかけて;
intro:你好
|欢迎来到 WebGAL 的世界;
changeBg:bg.webp -next;
unlockCg:bg.webp -name=良夜; // 解锁CG并赋予名称
changeFigure:stand.webp -left -next;
setAnimation:enter-from-left -target=fig-left -next;
;_WEBGAL_LINE_BREAK_  -target=fig-left -next;
WebGAL:欢迎使用 WebGAL！这是一款全新的网页端视觉小说引擎。 -v1.wav;
;_WEBGAL_LINE_BREAK_  -v1.wav;
changeFigure:stand2.webp -right -next;
;_WEBGAL_LINE_BREAK_  -right -next;
WebGAL 是使用 Web 技术开发的引擎，因此在网页端有良好的表现。 -v2.wav;
由于这个特性，如果你将 WebGAL 部署到服务器或网页托管平台上，玩家只需要一串链接就可以开始游玩！ -v3.wav;
setAnimation:move-front-and-back -target=fig-left -next;
;_WEBGAL_LINE_BREAK_  -target=fig-left
;_WEBGAL_LINE_BREAK_  -next;

听起来是不是非常吸引人？ -v4.wav;
changeFigure:none -right -next;
setAnimation:l2c -target=fig-left -next;
WebGAL 引擎也具有动画系统和特效系统，使用 WebGAL 开发的游戏可以拥有很好的表现效果。 -v5.wav;
;_WEBGAL_LINE_BREAK_  -v5.wav;
`;

    const preprocessedScene = sceneTextPreProcess(testScene);
    expect(preprocessedScene).toEqual(expected);
});



================================================
FILE: parser/test/test-resources/choose.txt
================================================
choose:;
choose:|;
choose:fff:;
choose::ff;
choose:|:ff;



================================================
FILE: parser/test/test-resources/debug.scss
================================================
.Title_main {
  width: 100%;
  height: 100%;
  position: absolute;
  z-index: 13;
}

.Title_buttonList {
  font-family: "思源宋体", serif;
  display: flex;
  position: absolute;
  left: 0;
  min-width: 25%;
  height: 100%;
  justify-content: center;
  align-items: flex-start;
  flex-flow: column;
  transition: background 0.75s;
  padding-left: 120px;
}

.Title_button {
  font-weight: bold;
  text-align: center;
  flex: 0 1 auto;
  cursor: pointer;
  padding: 1em 2em 1em 2em;
  margin: 20px 0;
  transition: all 0.33s;
  background: rgba(255, 255, 255, 0.15);
  backdrop-filter: blur(5px);
  border-radius: 4px;
  transform: skewX(-10deg);
  background: linear-gradient(to right, rgba(0, 0, 0, 0.3), rgba(0, 0, 0, 0.1));

  &:hover {
    font-weight: bold;
    text-shadow: 0 0 10px rgba(255, 255, 255, 1);
    padding: 1em 6em 1em 3em;
  }
  &:active {
    font-weight: bold;
  }
}

.Title_button_text {
  color: transparent;
  background: linear-gradient(135deg, #fdfbfb 0%, #dcddde 100%);
  -webkit-background-clip: text;
  padding: 0 0.5em 0 0.5em;
  font-size: 200%;
  font-family: WebgalUI, -apple-system, BlinkMacSystemFont, Segoe UI, Roboto, Oxygen, Ubuntu, Cantarell, Fira Sans, Droid Sans, Helvetica Neue, sans-serif;
  letter-spacing: 0.15em;
}

.Title_backup_background {
  width: 100%;
  height: 100%;
  position: absolute;
  z-index: 13;
  background: linear-gradient(135deg, #fdfbfb 0%, #dcddde 100%);
}





================================================
FILE: parser/test/test-resources/line-break.txt
================================================
changeFigure:a.png -left
  -next


  -id=id1

intro:aaa
  |bbb|ccc
  |ddd
  -next;

; WebGAL 引擎会默认读取 start.txt 作为初始场景，因此请不要删除，并在初始场景内跳转到其他场景
bgm:s_Title.mp3;
unlockBgm:s_Title.mp3 -name=雲を追いかけて;
intro:你好
|欢迎来到 WebGAL 的世界;
changeBg:bg.webp -next;
unlockCg:bg.webp -name=良夜; // 解锁CG并赋予名称
changeFigure:stand.webp -left -next;
setAnimation:enter-from-left
  -target=fig-left -next;
WebGAL:欢迎使用 WebGAL！这是一款全新的网页端视觉小说引擎。
  -v1.wav;
changeFigure:stand2.webp
  -right -next;
WebGAL 是使用 Web 技术开发的引擎，因此在网页端有良好的表现。 -v2.wav;
由于这个特性，如果你将 WebGAL 部署到服务器或网页托管平台上，玩家只需要一串链接就可以开始游玩！ -v3.wav;
setAnimation:move-front-and-back
  -target=fig-left


  -next;

听起来是不是非常吸引人？ -v4.wav;
changeFigure:none -right -next;
setAnimation:l2c -target=fig-left -next;
WebGAL 引擎也具有动画系统和特效系统，使用 WebGAL 开发的游戏可以拥有很好的表现效果。
  -v5.wav;



================================================
FILE: parser/test/test-resources/long-script.txt
================================================
; WebGAL 引擎会默认读取 start.txt 作为初始场景，因此请不要删除，并在初始场景内跳转到其他场景
bgm:s_Title.mp3;
unlockBgm:s_Title.mp3 -name=雲を追いかけて;
intro:你好|欢迎来到 WebGAL 的世界;
changeBg:bg.webp -next;
unlockCg:bg.webp -name=良夜; // 解锁CG并赋予名称
changeFigure:stand.webp -left -next;
setAnimation:enter-from-left -target=fig-left -next;
WebGAL:欢迎使用 WebGAL！这是一款全新的网页端视觉小说引擎。 -v1.wav;
changeFigure:stand2.webp -right -next;
WebGAL 是使用 Web 技术开发的引擎，因此在网页端有良好的表现。 -v2.wav;
由于这个特性，如果你将 WebGAL 部署到服务器或网页托管平台上，玩家只需要一串链接就可以开始游玩！ -v3.wav;
setAnimation:move-front-and-back -target=fig-left -next;
听起来是不是非常吸引人？ -v4.wav;
changeFigure:none -right -next;
setAnimation:l2c -target=fig-left -next;
WebGAL 引擎也具有动画系统和特效系统，使用 WebGAL 开发的游戏可以拥有很好的表现效果。 -v5.wav;
pixiInit;
pixiPerform:snow;
比如，这个下起小雪的特效。 -v6.wav;
除此以外，分支选择的功能也必不可少。 -v7.wav;
你可以通过以下两个分支了解 WebGAL 的更多故事。 -v8.wav;
pixiInit;
choose:WebGAL 发展历程:choose1|WebGAL 冷知识:choose2;

;分支1
label:choose1;
WebGAL 的开发初衷是能够让更多人可以更方便地制作属于自己的视觉小说。 -v9.wav;
在一开始，WebGAL 只具备很少的功能，仅仅能支持立绘和背景的显示、语音播放和分支选择。 -v10.wav;
在经历一年的发展后，现在已经是支持了很多优秀的表现效果的引擎了！ -v11.wav;
除此以外，WebGAL 编辑器的加入也使得制作和导出一个游戏更加方便快捷。 -v12.wav;
jumpLabel:end;

;分支2
label:choose2;
这个演示游戏使用的素材是 AI 生成的。 -v13.wav;
WebGAL 项目只用了一年不到就在 GitHub 获得了 1000 星标！ -v14.wav;
WebGAL 的开发历程，是一个在开发中学习开发的过程。因此她经历了3次重构，并且每次几乎都是推倒重来式的。 -v15.wav;
WebGAL 的脚本语言是为了简化制作难度而全新设计的！ -v16.wav;

;结束分支
label:end;
为了更接近桌面端视觉小说引擎的能力，我们支持很多快捷键以及可跳转的剧情回溯。 -v17.wav;
按下菜单中的“回想”按钮或者向上滚动鼠标滚轮试试吧！ -v18.wav;
快速存读挡、丰富的选项、自动播放以及快进等功能，也是应有尽有。 -v19.wav;
setTempAnimation:[{"position": {"x": 500,"y": 0},"duration": 0},{"position": {"x": 400,"y": 0},"duration": 250},{"position": {"x": 600,"y": 0},"duration": 500},{"position": {"x": 500,"y": 0},"duration": 250}] -target=fig-left -next;
当然，这不算什么，因为大多数成熟的引擎都有这些功能。但是在 Web 端，这却是很少见的。 -v20.wav;
我们为可能初次开发游戏的开发者提供了美观的通用 UI 和丰富的预设功能与动画。所以你可以没有顾虑地快速开始制作游戏。 -v21.wav;
WebGAL 项目组期待你的作品能够在 WebGAL 上呈现！只需要一个链接就可以让万千用户立刻开始享受你的作品。 -v22.wav;
感谢你关注 WebGAL 项目！ -v23.wav;
end;
; WebGAL 引擎会默认读取 start.txt 作为初始场景，因此请不要删除，并在初始场景内跳转到其他场景
bgm:s_Title.mp3;
unlockBgm:s_Title.mp3 -name=雲を追いかけて;
intro:你好|欢迎来到 WebGAL 的世界;
changeBg:bg.webp -next;
unlockCg:bg.webp -name=良夜; // 解锁CG并赋予名称
changeFigure:stand.webp -left -next;
setAnimation:enter-from-left -target=fig-left -next;
WebGAL:欢迎使用 WebGAL！这是一款全新的网页端视觉小说引擎。 -v1.wav;
changeFigure:stand2.webp -right -next;
WebGAL 是使用 Web 技术开发的引擎，因此在网页端有良好的表现。 -v2.wav;
由于这个特性，如果你将 WebGAL 部署到服务器或网页托管平台上，玩家只需要一串链接就可以开始游玩！ -v3.wav;
setAnimation:move-front-and-back -target=fig-left -next;
听起来是不是非常吸引人？ -v4.wav;
changeFigure:none -right -next;
setAnimation:l2c -target=fig-left -next;
WebGAL 引擎也具有动画系统和特效系统，使用 WebGAL 开发的游戏可以拥有很好的表现效果。 -v5.wav;
pixiInit;
pixiPerform:snow;
比如，这个下起小雪的特效。 -v6.wav;
除此以外，分支选择的功能也必不可少。 -v7.wav;
你可以通过以下两个分支了解 WebGAL 的更多故事。 -v8.wav;
pixiInit;
choose:WebGAL 发展历程:choose1|WebGAL 冷知识:choose2;

;分支1
label:choose1;
WebGAL 的开发初衷是能够让更多人可以更方便地制作属于自己的视觉小说。 -v9.wav;
在一开始，WebGAL 只具备很少的功能，仅仅能支持立绘和背景的显示、语音播放和分支选择。 -v10.wav;
在经历一年的发展后，现在已经是支持了很多优秀的表现效果的引擎了！ -v11.wav;
除此以外，WebGAL 编辑器的加入也使得制作和导出一个游戏更加方便快捷。 -v12.wav;
jumpLabel:end;

;分支2
label:choose2;
这个演示游戏使用的素材是 AI 生成的。 -v13.wav;
WebGAL 项目只用了一年不到就在 GitHub 获得了 1000 星标！ -v14.wav;
WebGAL 的开发历程，是一个在开发中学习开发的过程。因此她经历了3次重构，并且每次几乎都是推倒重来式的。 -v15.wav;
WebGAL 的脚本语言是为了简化制作难度而全新设计的！ -v16.wav;

;结束分支
label:end;
为了更接近桌面端视觉小说引擎的能力，我们支持很多快捷键以及可跳转的剧情回溯。 -v17.wav;
按下菜单中的“回想”按钮或者向上滚动鼠标滚轮试试吧！ -v18.wav;
快速存读挡、丰富的选项、自动播放以及快进等功能，也是应有尽有。 -v19.wav;
setTempAnimation:[{"position": {"x": 500,"y": 0},"duration": 0},{"position": {"x": 400,"y": 0},"duration": 250},{"position": {"x": 600,"y": 0},"duration": 500},{"position": {"x": 500,"y": 0},"duration": 250}] -target=fig-left -next;
当然，这不算什么，因为大多数成熟的引擎都有这些功能。但是在 Web 端，这却是很少见的。 -v20.wav;
我们为可能初次开发游戏的开发者提供了美观的通用 UI 和丰富的预设功能与动画。所以你可以没有顾虑地快速开始制作游戏。 -v21.wav;
WebGAL 项目组期待你的作品能够在 WebGAL 上呈现！只需要一个链接就可以让万千用户立刻开始享受你的作品。 -v22.wav;
感谢你关注 WebGAL 项目！ -v23.wav;
end;
; WebGAL 引擎会默认读取 start.txt 作为初始场景，因此请不要删除，并在初始场景内跳转到其他场景
bgm:s_Title.mp3;
unlockBgm:s_Title.mp3 -name=雲を追いかけて;
intro:你好|欢迎来到 WebGAL 的世界;
changeBg:bg.webp -next;
unlockCg:bg.webp -name=良夜; // 解锁CG并赋予名称
changeFigure:stand.webp -left -next;
setAnimation:enter-from-left -target=fig-left -next;
WebGAL:欢迎使用 WebGAL！这是一款全新的网页端视觉小说引擎。 -v1.wav;
changeFigure:stand2.webp -right -next;
WebGAL 是使用 Web 技术开发的引擎，因此在网页端有良好的表现。 -v2.wav;
由于这个特性，如果你将 WebGAL 部署到服务器或网页托管平台上，玩家只需要一串链接就可以开始游玩！ -v3.wav;
setAnimation:move-front-and-back -target=fig-left -next;
听起来是不是非常吸引人？ -v4.wav;
changeFigure:none -right -next;
setAnimation:l2c -target=fig-left -next;
WebGAL 引擎也具有动画系统和特效系统，使用 WebGAL 开发的游戏可以拥有很好的表现效果。 -v5.wav;
pixiInit;
pixiPerform:snow;
比如，这个下起小雪的特效。 -v6.wav;
除此以外，分支选择的功能也必不可少。 -v7.wav;
你可以通过以下两个分支了解 WebGAL 的更多故事。 -v8.wav;
pixiInit;
choose:WebGAL 发展历程:choose1|WebGAL 冷知识:choose2;

;分支1
label:choose1;
WebGAL 的开发初衷是能够让更多人可以更方便地制作属于自己的视觉小说。 -v9.wav;
在一开始，WebGAL 只具备很少的功能，仅仅能支持立绘和背景的显示、语音播放和分支选择。 -v10.wav;
在经历一年的发展后，现在已经是支持了很多优秀的表现效果的引擎了！ -v11.wav;
除此以外，WebGAL 编辑器的加入也使得制作和导出一个游戏更加方便快捷。 -v12.wav;
jumpLabel:end;

;分支2
label:choose2;
这个演示游戏使用的素材是 AI 生成的。 -v13.wav;
WebGAL 项目只用了一年不到就在 GitHub 获得了 1000 星标！ -v14.wav;
WebGAL 的开发历程，是一个在开发中学习开发的过程。因此她经历了3次重构，并且每次几乎都是推倒重来式的。 -v15.wav;
WebGAL 的脚本语言是为了简化制作难度而全新设计的！ -v16.wav;

;结束分支
label:end;
为了更接近桌面端视觉小说引擎的能力，我们支持很多快捷键以及可跳转的剧情回溯。 -v17.wav;
按下菜单中的“回想”按钮或者向上滚动鼠标滚轮试试吧！ -v18.wav;
快速存读挡、丰富的选项、自动播放以及快进等功能，也是应有尽有。 -v19.wav;
setTempAnimation:[{"position": {"x": 500,"y": 0},"duration": 0},{"position": {"x": 400,"y": 0},"duration": 250},{"position": {"x": 600,"y": 0},"duration": 500},{"position": {"x": 500,"y": 0},"duration": 250}] -target=fig-left -next;
当然，这不算什么，因为大多数成熟的引擎都有这些功能。但是在 Web 端，这却是很少见的。 -v20.wav;
我们为可能初次开发游戏的开发者提供了美观的通用 UI 和丰富的预设功能与动画。所以你可以没有顾虑地快速开始制作游戏。 -v21.wav;
WebGAL 项目组期待你的作品能够在 WebGAL 上呈现！只需要一个链接就可以让万千用户立刻开始享受你的作品。 -v22.wav;
感谢你关注 WebGAL 项目！ -v23.wav;
end;
; WebGAL 引擎会默认读取 start.txt 作为初始场景，因此请不要删除，并在初始场景内跳转到其他场景
bgm:s_Title.mp3;
unlockBgm:s_Title.mp3 -name=雲を追いかけて;
intro:你好|欢迎来到 WebGAL 的世界;
changeBg:bg.webp -next;
unlockCg:bg.webp -name=良夜; // 解锁CG并赋予名称
changeFigure:stand.webp -left -next;
setAnimation:enter-from-left -target=fig-left -next;
WebGAL:欢迎使用 WebGAL！这是一款全新的网页端视觉小说引擎。 -v1.wav;
changeFigure:stand2.webp -right -next;
WebGAL 是使用 Web 技术开发的引擎，因此在网页端有良好的表现。 -v2.wav;
由于这个特性，如果你将 WebGAL 部署到服务器或网页托管平台上，玩家只需要一串链接就可以开始游玩！ -v3.wav;
setAnimation:move-front-and-back -target=fig-left -next;
听起来是不是非常吸引人？ -v4.wav;
changeFigure:none -right -next;
setAnimation:l2c -target=fig-left -next;
WebGAL 引擎也具有动画系统和特效系统，使用 WebGAL 开发的游戏可以拥有很好的表现效果。 -v5.wav;
pixiInit;
pixiPerform:snow;
比如，这个下起小雪的特效。 -v6.wav;
除此以外，分支选择的功能也必不可少。 -v7.wav;
你可以通过以下两个分支了解 WebGAL 的更多故事。 -v8.wav;
pixiInit;
choose:WebGAL 发展历程:choose1|WebGAL 冷知识:choose2;

;分支1
label:choose1;
WebGAL 的开发初衷是能够让更多人可以更方便地制作属于自己的视觉小说。 -v9.wav;
在一开始，WebGAL 只具备很少的功能，仅仅能支持立绘和背景的显示、语音播放和分支选择。 -v10.wav;
在经历一年的发展后，现在已经是支持了很多优秀的表现效果的引擎了！ -v11.wav;
除此以外，WebGAL 编辑器的加入也使得制作和导出一个游戏更加方便快捷。 -v12.wav;
jumpLabel:end;

;分支2
label:choose2;
这个演示游戏使用的素材是 AI 生成的。 -v13.wav;
WebGAL 项目只用了一年不到就在 GitHub 获得了 1000 星标！ -v14.wav;
WebGAL 的开发历程，是一个在开发中学习开发的过程。因此她经历了3次重构，并且每次几乎都是推倒重来式的。 -v15.wav;
WebGAL 的脚本语言是为了简化制作难度而全新设计的！ -v16.wav;

;结束分支
label:end;
为了更接近桌面端视觉小说引擎的能力，我们支持很多快捷键以及可跳转的剧情回溯。 -v17.wav;
按下菜单中的“回想”按钮或者向上滚动鼠标滚轮试试吧！ -v18.wav;
快速存读挡、丰富的选项、自动播放以及快进等功能，也是应有尽有。 -v19.wav;
setTempAnimation:[{"position": {"x": 500,"y": 0},"duration": 0},{"position": {"x": 400,"y": 0},"duration": 250},{"position": {"x": 600,"y": 0},"duration": 500},{"position": {"x": 500,"y": 0},"duration": 250}] -target=fig-left -next;
当然，这不算什么，因为大多数成熟的引擎都有这些功能。但是在 Web 端，这却是很少见的。 -v20.wav;
我们为可能初次开发游戏的开发者提供了美观的通用 UI 和丰富的预设功能与动画。所以你可以没有顾虑地快速开始制作游戏。 -v21.wav;
WebGAL 项目组期待你的作品能够在 WebGAL 上呈现！只需要一个链接就可以让万千用户立刻开始享受你的作品。 -v22.wav;
感谢你关注 WebGAL 项目！ -v23.wav;
end;
; WebGAL 引擎会默认读取 start.txt 作为初始场景，因此请不要删除，并在初始场景内跳转到其他场景
bgm:s_Title.mp3;
unlockBgm:s_Title.mp3 -name=雲を追いかけて;
intro:你好|欢迎来到 WebGAL 的世界;
changeBg:bg.webp -next;
unlockCg:bg.webp -name=良夜; // 解锁CG并赋予名称
changeFigure:stand.webp -left -next;
setAnimation:enter-from-left -target=fig-left -next;
WebGAL:欢迎使用 WebGAL！这是一款全新的网页端视觉小说引擎。 -v1.wav;
changeFigure:stand2.webp -right -next;
WebGAL 是使用 Web 技术开发的引擎，因此在网页端有良好的表现。 -v2.wav;
由于这个特性，如果你将 WebGAL 部署到服务器或网页托管平台上，玩家只需要一串链接就可以开始游玩！ -v3.wav;
setAnimation:move-front-and-back -target=fig-left -next;
听起来是不是非常吸引人？ -v4.wav;
changeFigure:none -right -next;
setAnimation:l2c -target=fig-left -next;
WebGAL 引擎也具有动画系统和特效系统，使用 WebGAL 开发的游戏可以拥有很好的表现效果。 -v5.wav;
pixiInit;
pixiPerform:snow;
比如，这个下起小雪的特效。 -v6.wav;
除此以外，分支选择的功能也必不可少。 -v7.wav;
你可以通过以下两个分支了解 WebGAL 的更多故事。 -v8.wav;
pixiInit;
choose:WebGAL 发展历程:choose1|WebGAL 冷知识:choose2;

;分支1
label:choose1;
WebGAL 的开发初衷是能够让更多人可以更方便地制作属于自己的视觉小说。 -v9.wav;
在一开始，WebGAL 只具备很少的功能，仅仅能支持立绘和背景的显示、语音播放和分支选择。 -v10.wav;
在经历一年的发展后，现在已经是支持了很多优秀的表现效果的引擎了！ -v11.wav;
除此以外，WebGAL 编辑器的加入也使得制作和导出一个游戏更加方便快捷。 -v12.wav;
jumpLabel:end;

;分支2
label:choose2;
这个演示游戏使用的素材是 AI 生成的。 -v13.wav;
WebGAL 项目只用了一年不到就在 GitHub 获得了 1000 星标！ -v14.wav;
WebGAL 的开发历程，是一个在开发中学习开发的过程。因此她经历了3次重构，并且每次几乎都是推倒重来式的。 -v15.wav;
WebGAL 的脚本语言是为了简化制作难度而全新设计的！ -v16.wav;

;结束分支
label:end;
为了更接近桌面端视觉小说引擎的能力，我们支持很多快捷键以及可跳转的剧情回溯。 -v17.wav;
按下菜单中的“回想”按钮或者向上滚动鼠标滚轮试试吧！ -v18.wav;
快速存读挡、丰富的选项、自动播放以及快进等功能，也是应有尽有。 -v19.wav;
setTempAnimation:[{"position": {"x": 500,"y": 0},"duration": 0},{"position": {"x": 400,"y": 0},"duration": 250},{"position": {"x": 600,"y": 0},"duration": 500},{"position": {"x": 500,"y": 0},"duration": 250}] -target=fig-left -next;
当然，这不算什么，因为大多数成熟的引擎都有这些功能。但是在 Web 端，这却是很少见的。 -v20.wav;
我们为可能初次开发游戏的开发者提供了美观的通用 UI 和丰富的预设功能与动画。所以你可以没有顾虑地快速开始制作游戏。 -v21.wav;
WebGAL 项目组期待你的作品能够在 WebGAL 上呈现！只需要一个链接就可以让万千用户立刻开始享受你的作品。 -v22.wav;
感谢你关注 WebGAL 项目！ -v23.wav;
end;
; WebGAL 引擎会默认读取 start.txt 作为初始场景，因此请不要删除，并在初始场景内跳转到其他场景
bgm:s_Title.mp3;
unlockBgm:s_Title.mp3 -name=雲を追いかけて;
intro:你好|欢迎来到 WebGAL 的世界;
changeBg:bg.webp -next;
unlockCg:bg.webp -name=良夜; // 解锁CG并赋予名称
changeFigure:stand.webp -left -next;
setAnimation:enter-from-left -target=fig-left -next;
WebGAL:欢迎使用 WebGAL！这是一款全新的网页端视觉小说引擎。 -v1.wav;
changeFigure:stand2.webp -right -next;
WebGAL 是使用 Web 技术开发的引擎，因此在网页端有良好的表现。 -v2.wav;
由于这个特性，如果你将 WebGAL 部署到服务器或网页托管平台上，玩家只需要一串链接就可以开始游玩！ -v3.wav;
setAnimation:move-front-and-back -target=fig-left -next;
听起来是不是非常吸引人？ -v4.wav;
changeFigure:none -right -next;
setAnimation:l2c -target=fig-left -next;
WebGAL 引擎也具有动画系统和特效系统，使用 WebGAL 开发的游戏可以拥有很好的表现效果。 -v5.wav;
pixiInit;
pixiPerform:snow;
比如，这个下起小雪的特效。 -v6.wav;
除此以外，分支选择的功能也必不可少。 -v7.wav;
你可以通过以下两个分支了解 WebGAL 的更多故事。 -v8.wav;
pixiInit;
choose:WebGAL 发展历程:choose1|WebGAL 冷知识:choose2;

;分支1
label:choose1;
WebGAL 的开发初衷是能够让更多人可以更方便地制作属于自己的视觉小说。 -v9.wav;
在一开始，WebGAL 只具备很少的功能，仅仅能支持立绘和背景的显示、语音播放和分支选择。 -v10.wav;
在经历一年的发展后，现在已经是支持了很多优秀的表现效果的引擎了！ -v11.wav;
除此以外，WebGAL 编辑器的加入也使得制作和导出一个游戏更加方便快捷。 -v12.wav;
jumpLabel:end;

;分支2
label:choose2;
这个演示游戏使用的素材是 AI 生成的。 -v13.wav;
WebGAL 项目只用了一年不到就在 GitHub 获得了 1000 星标！ -v14.wav;
WebGAL 的开发历程，是一个在开发中学习开发的过程。因此她经历了3次重构，并且每次几乎都是推倒重来式的。 -v15.wav;
WebGAL 的脚本语言是为了简化制作难度而全新设计的！ -v16.wav;

;结束分支
label:end;
为了更接近桌面端视觉小说引擎的能力，我们支持很多快捷键以及可跳转的剧情回溯。 -v17.wav;
按下菜单中的“回想”按钮或者向上滚动鼠标滚轮试试吧！ -v18.wav;
快速存读挡、丰富的选项、自动播放以及快进等功能，也是应有尽有。 -v19.wav;
setTempAnimation:[{"position": {"x": 500,"y": 0},"duration": 0},{"position": {"x": 400,"y": 0},"duration": 250},{"position": {"x": 600,"y": 0},"duration": 500},{"position": {"x": 500,"y": 0},"duration": 250}] -target=fig-left -next;
当然，这不算什么，因为大多数成熟的引擎都有这些功能。但是在 Web 端，这却是很少见的。 -v20.wav;
我们为可能初次开发游戏的开发者提供了美观的通用 UI 和丰富的预设功能与动画。所以你可以没有顾虑地快速开始制作游戏。 -v21.wav;
WebGAL 项目组期待你的作品能够在 WebGAL 上呈现！只需要一个链接就可以让万千用户立刻开始享受你的作品。 -v22.wav;
感谢你关注 WebGAL 项目！ -v23.wav;
end;
; WebGAL 引擎会默认读取 start.txt 作为初始场景，因此请不要删除，并在初始场景内跳转到其他场景
bgm:s_Title.mp3;
unlockBgm:s_Title.mp3 -name=雲を追いかけて;
intro:你好|欢迎来到 WebGAL 的世界;
changeBg:bg.webp -next;
unlockCg:bg.webp -name=良夜; // 解锁CG并赋予名称
changeFigure:stand.webp -left -next;
setAnimation:enter-from-left -target=fig-left -next;
WebGAL:欢迎使用 WebGAL！这是一款全新的网页端视觉小说引擎。 -v1.wav;
changeFigure:stand2.webp -right -next;
WebGAL 是使用 Web 技术开发的引擎，因此在网页端有良好的表现。 -v2.wav;
由于这个特性，如果你将 WebGAL 部署到服务器或网页托管平台上，玩家只需要一串链接就可以开始游玩！ -v3.wav;
setAnimation:move-front-and-back -target=fig-left -next;
听起来是不是非常吸引人？ -v4.wav;
changeFigure:none -right -next;
setAnimation:l2c -target=fig-left -next;
WebGAL 引擎也具有动画系统和特效系统，使用 WebGAL 开发的游戏可以拥有很好的表现效果。 -v5.wav;
pixiInit;
pixiPerform:snow;
比如，这个下起小雪的特效。 -v6.wav;
除此以外，分支选择的功能也必不可少。 -v7.wav;
你可以通过以下两个分支了解 WebGAL 的更多故事。 -v8.wav;
pixiInit;
choose:WebGAL 发展历程:choose1|WebGAL 冷知识:choose2;

;分支1
label:choose1;
WebGAL 的开发初衷是能够让更多人可以更方便地制作属于自己的视觉小说。 -v9.wav;
在一开始，WebGAL 只具备很少的功能，仅仅能支持立绘和背景的显示、语音播放和分支选择。 -v10.wav;
在经历一年的发展后，现在已经是支持了很多优秀的表现效果的引擎了！ -v11.wav;
除此以外，WebGAL 编辑器的加入也使得制作和导出一个游戏更加方便快捷。 -v12.wav;
jumpLabel:end;

;分支2
label:choose2;
这个演示游戏使用的素材是 AI 生成的。 -v13.wav;
WebGAL 项目只用了一年不到就在 GitHub 获得了 1000 星标！ -v14.wav;
WebGAL 的开发历程，是一个在开发中学习开发的过程。因此她经历了3次重构，并且每次几乎都是推倒重来式的。 -v15.wav;
WebGAL 的脚本语言是为了简化制作难度而全新设计的！ -v16.wav;

;结束分支
label:end;
为了更接近桌面端视觉小说引擎的能力，我们支持很多快捷键以及可跳转的剧情回溯。 -v17.wav;
按下菜单中的“回想”按钮或者向上滚动鼠标滚轮试试吧！ -v18.wav;
快速存读挡、丰富的选项、自动播放以及快进等功能，也是应有尽有。 -v19.wav;
setTempAnimation:[{"position": {"x": 500,"y": 0},"duration": 0},{"position": {"x": 400,"y": 0},"duration": 250},{"position": {"x": 600,"y": 0},"duration": 500},{"position": {"x": 500,"y": 0},"duration": 250}] -target=fig-left -next;
当然，这不算什么，因为大多数成熟的引擎都有这些功能。但是在 Web 端，这却是很少见的。 -v20.wav;
我们为可能初次开发游戏的开发者提供了美观的通用 UI 和丰富的预设功能与动画。所以你可以没有顾虑地快速开始制作游戏。 -v21.wav;
WebGAL 项目组期待你的作品能够在 WebGAL 上呈现！只需要一个链接就可以让万千用户立刻开始享受你的作品。 -v22.wav;
感谢你关注 WebGAL 项目！ -v23.wav;
end;
; WebGAL 引擎会默认读取 start.txt 作为初始场景，因此请不要删除，并在初始场景内跳转到其他场景
bgm:s_Title.mp3;
unlockBgm:s_Title.mp3 -name=雲を追いかけて;
intro:你好|欢迎来到 WebGAL 的世界;
changeBg:bg.webp -next;
unlockCg:bg.webp -name=良夜; // 解锁CG并赋予名称
changeFigure:stand.webp -left -next;
setAnimation:enter-from-left -target=fig-left -next;
WebGAL:欢迎使用 WebGAL！这是一款全新的网页端视觉小说引擎。 -v1.wav;
changeFigure:stand2.webp -right -next;
WebGAL 是使用 Web 技术开发的引擎，因此在网页端有良好的表现。 -v2.wav;
由于这个特性，如果你将 WebGAL 部署到服务器或网页托管平台上，玩家只需要一串链接就可以开始游玩！ -v3.wav;
setAnimation:move-front-and-back -target=fig-left -next;
听起来是不是非常吸引人？ -v4.wav;
changeFigure:none -right -next;
setAnimation:l2c -target=fig-left -next;
WebGAL 引擎也具有动画系统和特效系统，使用 WebGAL 开发的游戏可以拥有很好的表现效果。 -v5.wav;
pixiInit;
pixiPerform:snow;
比如，这个下起小雪的特效。 -v6.wav;
除此以外，分支选择的功能也必不可少。 -v7.wav;
你可以通过以下两个分支了解 WebGAL 的更多故事。 -v8.wav;
pixiInit;
choose:WebGAL 发展历程:choose1|WebGAL 冷知识:choose2;

;分支1
label:choose1;
WebGAL 的开发初衷是能够让更多人可以更方便地制作属于自己的视觉小说。 -v9.wav;
在一开始，WebGAL 只具备很少的功能，仅仅能支持立绘和背景的显示、语音播放和分支选择。 -v10.wav;
在经历一年的发展后，现在已经是支持了很多优秀的表现效果的引擎了！ -v11.wav;
除此以外，WebGAL 编辑器的加入也使得制作和导出一个游戏更加方便快捷。 -v12.wav;
jumpLabel:end;

;分支2
label:choose2;
这个演示游戏使用的素材是 AI 生成的。 -v13.wav;
WebGAL 项目只用了一年不到就在 GitHub 获得了 1000 星标！ -v14.wav;
WebGAL 的开发历程，是一个在开发中学习开发的过程。因此她经历了3次重构，并且每次几乎都是推倒重来式的。 -v15.wav;
WebGAL 的脚本语言是为了简化制作难度而全新设计的！ -v16.wav;

;结束分支
label:end;
为了更接近桌面端视觉小说引擎的能力，我们支持很多快捷键以及可跳转的剧情回溯。 -v17.wav;
按下菜单中的“回想”按钮或者向上滚动鼠标滚轮试试吧！ -v18.wav;
快速存读挡、丰富的选项、自动播放以及快进等功能，也是应有尽有。 -v19.wav;
setTempAnimation:[{"position": {"x": 500,"y": 0},"duration": 0},{"position": {"x": 400,"y": 0},"duration": 250},{"position": {"x": 600,"y": 0},"duration": 500},{"position": {"x": 500,"y": 0},"duration": 250}] -target=fig-left -next;
当然，这不算什么，因为大多数成熟的引擎都有这些功能。但是在 Web 端，这却是很少见的。 -v20.wav;
我们为可能初次开发游戏的开发者提供了美观的通用 UI 和丰富的预设功能与动画。所以你可以没有顾虑地快速开始制作游戏。 -v21.wav;
WebGAL 项目组期待你的作品能够在 WebGAL 上呈现！只需要一个链接就可以让万千用户立刻开始享受你的作品。 -v22.wav;
感谢你关注 WebGAL 项目！ -v23.wav;
end;
; WebGAL 引擎会默认读取 start.txt 作为初始场景，因此请不要删除，并在初始场景内跳转到其他场景
bgm:s_Title.mp3;
unlockBgm:s_Title.mp3 -name=雲を追いかけて;
intro:你好|欢迎来到 WebGAL 的世界;
changeBg:bg.webp -next;
unlockCg:bg.webp -name=良夜; // 解锁CG并赋予名称
changeFigure:stand.webp -left -next;
setAnimation:enter-from-left -target=fig-left -next;
WebGAL:欢迎使用 WebGAL！这是一款全新的网页端视觉小说引擎。 -v1.wav;
changeFigure:stand2.webp -right -next;
WebGAL 是使用 Web 技术开发的引擎，因此在网页端有良好的表现。 -v2.wav;
由于这个特性，如果你将 WebGAL 部署到服务器或网页托管平台上，玩家只需要一串链接就可以开始游玩！ -v3.wav;
setAnimation:move-front-and-back -target=fig-left -next;
听起来是不是非常吸引人？ -v4.wav;
changeFigure:none -right -next;
setAnimation:l2c -target=fig-left -next;
WebGAL 引擎也具有动画系统和特效系统，使用 WebGAL 开发的游戏可以拥有很好的表现效果。 -v5.wav;
pixiInit;
pixiPerform:snow;
比如，这个下起小雪的特效。 -v6.wav;
除此以外，分支选择的功能也必不可少。 -v7.wav;
你可以通过以下两个分支了解 WebGAL 的更多故事。 -v8.wav;
pixiInit;
choose:WebGAL 发展历程:choose1|WebGAL 冷知识:choose2;

;分支1
label:choose1;
WebGAL 的开发初衷是能够让更多人可以更方便地制作属于自己的视觉小说。 -v9.wav;
在一开始，WebGAL 只具备很少的功能，仅仅能支持立绘和背景的显示、语音播放和分支选择。 -v10.wav;
在经历一年的发展后，现在已经是支持了很多优秀的表现效果的引擎了！ -v11.wav;
除此以外，WebGAL 编辑器的加入也使得制作和导出一个游戏更加方便快捷。 -v12.wav;
jumpLabel:end;

;分支2
label:choose2;
这个演示游戏使用的素材是 AI 生成的。 -v13.wav;
WebGAL 项目只用了一年不到就在 GitHub 获得了 1000 星标！ -v14.wav;
WebGAL 的开发历程，是一个在开发中学习开发的过程。因此她经历了3次重构，并且每次几乎都是推倒重来式的。 -v15.wav;
WebGAL 的脚本语言是为了简化制作难度而全新设计的！ -v16.wav;

;结束分支
label:end;
为了更接近桌面端视觉小说引擎的能力，我们支持很多快捷键以及可跳转的剧情回溯。 -v17.wav;
按下菜单中的“回想”按钮或者向上滚动鼠标滚轮试试吧！ -v18.wav;
快速存读挡、丰富的选项、自动播放以及快进等功能，也是应有尽有。 -v19.wav;
setTempAnimation:[{"position": {"x": 500,"y": 0},"duration": 0},{"position": {"x": 400,"y": 0},"duration": 250},{"position": {"x": 600,"y": 0},"duration": 500},{"position": {"x": 500,"y": 0},"duration": 250}] -target=fig-left -next;
当然，这不算什么，因为大多数成熟的引擎都有这些功能。但是在 Web 端，这却是很少见的。 -v20.wav;
我们为可能初次开发游戏的开发者提供了美观的通用 UI 和丰富的预设功能与动画。所以你可以没有顾虑地快速开始制作游戏。 -v21.wav;
WebGAL 项目组期待你的作品能够在 WebGAL 上呈现！只需要一个链接就可以让万千用户立刻开始享受你的作品。 -v22.wav;
感谢你关注 WebGAL 项目！ -v23.wav;
end;
; WebGAL 引擎会默认读取 start.txt 作为初始场景，因此请不要删除，并在初始场景内跳转到其他场景
bgm:s_Title.mp3;
unlockBgm:s_Title.mp3 -name=雲を追いかけて;
intro:你好|欢迎来到 WebGAL 的世界;
changeBg:bg.webp -next;
unlockCg:bg.webp -name=良夜; // 解锁CG并赋予名称
changeFigure:stand.webp -left -next;
setAnimation:enter-from-left -target=fig-left -next;
WebGAL:欢迎使用 WebGAL！这是一款全新的网页端视觉小说引擎。 -v1.wav;
changeFigure:stand2.webp -right -next;
WebGAL 是使用 Web 技术开发的引擎，因此在网页端有良好的表现。 -v2.wav;
由于这个特性，如果你将 WebGAL 部署到服务器或网页托管平台上，玩家只需要一串链接就可以开始游玩！ -v3.wav;
setAnimation:move-front-and-back -target=fig-left -next;
听起来是不是非常吸引人？ -v4.wav;
changeFigure:none -right -next;
setAnimation:l2c -target=fig-left -next;
WebGAL 引擎也具有动画系统和特效系统，使用 WebGAL 开发的游戏可以拥有很好的表现效果。 -v5.wav;
pixiInit;
pixiPerform:snow;
比如，这个下起小雪的特效。 -v6.wav;
除此以外，分支选择的功能也必不可少。 -v7.wav;
你可以通过以下两个分支了解 WebGAL 的更多故事。 -v8.wav;
pixiInit;
choose:WebGAL 发展历程:choose1|WebGAL 冷知识:choose2;

;分支1
label:choose1;
WebGAL 的开发初衷是能够让更多人可以更方便地制作属于自己的视觉小说。 -v9.wav;
在一开始，WebGAL 只具备很少的功能，仅仅能支持立绘和背景的显示、语音播放和分支选择。 -v10.wav;
在经历一年的发展后，现在已经是支持了很多优秀的表现效果的引擎了！ -v11.wav;
除此以外，WebGAL 编辑器的加入也使得制作和导出一个游戏更加方便快捷。 -v12.wav;
jumpLabel:end;

;分支2
label:choose2;
这个演示游戏使用的素材是 AI 生成的。 -v13.wav;
WebGAL 项目只用了一年不到就在 GitHub 获得了 1000 星标！ -v14.wav;
WebGAL 的开发历程，是一个在开发中学习开发的过程。因此她经历了3次重构，并且每次几乎都是推倒重来式的。 -v15.wav;
WebGAL 的脚本语言是为了简化制作难度而全新设计的！ -v16.wav;

;结束分支
label:end;
为了更接近桌面端视觉小说引擎的能力，我们支持很多快捷键以及可跳转的剧情回溯。 -v17.wav;
按下菜单中的“回想”按钮或者向上滚动鼠标滚轮试试吧！ -v18.wav;
快速存读挡、丰富的选项、自动播放以及快进等功能，也是应有尽有。 -v19.wav;
setTempAnimation:[{"position": {"x": 500,"y": 0},"duration": 0},{"position": {"x": 400,"y": 0},"duration": 250},{"position": {"x": 600,"y": 0},"duration": 500},{"position": {"x": 500,"y": 0},"duration": 250}] -target=fig-left -next;
当然，这不算什么，因为大多数成熟的引擎都有这些功能。但是在 Web 端，这却是很少见的。 -v20.wav;
我们为可能初次开发游戏的开发者提供了美观的通用 UI 和丰富的预设功能与动画。所以你可以没有顾虑地快速开始制作游戏。 -v21.wav;
WebGAL 项目组期待你的作品能够在 WebGAL 上呈现！只需要一个链接就可以让万千用户立刻开始享受你的作品。 -v22.wav;
感谢你关注 WebGAL 项目！ -v23.wav;
end;
; WebGAL 引擎会默认读取 start.txt 作为初始场景，因此请不要删除，并在初始场景内跳转到其他场景
bgm:s_Title.mp3;
unlockBgm:s_Title.mp3 -name=雲を追いかけて;
intro:你好|欢迎来到 WebGAL 的世界;
changeBg:bg.webp -next;
unlockCg:bg.webp -name=良夜; // 解锁CG并赋予名称
changeFigure:stand.webp -left -next;
setAnimation:enter-from-left -target=fig-left -next;
WebGAL:欢迎使用 WebGAL！这是一款全新的网页端视觉小说引擎。 -v1.wav;
changeFigure:stand2.webp -right -next;
WebGAL 是使用 Web 技术开发的引擎，因此在网页端有良好的表现。 -v2.wav;
由于这个特性，如果你将 WebGAL 部署到服务器或网页托管平台上，玩家只需要一串链接就可以开始游玩！ -v3.wav;
setAnimation:move-front-and-back -target=fig-left -next;
听起来是不是非常吸引人？ -v4.wav;
changeFigure:none -right -next;
setAnimation:l2c -target=fig-left -next;
WebGAL 引擎也具有动画系统和特效系统，使用 WebGAL 开发的游戏可以拥有很好的表现效果。 -v5.wav;
pixiInit;
pixiPerform:snow;
比如，这个下起小雪的特效。 -v6.wav;
除此以外，分支选择的功能也必不可少。 -v7.wav;
你可以通过以下两个分支了解 WebGAL 的更多故事。 -v8.wav;
pixiInit;
choose:WebGAL 发展历程:choose1|WebGAL 冷知识:choose2;

;分支1
label:choose1;
WebGAL 的开发初衷是能够让更多人可以更方便地制作属于自己的视觉小说。 -v9.wav;
在一开始，WebGAL 只具备很少的功能，仅仅能支持立绘和背景的显示、语音播放和分支选择。 -v10.wav;
在经历一年的发展后，现在已经是支持了很多优秀的表现效果的引擎了！ -v11.wav;
除此以外，WebGAL 编辑器的加入也使得制作和导出一个游戏更加方便快捷。 -v12.wav;
jumpLabel:end;

;分支2
label:choose2;
这个演示游戏使用的素材是 AI 生成的。 -v13.wav;
WebGAL 项目只用了一年不到就在 GitHub 获得了 1000 星标！ -v14.wav;
WebGAL 的开发历程，是一个在开发中学习开发的过程。因此她经历了3次重构，并且每次几乎都是推倒重来式的。 -v15.wav;
WebGAL 的脚本语言是为了简化制作难度而全新设计的！ -v16.wav;

;结束分支
label:end;
为了更接近桌面端视觉小说引擎的能力，我们支持很多快捷键以及可跳转的剧情回溯。 -v17.wav;
按下菜单中的“回想”按钮或者向上滚动鼠标滚轮试试吧！ -v18.wav;
快速存读挡、丰富的选项、自动播放以及快进等功能，也是应有尽有。 -v19.wav;
setTempAnimation:[{"position": {"x": 500,"y": 0},"duration": 0},{"position": {"x": 400,"y": 0},"duration": 250},{"position": {"x": 600,"y": 0},"duration": 500},{"position": {"x": 500,"y": 0},"duration": 250}] -target=fig-left -next;
当然，这不算什么，因为大多数成熟的引擎都有这些功能。但是在 Web 端，这却是很少见的。 -v20.wav;
我们为可能初次开发游戏的开发者提供了美观的通用 UI 和丰富的预设功能与动画。所以你可以没有顾虑地快速开始制作游戏。 -v21.wav;
WebGAL 项目组期待你的作品能够在 WebGAL 上呈现！只需要一个链接就可以让万千用户立刻开始享受你的作品。 -v22.wav;
感谢你关注 WebGAL 项目！ -v23.wav;
end;
; WebGAL 引擎会默认读取 start.txt 作为初始场景，因此请不要删除，并在初始场景内跳转到其他场景
bgm:s_Title.mp3;
unlockBgm:s_Title.mp3 -name=雲を追いかけて;
intro:你好|欢迎来到 WebGAL 的世界;
changeBg:bg.webp -next;
unlockCg:bg.webp -name=良夜; // 解锁CG并赋予名称
changeFigure:stand.webp -left -next;
setAnimation:enter-from-left -target=fig-left -next;
WebGAL:欢迎使用 WebGAL！这是一款全新的网页端视觉小说引擎。 -v1.wav;
changeFigure:stand2.webp -right -next;
WebGAL 是使用 Web 技术开发的引擎，因此在网页端有良好的表现。 -v2.wav;
由于这个特性，如果你将 WebGAL 部署到服务器或网页托管平台上，玩家只需要一串链接就可以开始游玩！ -v3.wav;
setAnimation:move-front-and-back -target=fig-left -next;
听起来是不是非常吸引人？ -v4.wav;
changeFigure:none -right -next;
setAnimation:l2c -target=fig-left -next;
WebGAL 引擎也具有动画系统和特效系统，使用 WebGAL 开发的游戏可以拥有很好的表现效果。 -v5.wav;
pixiInit;
pixiPerform:snow;
比如，这个下起小雪的特效。 -v6.wav;
除此以外，分支选择的功能也必不可少。 -v7.wav;
你可以通过以下两个分支了解 WebGAL 的更多故事。 -v8.wav;
pixiInit;
choose:WebGAL 发展历程:choose1|WebGAL 冷知识:choose2;

;分支1
label:choose1;
WebGAL 的开发初衷是能够让更多人可以更方便地制作属于自己的视觉小说。 -v9.wav;
在一开始，WebGAL 只具备很少的功能，仅仅能支持立绘和背景的显示、语音播放和分支选择。 -v10.wav;
在经历一年的发展后，现在已经是支持了很多优秀的表现效果的引擎了！ -v11.wav;
除此以外，WebGAL 编辑器的加入也使得制作和导出一个游戏更加方便快捷。 -v12.wav;
jumpLabel:end;

;分支2
label:choose2;
这个演示游戏使用的素材是 AI 生成的。 -v13.wav;
WebGAL 项目只用了一年不到就在 GitHub 获得了 1000 星标！ -v14.wav;
WebGAL 的开发历程，是一个在开发中学习开发的过程。因此她经历了3次重构，并且每次几乎都是推倒重来式的。 -v15.wav;
WebGAL 的脚本语言是为了简化制作难度而全新设计的！ -v16.wav;

;结束分支
label:end;
为了更接近桌面端视觉小说引擎的能力，我们支持很多快捷键以及可跳转的剧情回溯。 -v17.wav;
按下菜单中的“回想”按钮或者向上滚动鼠标滚轮试试吧！ -v18.wav;
快速存读挡、丰富的选项、自动播放以及快进等功能，也是应有尽有。 -v19.wav;
setTempAnimation:[{"position": {"x": 500,"y": 0},"duration": 0},{"position": {"x": 400,"y": 0},"duration": 250},{"position": {"x": 600,"y": 0},"duration": 500},{"position": {"x": 500,"y": 0},"duration": 250}] -target=fig-left -next;
当然，这不算什么，因为大多数成熟的引擎都有这些功能。但是在 Web 端，这却是很少见的。 -v20.wav;
我们为可能初次开发游戏的开发者提供了美观的通用 UI 和丰富的预设功能与动画。所以你可以没有顾虑地快速开始制作游戏。 -v21.wav;
WebGAL 项目组期待你的作品能够在 WebGAL 上呈现！只需要一个链接就可以让万千用户立刻开始享受你的作品。 -v22.wav;
感谢你关注 WebGAL 项目！ -v23.wav;
end;
; WebGAL 引擎会默认读取 start.txt 作为初始场景，因此请不要删除，并在初始场景内跳转到其他场景
bgm:s_Title.mp3;
unlockBgm:s_Title.mp3 -name=雲を追いかけて;
intro:你好|欢迎来到 WebGAL 的世界;
changeBg:bg.webp -next;
unlockCg:bg.webp -name=良夜; // 解锁CG并赋予名称
changeFigure:stand.webp -left -next;
setAnimation:enter-from-left -target=fig-left -next;
WebGAL:欢迎使用 WebGAL！这是一款全新的网页端视觉小说引擎。 -v1.wav;
changeFigure:stand2.webp -right -next;
WebGAL 是使用 Web 技术开发的引擎，因此在网页端有良好的表现。 -v2.wav;
由于这个特性，如果你将 WebGAL 部署到服务器或网页托管平台上，玩家只需要一串链接就可以开始游玩！ -v3.wav;
setAnimation:move-front-and-back -target=fig-left -next;
听起来是不是非常吸引人？ -v4.wav;
changeFigure:none -right -next;
setAnimation:l2c -target=fig-left -next;
WebGAL 引擎也具有动画系统和特效系统，使用 WebGAL 开发的游戏可以拥有很好的表现效果。 -v5.wav;
pixiInit;
pixiPerform:snow;
比如，这个下起小雪的特效。 -v6.wav;
除此以外，分支选择的功能也必不可少。 -v7.wav;
你可以通过以下两个分支了解 WebGAL 的更多故事。 -v8.wav;
pixiInit;
choose:WebGAL 发展历程:choose1|WebGAL 冷知识:choose2;

;分支1
label:choose1;
WebGAL 的开发初衷是能够让更多人可以更方便地制作属于自己的视觉小说。 -v9.wav;
在一开始，WebGAL 只具备很少的功能，仅仅能支持立绘和背景的显示、语音播放和分支选择。 -v10.wav;
在经历一年的发展后，现在已经是支持了很多优秀的表现效果的引擎了！ -v11.wav;
除此以外，WebGAL 编辑器的加入也使得制作和导出一个游戏更加方便快捷。 -v12.wav;
jumpLabel:end;

;分支2
label:choose2;
这个演示游戏使用的素材是 AI 生成的。 -v13.wav;
WebGAL 项目只用了一年不到就在 GitHub 获得了 1000 星标！ -v14.wav;
WebGAL 的开发历程，是一个在开发中学习开发的过程。因此她经历了3次重构，并且每次几乎都是推倒重来式的。 -v15.wav;
WebGAL 的脚本语言是为了简化制作难度而全新设计的！ -v16.wav;

;结束分支
label:end;
为了更接近桌面端视觉小说引擎的能力，我们支持很多快捷键以及可跳转的剧情回溯。 -v17.wav;
按下菜单中的“回想”按钮或者向上滚动鼠标滚轮试试吧！ -v18.wav;
快速存读挡、丰富的选项、自动播放以及快进等功能，也是应有尽有。 -v19.wav;
setTempAnimation:[{"position": {"x": 500,"y": 0},"duration": 0},{"position": {"x": 400,"y": 0},"duration": 250},{"position": {"x": 600,"y": 0},"duration": 500},{"position": {"x": 500,"y": 0},"duration": 250}] -target=fig-left -next;
当然，这不算什么，因为大多数成熟的引擎都有这些功能。但是在 Web 端，这却是很少见的。 -v20.wav;
我们为可能初次开发游戏的开发者提供了美观的通用 UI 和丰富的预设功能与动画。所以你可以没有顾虑地快速开始制作游戏。 -v21.wav;
WebGAL 项目组期待你的作品能够在 WebGAL 上呈现！只需要一个链接就可以让万千用户立刻开始享受你的作品。 -v22.wav;
感谢你关注 WebGAL 项目！ -v23.wav;
end;
; WebGAL 引擎会默认读取 start.txt 作为初始场景，因此请不要删除，并在初始场景内跳转到其他场景
bgm:s_Title.mp3;
unlockBgm:s_Title.mp3 -name=雲を追いかけて;
intro:你好|欢迎来到 WebGAL 的世界;
changeBg:bg.webp -next;
unlockCg:bg.webp -name=良夜; // 解锁CG并赋予名称
changeFigure:stand.webp -left -next;
setAnimation:enter-from-left -target=fig-left -next;
WebGAL:欢迎使用 WebGAL！这是一款全新的网页端视觉小说引擎。 -v1.wav;
changeFigure:stand2.webp -right -next;
WebGAL 是使用 Web 技术开发的引擎，因此在网页端有良好的表现。 -v2.wav;
由于这个特性，如果你将 WebGAL 部署到服务器或网页托管平台上，玩家只需要一串链接就可以开始游玩！ -v3.wav;
setAnimation:move-front-and-back -target=fig-left -next;
听起来是不是非常吸引人？ -v4.wav;
changeFigure:none -right -next;
setAnimation:l2c -target=fig-left -next;
WebGAL 引擎也具有动画系统和特效系统，使用 WebGAL 开发的游戏可以拥有很好的表现效果。 -v5.wav;
pixiInit;
pixiPerform:snow;
比如，这个下起小雪的特效。 -v6.wav;
除此以外，分支选择的功能也必不可少。 -v7.wav;
你可以通过以下两个分支了解 WebGAL 的更多故事。 -v8.wav;
pixiInit;
choose:WebGAL 发展历程:choose1|WebGAL 冷知识:choose2;

;分支1
label:choose1;
WebGAL 的开发初衷是能够让更多人可以更方便地制作属于自己的视觉小说。 -v9.wav;
在一开始，WebGAL 只具备很少的功能，仅仅能支持立绘和背景的显示、语音播放和分支选择。 -v10.wav;
在经历一年的发展后，现在已经是支持了很多优秀的表现效果的引擎了！ -v11.wav;
除此以外，WebGAL 编辑器的加入也使得制作和导出一个游戏更加方便快捷。 -v12.wav;
jumpLabel:end;

;分支2
label:choose2;
这个演示游戏使用的素材是 AI 生成的。 -v13.wav;
WebGAL 项目只用了一年不到就在 GitHub 获得了 1000 星标！ -v14.wav;
WebGAL 的开发历程，是一个在开发中学习开发的过程。因此她经历了3次重构，并且每次几乎都是推倒重来式的。 -v15.wav;
WebGAL 的脚本语言是为了简化制作难度而全新设计的！ -v16.wav;

;结束分支
label:end;
为了更接近桌面端视觉小说引擎的能力，我们支持很多快捷键以及可跳转的剧情回溯。 -v17.wav;
按下菜单中的“回想”按钮或者向上滚动鼠标滚轮试试吧！ -v18.wav;
快速存读挡、丰富的选项、自动播放以及快进等功能，也是应有尽有。 -v19.wav;
setTempAnimation:[{"position": {"x": 500,"y": 0},"duration": 0},{"position": {"x": 400,"y": 0},"duration": 250},{"position": {"x": 600,"y": 0},"duration": 500},{"position": {"x": 500,"y": 0},"duration": 250}] -target=fig-left -next;
当然，这不算什么，因为大多数成熟的引擎都有这些功能。但是在 Web 端，这却是很少见的。 -v20.wav;
我们为可能初次开发游戏的开发者提供了美观的通用 UI 和丰富的预设功能与动画。所以你可以没有顾虑地快速开始制作游戏。 -v21.wav;
WebGAL 项目组期待你的作品能够在 WebGAL 上呈现！只需要一个链接就可以让万千用户立刻开始享受你的作品。 -v22.wav;
感谢你关注 WebGAL 项目！ -v23.wav;
end;
; WebGAL 引擎会默认读取 start.txt 作为初始场景，因此请不要删除，并在初始场景内跳转到其他场景
bgm:s_Title.mp3;
unlockBgm:s_Title.mp3 -name=雲を追いかけて;
intro:你好|欢迎来到 WebGAL 的世界;
changeBg:bg.webp -next;
unlockCg:bg.webp -name=良夜; // 解锁CG并赋予名称
changeFigure:stand.webp -left -next;
setAnimation:enter-from-left -target=fig-left -next;
WebGAL:欢迎使用 WebGAL！这是一款全新的网页端视觉小说引擎。 -v1.wav;
changeFigure:stand2.webp -right -next;
WebGAL 是使用 Web 技术开发的引擎，因此在网页端有良好的表现。 -v2.wav;
由于这个特性，如果你将 WebGAL 部署到服务器或网页托管平台上，玩家只需要一串链接就可以开始游玩！ -v3.wav;
setAnimation:move-front-and-back -target=fig-left -next;
听起来是不是非常吸引人？ -v4.wav;
changeFigure:none -right -next;
setAnimation:l2c -target=fig-left -next;
WebGAL 引擎也具有动画系统和特效系统，使用 WebGAL 开发的游戏可以拥有很好的表现效果。 -v5.wav;
pixiInit;
pixiPerform:snow;
比如，这个下起小雪的特效。 -v6.wav;
除此以外，分支选择的功能也必不可少。 -v7.wav;
你可以通过以下两个分支了解 WebGAL 的更多故事。 -v8.wav;
pixiInit;
choose:WebGAL 发展历程:choose1|WebGAL 冷知识:choose2;

;分支1
label:choose1;
WebGAL 的开发初衷是能够让更多人可以更方便地制作属于自己的视觉小说。 -v9.wav;
在一开始，WebGAL 只具备很少的功能，仅仅能支持立绘和背景的显示、语音播放和分支选择。 -v10.wav;
在经历一年的发展后，现在已经是支持了很多优秀的表现效果的引擎了！ -v11.wav;
除此以外，WebGAL 编辑器的加入也使得制作和导出一个游戏更加方便快捷。 -v12.wav;
jumpLabel:end;

;分支2
label:choose2;
这个演示游戏使用的素材是 AI 生成的。 -v13.wav;
WebGAL 项目只用了一年不到就在 GitHub 获得了 1000 星标！ -v14.wav;
WebGAL 的开发历程，是一个在开发中学习开发的过程。因此她经历了3次重构，并且每次几乎都是推倒重来式的。 -v15.wav;
WebGAL 的脚本语言是为了简化制作难度而全新设计的！ -v16.wav;

;结束分支
label:end;
为了更接近桌面端视觉小说引擎的能力，我们支持很多快捷键以及可跳转的剧情回溯。 -v17.wav;
按下菜单中的“回想”按钮或者向上滚动鼠标滚轮试试吧！ -v18.wav;
快速存读挡、丰富的选项、自动播放以及快进等功能，也是应有尽有。 -v19.wav;
setTempAnimation:[{"position": {"x": 500,"y": 0},"duration": 0},{"position": {"x": 400,"y": 0},"duration": 250},{"position": {"x": 600,"y": 0},"duration": 500},{"position": {"x": 500,"y": 0},"duration": 250}] -target=fig-left -next;
当然，这不算什么，因为大多数成熟的引擎都有这些功能。但是在 Web 端，这却是很少见的。 -v20.wav;
我们为可能初次开发游戏的开发者提供了美观的通用 UI 和丰富的预设功能与动画。所以你可以没有顾虑地快速开始制作游戏。 -v21.wav;
WebGAL 项目组期待你的作品能够在 WebGAL 上呈现！只需要一个链接就可以让万千用户立刻开始享受你的作品。 -v22.wav;
感谢你关注 WebGAL 项目！ -v23.wav;
end;
; WebGAL 引擎会默认读取 start.txt 作为初始场景，因此请不要删除，并在初始场景内跳转到其他场景
bgm:s_Title.mp3;
unlockBgm:s_Title.mp3 -name=雲を追いかけて;
intro:你好|欢迎来到 WebGAL 的世界;
changeBg:bg.webp -next;
unlockCg:bg.webp -name=良夜; // 解锁CG并赋予名称
changeFigure:stand.webp -left -next;
setAnimation:enter-from-left -target=fig-left -next;
WebGAL:欢迎使用 WebGAL！这是一款全新的网页端视觉小说引擎。 -v1.wav;
changeFigure:stand2.webp -right -next;
WebGAL 是使用 Web 技术开发的引擎，因此在网页端有良好的表现。 -v2.wav;
由于这个特性，如果你将 WebGAL 部署到服务器或网页托管平台上，玩家只需要一串链接就可以开始游玩！ -v3.wav;
setAnimation:move-front-and-back -target=fig-left -next;
听起来是不是非常吸引人？ -v4.wav;
changeFigure:none -right -next;
setAnimation:l2c -target=fig-left -next;
WebGAL 引擎也具有动画系统和特效系统，使用 WebGAL 开发的游戏可以拥有很好的表现效果。 -v5.wav;
pixiInit;
pixiPerform:snow;
比如，这个下起小雪的特效。 -v6.wav;
除此以外，分支选择的功能也必不可少。 -v7.wav;
你可以通过以下两个分支了解 WebGAL 的更多故事。 -v8.wav;
pixiInit;
choose:WebGAL 发展历程:choose1|WebGAL 冷知识:choose2;

;分支1
label:choose1;
WebGAL 的开发初衷是能够让更多人可以更方便地制作属于自己的视觉小说。 -v9.wav;
在一开始，WebGAL 只具备很少的功能，仅仅能支持立绘和背景的显示、语音播放和分支选择。 -v10.wav;
在经历一年的发展后，现在已经是支持了很多优秀的表现效果的引擎了！ -v11.wav;
除此以外，WebGAL 编辑器的加入也使得制作和导出一个游戏更加方便快捷。 -v12.wav;
jumpLabel:end;

;分支2
label:choose2;
这个演示游戏使用的素材是 AI 生成的。 -v13.wav;
WebGAL 项目只用了一年不到就在 GitHub 获得了 1000 星标！ -v14.wav;
WebGAL 的开发历程，是一个在开发中学习开发的过程。因此她经历了3次重构，并且每次几乎都是推倒重来式的。 -v15.wav;
WebGAL 的脚本语言是为了简化制作难度而全新设计的！ -v16.wav;

;结束分支
label:end;
为了更接近桌面端视觉小说引擎的能力，我们支持很多快捷键以及可跳转的剧情回溯。 -v17.wav;
按下菜单中的“回想”按钮或者向上滚动鼠标滚轮试试吧！ -v18.wav;
快速存读挡、丰富的选项、自动播放以及快进等功能，也是应有尽有。 -v19.wav;
setTempAnimation:[{"position": {"x": 500,"y": 0},"duration": 0},{"position": {"x": 400,"y": 0},"duration": 250},{"position": {"x": 600,"y": 0},"duration": 500},{"position": {"x": 500,"y": 0},"duration": 250}] -target=fig-left -next;
当然，这不算什么，因为大多数成熟的引擎都有这些功能。但是在 Web 端，这却是很少见的。 -v20.wav;
我们为可能初次开发游戏的开发者提供了美观的通用 UI 和丰富的预设功能与动画。所以你可以没有顾虑地快速开始制作游戏。 -v21.wav;
WebGAL 项目组期待你的作品能够在 WebGAL 上呈现！只需要一个链接就可以让万千用户立刻开始享受你的作品。 -v22.wav;
感谢你关注 WebGAL 项目！ -v23.wav;
end;
; WebGAL 引擎会默认读取 start.txt 作为初始场景，因此请不要删除，并在初始场景内跳转到其他场景
bgm:s_Title.mp3;
unlockBgm:s_Title.mp3 -name=雲を追いかけて;
intro:你好|欢迎来到 WebGAL 的世界;
changeBg:bg.webp -next;
unlockCg:bg.webp -name=良夜; // 解锁CG并赋予名称
changeFigure:stand.webp -left -next;
setAnimation:enter-from-left -target=fig-left -next;
WebGAL:欢迎使用 WebGAL！这是一款全新的网页端视觉小说引擎。 -v1.wav;
changeFigure:stand2.webp -right -next;
WebGAL 是使用 Web 技术开发的引擎，因此在网页端有良好的表现。 -v2.wav;
由于这个特性，如果你将 WebGAL 部署到服务器或网页托管平台上，玩家只需要一串链接就可以开始游玩！ -v3.wav;
setAnimation:move-front-and-back -target=fig-left -next;
听起来是不是非常吸引人？ -v4.wav;
changeFigure:none -right -next;
setAnimation:l2c -target=fig-left -next;
WebGAL 引擎也具有动画系统和特效系统，使用 WebGAL 开发的游戏可以拥有很好的表现效果。 -v5.wav;
pixiInit;
pixiPerform:snow;
比如，这个下起小雪的特效。 -v6.wav;
除此以外，分支选择的功能也必不可少。 -v7.wav;
你可以通过以下两个分支了解 WebGAL 的更多故事。 -v8.wav;
pixiInit;
choose:WebGAL 发展历程:choose1|WebGAL 冷知识:choose2;

;分支1
label:choose1;
WebGAL 的开发初衷是能够让更多人可以更方便地制作属于自己的视觉小说。 -v9.wav;
在一开始，WebGAL 只具备很少的功能，仅仅能支持立绘和背景的显示、语音播放和分支选择。 -v10.wav;
在经历一年的发展后，现在已经是支持了很多优秀的表现效果的引擎了！ -v11.wav;
除此以外，WebGAL 编辑器的加入也使得制作和导出一个游戏更加方便快捷。 -v12.wav;
jumpLabel:end;

;分支2
label:choose2;
这个演示游戏使用的素材是 AI 生成的。 -v13.wav;
WebGAL 项目只用了一年不到就在 GitHub 获得了 1000 星标！ -v14.wav;
WebGAL 的开发历程，是一个在开发中学习开发的过程。因此她经历了3次重构，并且每次几乎都是推倒重来式的。 -v15.wav;
WebGAL 的脚本语言是为了简化制作难度而全新设计的！ -v16.wav;

;结束分支
label:end;
为了更接近桌面端视觉小说引擎的能力，我们支持很多快捷键以及可跳转的剧情回溯。 -v17.wav;
按下菜单中的“回想”按钮或者向上滚动鼠标滚轮试试吧！ -v18.wav;
快速存读挡、丰富的选项、自动播放以及快进等功能，也是应有尽有。 -v19.wav;
setTempAnimation:[{"position": {"x": 500,"y": 0},"duration": 0},{"position": {"x": 400,"y": 0},"duration": 250},{"position": {"x": 600,"y": 0},"duration": 500},{"position": {"x": 500,"y": 0},"duration": 250}] -target=fig-left -next;
当然，这不算什么，因为大多数成熟的引擎都有这些功能。但是在 Web 端，这却是很少见的。 -v20.wav;
我们为可能初次开发游戏的开发者提供了美观的通用 UI 和丰富的预设功能与动画。所以你可以没有顾虑地快速开始制作游戏。 -v21.wav;
WebGAL 项目组期待你的作品能够在 WebGAL 上呈现！只需要一个链接就可以让万千用户立刻开始享受你的作品。 -v22.wav;
感谢你关注 WebGAL 项目！ -v23.wav;
end;
; WebGAL 引擎会默认读取 start.txt 作为初始场景，因此请不要删除，并在初始场景内跳转到其他场景
bgm:s_Title.mp3;
unlockBgm:s_Title.mp3 -name=雲を追いかけて;
intro:你好|欢迎来到 WebGAL 的世界;
changeBg:bg.webp -next;
unlockCg:bg.webp -name=良夜; // 解锁CG并赋予名称
changeFigure:stand.webp -left -next;
setAnimation:enter-from-left -target=fig-left -next;
WebGAL:欢迎使用 WebGAL！这是一款全新的网页端视觉小说引擎。 -v1.wav;
changeFigure:stand2.webp -right -next;
WebGAL 是使用 Web 技术开发的引擎，因此在网页端有良好的表现。 -v2.wav;
由于这个特性，如果你将 WebGAL 部署到服务器或网页托管平台上，玩家只需要一串链接就可以开始游玩！ -v3.wav;
setAnimation:move-front-and-back -target=fig-left -next;
听起来是不是非常吸引人？ -v4.wav;
changeFigure:none -right -next;
setAnimation:l2c -target=fig-left -next;
WebGAL 引擎也具有动画系统和特效系统，使用 WebGAL 开发的游戏可以拥有很好的表现效果。 -v5.wav;
pixiInit;
pixiPerform:snow;
比如，这个下起小雪的特效。 -v6.wav;
除此以外，分支选择的功能也必不可少。 -v7.wav;
你可以通过以下两个分支了解 WebGAL 的更多故事。 -v8.wav;
pixiInit;
choose:WebGAL 发展历程:choose1|WebGAL 冷知识:choose2;

;分支1
label:choose1;
WebGAL 的开发初衷是能够让更多人可以更方便地制作属于自己的视觉小说。 -v9.wav;
在一开始，WebGAL 只具备很少的功能，仅仅能支持立绘和背景的显示、语音播放和分支选择。 -v10.wav;
在经历一年的发展后，现在已经是支持了很多优秀的表现效果的引擎了！ -v11.wav;
除此以外，WebGAL 编辑器的加入也使得制作和导出一个游戏更加方便快捷。 -v12.wav;
jumpLabel:end;

;分支2
label:choose2;
这个演示游戏使用的素材是 AI 生成的。 -v13.wav;
WebGAL 项目只用了一年不到就在 GitHub 获得了 1000 星标！ -v14.wav;
WebGAL 的开发历程，是一个在开发中学习开发的过程。因此她经历了3次重构，并且每次几乎都是推倒重来式的。 -v15.wav;
WebGAL 的脚本语言是为了简化制作难度而全新设计的！ -v16.wav;

;结束分支
label:end;
为了更接近桌面端视觉小说引擎的能力，我们支持很多快捷键以及可跳转的剧情回溯。 -v17.wav;
按下菜单中的“回想”按钮或者向上滚动鼠标滚轮试试吧！ -v18.wav;
快速存读挡、丰富的选项、自动播放以及快进等功能，也是应有尽有。 -v19.wav;
setTempAnimation:[{"position": {"x": 500,"y": 0},"duration": 0},{"position": {"x": 400,"y": 0},"duration": 250},{"position": {"x": 600,"y": 0},"duration": 500},{"position": {"x": 500,"y": 0},"duration": 250}] -target=fig-left -next;
当然，这不算什么，因为大多数成熟的引擎都有这些功能。但是在 Web 端，这却是很少见的。 -v20.wav;
我们为可能初次开发游戏的开发者提供了美观的通用 UI 和丰富的预设功能与动画。所以你可以没有顾虑地快速开始制作游戏。 -v21.wav;
WebGAL 项目组期待你的作品能够在 WebGAL 上呈现！只需要一个链接就可以让万千用户立刻开始享受你的作品。 -v22.wav;
感谢你关注 WebGAL 项目！ -v23.wav;
end;
; WebGAL 引擎会默认读取 start.txt 作为初始场景，因此请不要删除，并在初始场景内跳转到其他场景
bgm:s_Title.mp3;
unlockBgm:s_Title.mp3 -name=雲を追いかけて;
intro:你好|欢迎来到 WebGAL 的世界;
changeBg:bg.webp -next;
unlockCg:bg.webp -name=良夜; // 解锁CG并赋予名称
changeFigure:stand.webp -left -next;
setAnimation:enter-from-left -target=fig-left -next;
WebGAL:欢迎使用 WebGAL！这是一款全新的网页端视觉小说引擎。 -v1.wav;
changeFigure:stand2.webp -right -next;
WebGAL 是使用 Web 技术开发的引擎，因此在网页端有良好的表现。 -v2.wav;
由于这个特性，如果你将 WebGAL 部署到服务器或网页托管平台上，玩家只需要一串链接就可以开始游玩！ -v3.wav;
setAnimation:move-front-and-back -target=fig-left -next;
听起来是不是非常吸引人？ -v4.wav;
changeFigure:none -right -next;
setAnimation:l2c -target=fig-left -next;
WebGAL 引擎也具有动画系统和特效系统，使用 WebGAL 开发的游戏可以拥有很好的表现效果。 -v5.wav;
pixiInit;
pixiPerform:snow;
比如，这个下起小雪的特效。 -v6.wav;
除此以外，分支选择的功能也必不可少。 -v7.wav;
你可以通过以下两个分支了解 WebGAL 的更多故事。 -v8.wav;
pixiInit;
choose:WebGAL 发展历程:choose1|WebGAL 冷知识:choose2;

;分支1
label:choose1;
WebGAL 的开发初衷是能够让更多人可以更方便地制作属于自己的视觉小说。 -v9.wav;
在一开始，WebGAL 只具备很少的功能，仅仅能支持立绘和背景的显示、语音播放和分支选择。 -v10.wav;
在经历一年的发展后，现在已经是支持了很多优秀的表现效果的引擎了！ -v11.wav;
除此以外，WebGAL 编辑器的加入也使得制作和导出一个游戏更加方便快捷。 -v12.wav;
jumpLabel:end;

;分支2
label:choose2;
这个演示游戏使用的素材是 AI 生成的。 -v13.wav;
WebGAL 项目只用了一年不到就在 GitHub 获得了 1000 星标！ -v14.wav;
WebGAL 的开发历程，是一个在开发中学习开发的过程。因此她经历了3次重构，并且每次几乎都是推倒重来式的。 -v15.wav;
WebGAL 的脚本语言是为了简化制作难度而全新设计的！ -v16.wav;

;结束分支
label:end;
为了更接近桌面端视觉小说引擎的能力，我们支持很多快捷键以及可跳转的剧情回溯。 -v17.wav;
按下菜单中的“回想”按钮或者向上滚动鼠标滚轮试试吧！ -v18.wav;
快速存读挡、丰富的选项、自动播放以及快进等功能，也是应有尽有。 -v19.wav;
setTempAnimation:[{"position": {"x": 500,"y": 0},"duration": 0},{"position": {"x": 400,"y": 0},"duration": 250},{"position": {"x": 600,"y": 0},"duration": 500},{"position": {"x": 500,"y": 0},"duration": 250}] -target=fig-left -next;
当然，这不算什么，因为大多数成熟的引擎都有这些功能。但是在 Web 端，这却是很少见的。 -v20.wav;
我们为可能初次开发游戏的开发者提供了美观的通用 UI 和丰富的预设功能与动画。所以你可以没有顾虑地快速开始制作游戏。 -v21.wav;
WebGAL 项目组期待你的作品能够在 WebGAL 上呈现！只需要一个链接就可以让万千用户立刻开始享受你的作品。 -v22.wav;
感谢你关注 WebGAL 项目！ -v23.wav;
end;
; WebGAL 引擎会默认读取 start.txt 作为初始场景，因此请不要删除，并在初始场景内跳转到其他场景
bgm:s_Title.mp3;
unlockBgm:s_Title.mp3 -name=雲を追いかけて;
intro:你好|欢迎来到 WebGAL 的世界;
changeBg:bg.webp -next;
unlockCg:bg.webp -name=良夜; // 解锁CG并赋予名称
changeFigure:stand.webp -left -next;
setAnimation:enter-from-left -target=fig-left -next;
WebGAL:欢迎使用 WebGAL！这是一款全新的网页端视觉小说引擎。 -v1.wav;
changeFigure:stand2.webp -right -next;
WebGAL 是使用 Web 技术开发的引擎，因此在网页端有良好的表现。 -v2.wav;
由于这个特性，如果你将 WebGAL 部署到服务器或网页托管平台上，玩家只需要一串链接就可以开始游玩！ -v3.wav;
setAnimation:move-front-and-back -target=fig-left -next;
听起来是不是非常吸引人？ -v4.wav;
changeFigure:none -right -next;
setAnimation:l2c -target=fig-left -next;
WebGAL 引擎也具有动画系统和特效系统，使用 WebGAL 开发的游戏可以拥有很好的表现效果。 -v5.wav;
pixiInit;
pixiPerform:snow;
比如，这个下起小雪的特效。 -v6.wav;
除此以外，分支选择的功能也必不可少。 -v7.wav;
你可以通过以下两个分支了解 WebGAL 的更多故事。 -v8.wav;
pixiInit;
choose:WebGAL 发展历程:choose1|WebGAL 冷知识:choose2;

;分支1
label:choose1;
WebGAL 的开发初衷是能够让更多人可以更方便地制作属于自己的视觉小说。 -v9.wav;
在一开始，WebGAL 只具备很少的功能，仅仅能支持立绘和背景的显示、语音播放和分支选择。 -v10.wav;
在经历一年的发展后，现在已经是支持了很多优秀的表现效果的引擎了！ -v11.wav;
除此以外，WebGAL 编辑器的加入也使得制作和导出一个游戏更加方便快捷。 -v12.wav;
jumpLabel:end;

;分支2
label:choose2;
这个演示游戏使用的素材是 AI 生成的。 -v13.wav;
WebGAL 项目只用了一年不到就在 GitHub 获得了 1000 星标！ -v14.wav;
WebGAL 的开发历程，是一个在开发中学习开发的过程。因此她经历了3次重构，并且每次几乎都是推倒重来式的。 -v15.wav;
WebGAL 的脚本语言是为了简化制作难度而全新设计的！ -v16.wav;

;结束分支
label:end;
为了更接近桌面端视觉小说引擎的能力，我们支持很多快捷键以及可跳转的剧情回溯。 -v17.wav;
按下菜单中的“回想”按钮或者向上滚动鼠标滚轮试试吧！ -v18.wav;
快速存读挡、丰富的选项、自动播放以及快进等功能，也是应有尽有。 -v19.wav;
setTempAnimation:[{"position": {"x": 500,"y": 0},"duration": 0},{"position": {"x": 400,"y": 0},"duration": 250},{"position": {"x": 600,"y": 0},"duration": 500},{"position": {"x": 500,"y": 0},"duration": 250}] -target=fig-left -next;
当然，这不算什么，因为大多数成熟的引擎都有这些功能。但是在 Web 端，这却是很少见的。 -v20.wav;
我们为可能初次开发游戏的开发者提供了美观的通用 UI 和丰富的预设功能与动画。所以你可以没有顾虑地快速开始制作游戏。 -v21.wav;
WebGAL 项目组期待你的作品能够在 WebGAL 上呈现！只需要一个链接就可以让万千用户立刻开始享受你的作品。 -v22.wav;
感谢你关注 WebGAL 项目！ -v23.wav;
end;
; WebGAL 引擎会默认读取 start.txt 作为初始场景，因此请不要删除，并在初始场景内跳转到其他场景
bgm:s_Title.mp3;
unlockBgm:s_Title.mp3 -name=雲を追いかけて;
intro:你好|欢迎来到 WebGAL 的世界;
changeBg:bg.webp -next;
unlockCg:bg.webp -name=良夜; // 解锁CG并赋予名称
changeFigure:stand.webp -left -next;
setAnimation:enter-from-left -target=fig-left -next;
WebGAL:欢迎使用 WebGAL！这是一款全新的网页端视觉小说引擎。 -v1.wav;
changeFigure:stand2.webp -right -next;
WebGAL 是使用 Web 技术开发的引擎，因此在网页端有良好的表现。 -v2.wav;
由于这个特性，如果你将 WebGAL 部署到服务器或网页托管平台上，玩家只需要一串链接就可以开始游玩！ -v3.wav;
setAnimation:move-front-and-back -target=fig-left -next;
听起来是不是非常吸引人？ -v4.wav;
changeFigure:none -right -next;
setAnimation:l2c -target=fig-left -next;
WebGAL 引擎也具有动画系统和特效系统，使用 WebGAL 开发的游戏可以拥有很好的表现效果。 -v5.wav;
pixiInit;
pixiPerform:snow;
比如，这个下起小雪的特效。 -v6.wav;
除此以外，分支选择的功能也必不可少。 -v7.wav;
你可以通过以下两个分支了解 WebGAL 的更多故事。 -v8.wav;
pixiInit;
choose:WebGAL 发展历程:choose1|WebGAL 冷知识:choose2;

;分支1
label:choose1;
WebGAL 的开发初衷是能够让更多人可以更方便地制作属于自己的视觉小说。 -v9.wav;
在一开始，WebGAL 只具备很少的功能，仅仅能支持立绘和背景的显示、语音播放和分支选择。 -v10.wav;
在经历一年的发展后，现在已经是支持了很多优秀的表现效果的引擎了！ -v11.wav;
除此以外，WebGAL 编辑器的加入也使得制作和导出一个游戏更加方便快捷。 -v12.wav;
jumpLabel:end;

;分支2
label:choose2;
这个演示游戏使用的素材是 AI 生成的。 -v13.wav;
WebGAL 项目只用了一年不到就在 GitHub 获得了 1000 星标！ -v14.wav;
WebGAL 的开发历程，是一个在开发中学习开发的过程。因此她经历了3次重构，并且每次几乎都是推倒重来式的。 -v15.wav;
WebGAL 的脚本语言是为了简化制作难度而全新设计的！ -v16.wav;

;结束分支
label:end;
为了更接近桌面端视觉小说引擎的能力，我们支持很多快捷键以及可跳转的剧情回溯。 -v17.wav;
按下菜单中的“回想”按钮或者向上滚动鼠标滚轮试试吧！ -v18.wav;
快速存读挡、丰富的选项、自动播放以及快进等功能，也是应有尽有。 -v19.wav;
setTempAnimation:[{"position": {"x": 500,"y": 0},"duration": 0},{"position": {"x": 400,"y": 0},"duration": 250},{"position": {"x": 600,"y": 0},"duration": 500},{"position": {"x": 500,"y": 0},"duration": 250}] -target=fig-left -next;
当然，这不算什么，因为大多数成熟的引擎都有这些功能。但是在 Web 端，这却是很少见的。 -v20.wav;
我们为可能初次开发游戏的开发者提供了美观的通用 UI 和丰富的预设功能与动画。所以你可以没有顾虑地快速开始制作游戏。 -v21.wav;
WebGAL 项目组期待你的作品能够在 WebGAL 上呈现！只需要一个链接就可以让万千用户立刻开始享受你的作品。 -v22.wav;
感谢你关注 WebGAL 项目！ -v23.wav;
end;
; WebGAL 引擎会默认读取 start.txt 作为初始场景，因此请不要删除，并在初始场景内跳转到其他场景
bgm:s_Title.mp3;
unlockBgm:s_Title.mp3 -name=雲を追いかけて;
intro:你好|欢迎来到 WebGAL 的世界;
changeBg:bg.webp -next;
unlockCg:bg.webp -name=良夜; // 解锁CG并赋予名称
changeFigure:stand.webp -left -next;
setAnimation:enter-from-left -target=fig-left -next;
WebGAL:欢迎使用 WebGAL！这是一款全新的网页端视觉小说引擎。 -v1.wav;
changeFigure:stand2.webp -right -next;
WebGAL 是使用 Web 技术开发的引擎，因此在网页端有良好的表现。 -v2.wav;
由于这个特性，如果你将 WebGAL 部署到服务器或网页托管平台上，玩家只需要一串链接就可以开始游玩！ -v3.wav;
setAnimation:move-front-and-back -target=fig-left -next;
听起来是不是非常吸引人？ -v4.wav;
changeFigure:none -right -next;
setAnimation:l2c -target=fig-left -next;
WebGAL 引擎也具有动画系统和特效系统，使用 WebGAL 开发的游戏可以拥有很好的表现效果。 -v5.wav;
pixiInit;
pixiPerform:snow;
比如，这个下起小雪的特效。 -v6.wav;
除此以外，分支选择的功能也必不可少。 -v7.wav;
你可以通过以下两个分支了解 WebGAL 的更多故事。 -v8.wav;
pixiInit;
choose:WebGAL 发展历程:choose1|WebGAL 冷知识:choose2;

;分支1
label:choose1;
WebGAL 的开发初衷是能够让更多人可以更方便地制作属于自己的视觉小说。 -v9.wav;
在一开始，WebGAL 只具备很少的功能，仅仅能支持立绘和背景的显示、语音播放和分支选择。 -v10.wav;
在经历一年的发展后，现在已经是支持了很多优秀的表现效果的引擎了！ -v11.wav;
除此以外，WebGAL 编辑器的加入也使得制作和导出一个游戏更加方便快捷。 -v12.wav;
jumpLabel:end;

;分支2
label:choose2;
这个演示游戏使用的素材是 AI 生成的。 -v13.wav;
WebGAL 项目只用了一年不到就在 GitHub 获得了 1000 星标！ -v14.wav;
WebGAL 的开发历程，是一个在开发中学习开发的过程。因此她经历了3次重构，并且每次几乎都是推倒重来式的。 -v15.wav;
WebGAL 的脚本语言是为了简化制作难度而全新设计的！ -v16.wav;

;结束分支
label:end;
为了更接近桌面端视觉小说引擎的能力，我们支持很多快捷键以及可跳转的剧情回溯。 -v17.wav;
按下菜单中的“回想”按钮或者向上滚动鼠标滚轮试试吧！ -v18.wav;
快速存读挡、丰富的选项、自动播放以及快进等功能，也是应有尽有。 -v19.wav;
setTempAnimation:[{"position": {"x": 500,"y": 0},"duration": 0},{"position": {"x": 400,"y": 0},"duration": 250},{"position": {"x": 600,"y": 0},"duration": 500},{"position": {"x": 500,"y": 0},"duration": 250}] -target=fig-left -next;
当然，这不算什么，因为大多数成熟的引擎都有这些功能。但是在 Web 端，这却是很少见的。 -v20.wav;
我们为可能初次开发游戏的开发者提供了美观的通用 UI 和丰富的预设功能与动画。所以你可以没有顾虑地快速开始制作游戏。 -v21.wav;
WebGAL 项目组期待你的作品能够在 WebGAL 上呈现！只需要一个链接就可以让万千用户立刻开始享受你的作品。 -v22.wav;
感谢你关注 WebGAL 项目！ -v23.wav;
end;
; WebGAL 引擎会默认读取 start.txt 作为初始场景，因此请不要删除，并在初始场景内跳转到其他场景
bgm:s_Title.mp3;
unlockBgm:s_Title.mp3 -name=雲を追いかけて;
intro:你好|欢迎来到 WebGAL 的世界;
changeBg:bg.webp -next;
unlockCg:bg.webp -name=良夜; // 解锁CG并赋予名称
changeFigure:stand.webp -left -next;
setAnimation:enter-from-left -target=fig-left -next;
WebGAL:欢迎使用 WebGAL！这是一款全新的网页端视觉小说引擎。 -v1.wav;
changeFigure:stand2.webp -right -next;
WebGAL 是使用 Web 技术开发的引擎，因此在网页端有良好的表现。 -v2.wav;
由于这个特性，如果你将 WebGAL 部署到服务器或网页托管平台上，玩家只需要一串链接就可以开始游玩！ -v3.wav;
setAnimation:move-front-and-back -target=fig-left -next;
听起来是不是非常吸引人？ -v4.wav;
changeFigure:none -right -next;
setAnimation:l2c -target=fig-left -next;
WebGAL 引擎也具有动画系统和特效系统，使用 WebGAL 开发的游戏可以拥有很好的表现效果。 -v5.wav;
pixiInit;
pixiPerform:snow;
比如，这个下起小雪的特效。 -v6.wav;
除此以外，分支选择的功能也必不可少。 -v7.wav;
你可以通过以下两个分支了解 WebGAL 的更多故事。 -v8.wav;
pixiInit;
choose:WebGAL 发展历程:choose1|WebGAL 冷知识:choose2;

;分支1
label:choose1;
WebGAL 的开发初衷是能够让更多人可以更方便地制作属于自己的视觉小说。 -v9.wav;
在一开始，WebGAL 只具备很少的功能，仅仅能支持立绘和背景的显示、语音播放和分支选择。 -v10.wav;
在经历一年的发展后，现在已经是支持了很多优秀的表现效果的引擎了！ -v11.wav;
除此以外，WebGAL 编辑器的加入也使得制作和导出一个游戏更加方便快捷。 -v12.wav;
jumpLabel:end;

;分支2
label:choose2;
这个演示游戏使用的素材是 AI 生成的。 -v13.wav;
WebGAL 项目只用了一年不到就在 GitHub 获得了 1000 星标！ -v14.wav;
WebGAL 的开发历程，是一个在开发中学习开发的过程。因此她经历了3次重构，并且每次几乎都是推倒重来式的。 -v15.wav;
WebGAL 的脚本语言是为了简化制作难度而全新设计的！ -v16.wav;

;结束分支
label:end;
为了更接近桌面端视觉小说引擎的能力，我们支持很多快捷键以及可跳转的剧情回溯。 -v17.wav;
按下菜单中的“回想”按钮或者向上滚动鼠标滚轮试试吧！ -v18.wav;
快速存读挡、丰富的选项、自动播放以及快进等功能，也是应有尽有。 -v19.wav;
setTempAnimation:[{"position": {"x": 500,"y": 0},"duration": 0},{"position": {"x": 400,"y": 0},"duration": 250},{"position": {"x": 600,"y": 0},"duration": 500},{"position": {"x": 500,"y": 0},"duration": 250}] -target=fig-left -next;
当然，这不算什么，因为大多数成熟的引擎都有这些功能。但是在 Web 端，这却是很少见的。 -v20.wav;
我们为可能初次开发游戏的开发者提供了美观的通用 UI 和丰富的预设功能与动画。所以你可以没有顾虑地快速开始制作游戏。 -v21.wav;
WebGAL 项目组期待你的作品能够在 WebGAL 上呈现！只需要一个链接就可以让万千用户立刻开始享受你的作品。 -v22.wav;
感谢你关注 WebGAL 项目！ -v23.wav;
end;
; WebGAL 引擎会默认读取 start.txt 作为初始场景，因此请不要删除，并在初始场景内跳转到其他场景
bgm:s_Title.mp3;
unlockBgm:s_Title.mp3 -name=雲を追いかけて;
intro:你好|欢迎来到 WebGAL 的世界;
changeBg:bg.webp -next;
unlockCg:bg.webp -name=良夜; // 解锁CG并赋予名称
changeFigure:stand.webp -left -next;
setAnimation:enter-from-left -target=fig-left -next;
WebGAL:欢迎使用 WebGAL！这是一款全新的网页端视觉小说引擎。 -v1.wav;
changeFigure:stand2.webp -right -next;
WebGAL 是使用 Web 技术开发的引擎，因此在网页端有良好的表现。 -v2.wav;
由于这个特性，如果你将 WebGAL 部署到服务器或网页托管平台上，玩家只需要一串链接就可以开始游玩！ -v3.wav;
setAnimation:move-front-and-back -target=fig-left -next;
听起来是不是非常吸引人？ -v4.wav;
changeFigure:none -right -next;
setAnimation:l2c -target=fig-left -next;
WebGAL 引擎也具有动画系统和特效系统，使用 WebGAL 开发的游戏可以拥有很好的表现效果。 -v5.wav;
pixiInit;
pixiPerform:snow;
比如，这个下起小雪的特效。 -v6.wav;
除此以外，分支选择的功能也必不可少。 -v7.wav;
你可以通过以下两个分支了解 WebGAL 的更多故事。 -v8.wav;
pixiInit;
choose:WebGAL 发展历程:choose1|WebGAL 冷知识:choose2;

;分支1
label:choose1;
WebGAL 的开发初衷是能够让更多人可以更方便地制作属于自己的视觉小说。 -v9.wav;
在一开始，WebGAL 只具备很少的功能，仅仅能支持立绘和背景的显示、语音播放和分支选择。 -v10.wav;
在经历一年的发展后，现在已经是支持了很多优秀的表现效果的引擎了！ -v11.wav;
除此以外，WebGAL 编辑器的加入也使得制作和导出一个游戏更加方便快捷。 -v12.wav;
jumpLabel:end;

;分支2
label:choose2;
这个演示游戏使用的素材是 AI 生成的。 -v13.wav;
WebGAL 项目只用了一年不到就在 GitHub 获得了 1000 星标！ -v14.wav;
WebGAL 的开发历程，是一个在开发中学习开发的过程。因此她经历了3次重构，并且每次几乎都是推倒重来式的。 -v15.wav;
WebGAL 的脚本语言是为了简化制作难度而全新设计的！ -v16.wav;

;结束分支
label:end;
为了更接近桌面端视觉小说引擎的能力，我们支持很多快捷键以及可跳转的剧情回溯。 -v17.wav;
按下菜单中的“回想”按钮或者向上滚动鼠标滚轮试试吧！ -v18.wav;
快速存读挡、丰富的选项、自动播放以及快进等功能，也是应有尽有。 -v19.wav;
setTempAnimation:[{"position": {"x": 500,"y": 0},"duration": 0},{"position": {"x": 400,"y": 0},"duration": 250},{"position": {"x": 600,"y": 0},"duration": 500},{"position": {"x": 500,"y": 0},"duration": 250}] -target=fig-left -next;
当然，这不算什么，因为大多数成熟的引擎都有这些功能。但是在 Web 端，这却是很少见的。 -v20.wav;
我们为可能初次开发游戏的开发者提供了美观的通用 UI 和丰富的预设功能与动画。所以你可以没有顾虑地快速开始制作游戏。 -v21.wav;
WebGAL 项目组期待你的作品能够在 WebGAL 上呈现！只需要一个链接就可以让万千用户立刻开始享受你的作品。 -v22.wav;
感谢你关注 WebGAL 项目！ -v23.wav;
end;
; WebGAL 引擎会默认读取 start.txt 作为初始场景，因此请不要删除，并在初始场景内跳转到其他场景
bgm:s_Title.mp3;
unlockBgm:s_Title.mp3 -name=雲を追いかけて;
intro:你好|欢迎来到 WebGAL 的世界;
changeBg:bg.webp -next;
unlockCg:bg.webp -name=良夜; // 解锁CG并赋予名称
changeFigure:stand.webp -left -next;
setAnimation:enter-from-left -target=fig-left -next;
WebGAL:欢迎使用 WebGAL！这是一款全新的网页端视觉小说引擎。 -v1.wav;
changeFigure:stand2.webp -right -next;
WebGAL 是使用 Web 技术开发的引擎，因此在网页端有良好的表现。 -v2.wav;
由于这个特性，如果你将 WebGAL 部署到服务器或网页托管平台上，玩家只需要一串链接就可以开始游玩！ -v3.wav;
setAnimation:move-front-and-back -target=fig-left -next;
听起来是不是非常吸引人？ -v4.wav;
changeFigure:none -right -next;
setAnimation:l2c -target=fig-left -next;
WebGAL 引擎也具有动画系统和特效系统，使用 WebGAL 开发的游戏可以拥有很好的表现效果。 -v5.wav;
pixiInit;
pixiPerform:snow;
比如，这个下起小雪的特效。 -v6.wav;
除此以外，分支选择的功能也必不可少。 -v7.wav;
你可以通过以下两个分支了解 WebGAL 的更多故事。 -v8.wav;
pixiInit;
choose:WebGAL 发展历程:choose1|WebGAL 冷知识:choose2;

;分支1
label:choose1;
WebGAL 的开发初衷是能够让更多人可以更方便地制作属于自己的视觉小说。 -v9.wav;
在一开始，WebGAL 只具备很少的功能，仅仅能支持立绘和背景的显示、语音播放和分支选择。 -v10.wav;
在经历一年的发展后，现在已经是支持了很多优秀的表现效果的引擎了！ -v11.wav;
除此以外，WebGAL 编辑器的加入也使得制作和导出一个游戏更加方便快捷。 -v12.wav;
jumpLabel:end;

;分支2
label:choose2;
这个演示游戏使用的素材是 AI 生成的。 -v13.wav;
WebGAL 项目只用了一年不到就在 GitHub 获得了 1000 星标！ -v14.wav;
WebGAL 的开发历程，是一个在开发中学习开发的过程。因此她经历了3次重构，并且每次几乎都是推倒重来式的。 -v15.wav;
WebGAL 的脚本语言是为了简化制作难度而全新设计的！ -v16.wav;

;结束分支
label:end;
为了更接近桌面端视觉小说引擎的能力，我们支持很多快捷键以及可跳转的剧情回溯。 -v17.wav;
按下菜单中的“回想”按钮或者向上滚动鼠标滚轮试试吧！ -v18.wav;
快速存读挡、丰富的选项、自动播放以及快进等功能，也是应有尽有。 -v19.wav;
setTempAnimation:[{"position": {"x": 500,"y": 0},"duration": 0},{"position": {"x": 400,"y": 0},"duration": 250},{"position": {"x": 600,"y": 0},"duration": 500},{"position": {"x": 500,"y": 0},"duration": 250}] -target=fig-left -next;
当然，这不算什么，因为大多数成熟的引擎都有这些功能。但是在 Web 端，这却是很少见的。 -v20.wav;
我们为可能初次开发游戏的开发者提供了美观的通用 UI 和丰富的预设功能与动画。所以你可以没有顾虑地快速开始制作游戏。 -v21.wav;
WebGAL 项目组期待你的作品能够在 WebGAL 上呈现！只需要一个链接就可以让万千用户立刻开始享受你的作品。 -v22.wav;
感谢你关注 WebGAL 项目！ -v23.wav;
end;
; WebGAL 引擎会默认读取 start.txt 作为初始场景，因此请不要删除，并在初始场景内跳转到其他场景
bgm:s_Title.mp3;
unlockBgm:s_Title.mp3 -name=雲を追いかけて;
intro:你好|欢迎来到 WebGAL 的世界;
changeBg:bg.webp -next;
unlockCg:bg.webp -name=良夜; // 解锁CG并赋予名称
changeFigure:stand.webp -left -next;
setAnimation:enter-from-left -target=fig-left -next;
WebGAL:欢迎使用 WebGAL！这是一款全新的网页端视觉小说引擎。 -v1.wav;
changeFigure:stand2.webp -right -next;
WebGAL 是使用 Web 技术开发的引擎，因此在网页端有良好的表现。 -v2.wav;
由于这个特性，如果你将 WebGAL 部署到服务器或网页托管平台上，玩家只需要一串链接就可以开始游玩！ -v3.wav;
setAnimation:move-front-and-back -target=fig-left -next;
听起来是不是非常吸引人？ -v4.wav;
changeFigure:none -right -next;
setAnimation:l2c -target=fig-left -next;
WebGAL 引擎也具有动画系统和特效系统，使用 WebGAL 开发的游戏可以拥有很好的表现效果。 -v5.wav;
pixiInit;
pixiPerform:snow;
比如，这个下起小雪的特效。 -v6.wav;
除此以外，分支选择的功能也必不可少。 -v7.wav;
你可以通过以下两个分支了解 WebGAL 的更多故事。 -v8.wav;
pixiInit;
choose:WebGAL 发展历程:choose1|WebGAL 冷知识:choose2;

;分支1
label:choose1;
WebGAL 的开发初衷是能够让更多人可以更方便地制作属于自己的视觉小说。 -v9.wav;
在一开始，WebGAL 只具备很少的功能，仅仅能支持立绘和背景的显示、语音播放和分支选择。 -v10.wav;
在经历一年的发展后，现在已经是支持了很多优秀的表现效果的引擎了！ -v11.wav;
除此以外，WebGAL 编辑器的加入也使得制作和导出一个游戏更加方便快捷。 -v12.wav;
jumpLabel:end;

;分支2
label:choose2;
这个演示游戏使用的素材是 AI 生成的。 -v13.wav;
WebGAL 项目只用了一年不到就在 GitHub 获得了 1000 星标！ -v14.wav;
WebGAL 的开发历程，是一个在开发中学习开发的过程。因此她经历了3次重构，并且每次几乎都是推倒重来式的。 -v15.wav;
WebGAL 的脚本语言是为了简化制作难度而全新设计的！ -v16.wav;

;结束分支
label:end;
为了更接近桌面端视觉小说引擎的能力，我们支持很多快捷键以及可跳转的剧情回溯。 -v17.wav;
按下菜单中的“回想”按钮或者向上滚动鼠标滚轮试试吧！ -v18.wav;
快速存读挡、丰富的选项、自动播放以及快进等功能，也是应有尽有。 -v19.wav;
setTempAnimation:[{"position": {"x": 500,"y": 0},"duration": 0},{"position": {"x": 400,"y": 0},"duration": 250},{"position": {"x": 600,"y": 0},"duration": 500},{"position": {"x": 500,"y": 0},"duration": 250}] -target=fig-left -next;
当然，这不算什么，因为大多数成熟的引擎都有这些功能。但是在 Web 端，这却是很少见的。 -v20.wav;
我们为可能初次开发游戏的开发者提供了美观的通用 UI 和丰富的预设功能与动画。所以你可以没有顾虑地快速开始制作游戏。 -v21.wav;
WebGAL 项目组期待你的作品能够在 WebGAL 上呈现！只需要一个链接就可以让万千用户立刻开始享受你的作品。 -v22.wav;
感谢你关注 WebGAL 项目！ -v23.wav;
end;
; WebGAL 引擎会默认读取 start.txt 作为初始场景，因此请不要删除，并在初始场景内跳转到其他场景
bgm:s_Title.mp3;
unlockBgm:s_Title.mp3 -name=雲を追いかけて;
intro:你好|欢迎来到 WebGAL 的世界;
changeBg:bg.webp -next;
unlockCg:bg.webp -name=良夜; // 解锁CG并赋予名称
changeFigure:stand.webp -left -next;
setAnimation:enter-from-left -target=fig-left -next;
WebGAL:欢迎使用 WebGAL！这是一款全新的网页端视觉小说引擎。 -v1.wav;
changeFigure:stand2.webp -right -next;
WebGAL 是使用 Web 技术开发的引擎，因此在网页端有良好的表现。 -v2.wav;
由于这个特性，如果你将 WebGAL 部署到服务器或网页托管平台上，玩家只需要一串链接就可以开始游玩！ -v3.wav;
setAnimation:move-front-and-back -target=fig-left -next;
听起来是不是非常吸引人？ -v4.wav;
changeFigure:none -right -next;
setAnimation:l2c -target=fig-left -next;
WebGAL 引擎也具有动画系统和特效系统，使用 WebGAL 开发的游戏可以拥有很好的表现效果。 -v5.wav;
pixiInit;
pixiPerform:snow;
比如，这个下起小雪的特效。 -v6.wav;
除此以外，分支选择的功能也必不可少。 -v7.wav;
你可以通过以下两个分支了解 WebGAL 的更多故事。 -v8.wav;
pixiInit;
choose:WebGAL 发展历程:choose1|WebGAL 冷知识:choose2;

;分支1
label:choose1;
WebGAL 的开发初衷是能够让更多人可以更方便地制作属于自己的视觉小说。 -v9.wav;
在一开始，WebGAL 只具备很少的功能，仅仅能支持立绘和背景的显示、语音播放和分支选择。 -v10.wav;
在经历一年的发展后，现在已经是支持了很多优秀的表现效果的引擎了！ -v11.wav;
除此以外，WebGAL 编辑器的加入也使得制作和导出一个游戏更加方便快捷。 -v12.wav;
jumpLabel:end;

;分支2
label:choose2;
这个演示游戏使用的素材是 AI 生成的。 -v13.wav;
WebGAL 项目只用了一年不到就在 GitHub 获得了 1000 星标！ -v14.wav;
WebGAL 的开发历程，是一个在开发中学习开发的过程。因此她经历了3次重构，并且每次几乎都是推倒重来式的。 -v15.wav;
WebGAL 的脚本语言是为了简化制作难度而全新设计的！ -v16.wav;

;结束分支
label:end;
为了更接近桌面端视觉小说引擎的能力，我们支持很多快捷键以及可跳转的剧情回溯。 -v17.wav;
按下菜单中的“回想”按钮或者向上滚动鼠标滚轮试试吧！ -v18.wav;
快速存读挡、丰富的选项、自动播放以及快进等功能，也是应有尽有。 -v19.wav;
setTempAnimation:[{"position": {"x": 500,"y": 0},"duration": 0},{"position": {"x": 400,"y": 0},"duration": 250},{"position": {"x": 600,"y": 0},"duration": 500},{"position": {"x": 500,"y": 0},"duration": 250}] -target=fig-left -next;
当然，这不算什么，因为大多数成熟的引擎都有这些功能。但是在 Web 端，这却是很少见的。 -v20.wav;
我们为可能初次开发游戏的开发者提供了美观的通用 UI 和丰富的预设功能与动画。所以你可以没有顾虑地快速开始制作游戏。 -v21.wav;
WebGAL 项目组期待你的作品能够在 WebGAL 上呈现！只需要一个链接就可以让万千用户立刻开始享受你的作品。 -v22.wav;
感谢你关注 WebGAL 项目！ -v23.wav;
end;
; WebGAL 引擎会默认读取 start.txt 作为初始场景，因此请不要删除，并在初始场景内跳转到其他场景
bgm:s_Title.mp3;
unlockBgm:s_Title.mp3 -name=雲を追いかけて;
intro:你好|欢迎来到 WebGAL 的世界;
changeBg:bg.webp -next;
unlockCg:bg.webp -name=良夜; // 解锁CG并赋予名称
changeFigure:stand.webp -left -next;
setAnimation:enter-from-left -target=fig-left -next;
WebGAL:欢迎使用 WebGAL！这是一款全新的网页端视觉小说引擎。 -v1.wav;
changeFigure:stand2.webp -right -next;
WebGAL 是使用 Web 技术开发的引擎，因此在网页端有良好的表现。 -v2.wav;
由于这个特性，如果你将 WebGAL 部署到服务器或网页托管平台上，玩家只需要一串链接就可以开始游玩！ -v3.wav;
setAnimation:move-front-and-back -target=fig-left -next;
听起来是不是非常吸引人？ -v4.wav;
changeFigure:none -right -next;
setAnimation:l2c -target=fig-left -next;
WebGAL 引擎也具有动画系统和特效系统，使用 WebGAL 开发的游戏可以拥有很好的表现效果。 -v5.wav;
pixiInit;
pixiPerform:snow;
比如，这个下起小雪的特效。 -v6.wav;
除此以外，分支选择的功能也必不可少。 -v7.wav;
你可以通过以下两个分支了解 WebGAL 的更多故事。 -v8.wav;
pixiInit;
choose:WebGAL 发展历程:choose1|WebGAL 冷知识:choose2;

;分支1
label:choose1;
WebGAL 的开发初衷是能够让更多人可以更方便地制作属于自己的视觉小说。 -v9.wav;
在一开始，WebGAL 只具备很少的功能，仅仅能支持立绘和背景的显示、语音播放和分支选择。 -v10.wav;
在经历一年的发展后，现在已经是支持了很多优秀的表现效果的引擎了！ -v11.wav;
除此以外，WebGAL 编辑器的加入也使得制作和导出一个游戏更加方便快捷。 -v12.wav;
jumpLabel:end;

;分支2
label:choose2;
这个演示游戏使用的素材是 AI 生成的。 -v13.wav;
WebGAL 项目只用了一年不到就在 GitHub 获得了 1000 星标！ -v14.wav;
WebGAL 的开发历程，是一个在开发中学习开发的过程。因此她经历了3次重构，并且每次几乎都是推倒重来式的。 -v15.wav;
WebGAL 的脚本语言是为了简化制作难度而全新设计的！ -v16.wav;

;结束分支
label:end;
为了更接近桌面端视觉小说引擎的能力，我们支持很多快捷键以及可跳转的剧情回溯。 -v17.wav;
按下菜单中的“回想”按钮或者向上滚动鼠标滚轮试试吧！ -v18.wav;
快速存读挡、丰富的选项、自动播放以及快进等功能，也是应有尽有。 -v19.wav;
setTempAnimation:[{"position": {"x": 500,"y": 0},"duration": 0},{"position": {"x": 400,"y": 0},"duration": 250},{"position": {"x": 600,"y": 0},"duration": 500},{"position": {"x": 500,"y": 0},"duration": 250}] -target=fig-left -next;
当然，这不算什么，因为大多数成熟的引擎都有这些功能。但是在 Web 端，这却是很少见的。 -v20.wav;
我们为可能初次开发游戏的开发者提供了美观的通用 UI 和丰富的预设功能与动画。所以你可以没有顾虑地快速开始制作游戏。 -v21.wav;
WebGAL 项目组期待你的作品能够在 WebGAL 上呈现！只需要一个链接就可以让万千用户立刻开始享受你的作品。 -v22.wav;
感谢你关注 WebGAL 项目！ -v23.wav;
end;
; WebGAL 引擎会默认读取 start.txt 作为初始场景，因此请不要删除，并在初始场景内跳转到其他场景
bgm:s_Title.mp3;
unlockBgm:s_Title.mp3 -name=雲を追いかけて;
intro:你好|欢迎来到 WebGAL 的世界;
changeBg:bg.webp -next;
unlockCg:bg.webp -name=良夜; // 解锁CG并赋予名称
changeFigure:stand.webp -left -next;
setAnimation:enter-from-left -target=fig-left -next;
WebGAL:欢迎使用 WebGAL！这是一款全新的网页端视觉小说引擎。 -v1.wav;
changeFigure:stand2.webp -right -next;
WebGAL 是使用 Web 技术开发的引擎，因此在网页端有良好的表现。 -v2.wav;
由于这个特性，如果你将 WebGAL 部署到服务器或网页托管平台上，玩家只需要一串链接就可以开始游玩！ -v3.wav;
setAnimation:move-front-and-back -target=fig-left -next;
听起来是不是非常吸引人？ -v4.wav;
changeFigure:none -right -next;
setAnimation:l2c -target=fig-left -next;
WebGAL 引擎也具有动画系统和特效系统，使用 WebGAL 开发的游戏可以拥有很好的表现效果。 -v5.wav;
pixiInit;
pixiPerform:snow;
比如，这个下起小雪的特效。 -v6.wav;
除此以外，分支选择的功能也必不可少。 -v7.wav;
你可以通过以下两个分支了解 WebGAL 的更多故事。 -v8.wav;
pixiInit;
choose:WebGAL 发展历程:choose1|WebGAL 冷知识:choose2;

;分支1
label:choose1;
WebGAL 的开发初衷是能够让更多人可以更方便地制作属于自己的视觉小说。 -v9.wav;
在一开始，WebGAL 只具备很少的功能，仅仅能支持立绘和背景的显示、语音播放和分支选择。 -v10.wav;
在经历一年的发展后，现在已经是支持了很多优秀的表现效果的引擎了！ -v11.wav;
除此以外，WebGAL 编辑器的加入也使得制作和导出一个游戏更加方便快捷。 -v12.wav;
jumpLabel:end;

;分支2
label:choose2;
这个演示游戏使用的素材是 AI 生成的。 -v13.wav;
WebGAL 项目只用了一年不到就在 GitHub 获得了 1000 星标！ -v14.wav;
WebGAL 的开发历程，是一个在开发中学习开发的过程。因此她经历了3次重构，并且每次几乎都是推倒重来式的。 -v15.wav;
WebGAL 的脚本语言是为了简化制作难度而全新设计的！ -v16.wav;

;结束分支
label:end;
为了更接近桌面端视觉小说引擎的能力，我们支持很多快捷键以及可跳转的剧情回溯。 -v17.wav;
按下菜单中的“回想”按钮或者向上滚动鼠标滚轮试试吧！ -v18.wav;
快速存读挡、丰富的选项、自动播放以及快进等功能，也是应有尽有。 -v19.wav;
setTempAnimation:[{"position": {"x": 500,"y": 0},"duration": 0},{"position": {"x": 400,"y": 0},"duration": 250},{"position": {"x": 600,"y": 0},"duration": 500},{"position": {"x": 500,"y": 0},"duration": 250}] -target=fig-left -next;
当然，这不算什么，因为大多数成熟的引擎都有这些功能。但是在 Web 端，这却是很少见的。 -v20.wav;
我们为可能初次开发游戏的开发者提供了美观的通用 UI 和丰富的预设功能与动画。所以你可以没有顾虑地快速开始制作游戏。 -v21.wav;
WebGAL 项目组期待你的作品能够在 WebGAL 上呈现！只需要一个链接就可以让万千用户立刻开始享受你的作品。 -v22.wav;
感谢你关注 WebGAL 项目！ -v23.wav;
end;
; WebGAL 引擎会默认读取 start.txt 作为初始场景，因此请不要删除，并在初始场景内跳转到其他场景
bgm:s_Title.mp3;
unlockBgm:s_Title.mp3 -name=雲を追いかけて;
intro:你好|欢迎来到 WebGAL 的世界;
changeBg:bg.webp -next;
unlockCg:bg.webp -name=良夜; // 解锁CG并赋予名称
changeFigure:stand.webp -left -next;
setAnimation:enter-from-left -target=fig-left -next;
WebGAL:欢迎使用 WebGAL！这是一款全新的网页端视觉小说引擎。 -v1.wav;
changeFigure:stand2.webp -right -next;
WebGAL 是使用 Web 技术开发的引擎，因此在网页端有良好的表现。 -v2.wav;
由于这个特性，如果你将 WebGAL 部署到服务器或网页托管平台上，玩家只需要一串链接就可以开始游玩！ -v3.wav;
setAnimation:move-front-and-back -target=fig-left -next;
听起来是不是非常吸引人？ -v4.wav;
changeFigure:none -right -next;
setAnimation:l2c -target=fig-left -next;
WebGAL 引擎也具有动画系统和特效系统，使用 WebGAL 开发的游戏可以拥有很好的表现效果。 -v5.wav;
pixiInit;
pixiPerform:snow;
比如，这个下起小雪的特效。 -v6.wav;
除此以外，分支选择的功能也必不可少。 -v7.wav;
你可以通过以下两个分支了解 WebGAL 的更多故事。 -v8.wav;
pixiInit;
choose:WebGAL 发展历程:choose1|WebGAL 冷知识:choose2;

;分支1
label:choose1;
WebGAL 的开发初衷是能够让更多人可以更方便地制作属于自己的视觉小说。 -v9.wav;
在一开始，WebGAL 只具备很少的功能，仅仅能支持立绘和背景的显示、语音播放和分支选择。 -v10.wav;
在经历一年的发展后，现在已经是支持了很多优秀的表现效果的引擎了！ -v11.wav;
除此以外，WebGAL 编辑器的加入也使得制作和导出一个游戏更加方便快捷。 -v12.wav;
jumpLabel:end;

;分支2
label:choose2;
这个演示游戏使用的素材是 AI 生成的。 -v13.wav;
WebGAL 项目只用了一年不到就在 GitHub 获得了 1000 星标！ -v14.wav;
WebGAL 的开发历程，是一个在开发中学习开发的过程。因此她经历了3次重构，并且每次几乎都是推倒重来式的。 -v15.wav;
WebGAL 的脚本语言是为了简化制作难度而全新设计的！ -v16.wav;

;结束分支
label:end;
为了更接近桌面端视觉小说引擎的能力，我们支持很多快捷键以及可跳转的剧情回溯。 -v17.wav;
按下菜单中的“回想”按钮或者向上滚动鼠标滚轮试试吧！ -v18.wav;
快速存读挡、丰富的选项、自动播放以及快进等功能，也是应有尽有。 -v19.wav;
setTempAnimation:[{"position": {"x": 500,"y": 0},"duration": 0},{"position": {"x": 400,"y": 0},"duration": 250},{"position": {"x": 600,"y": 0},"duration": 500},{"position": {"x": 500,"y": 0},"duration": 250}] -target=fig-left -next;
当然，这不算什么，因为大多数成熟的引擎都有这些功能。但是在 Web 端，这却是很少见的。 -v20.wav;
我们为可能初次开发游戏的开发者提供了美观的通用 UI 和丰富的预设功能与动画。所以你可以没有顾虑地快速开始制作游戏。 -v21.wav;
WebGAL 项目组期待你的作品能够在 WebGAL 上呈现！只需要一个链接就可以让万千用户立刻开始享受你的作品。 -v22.wav;
感谢你关注 WebGAL 项目！ -v23.wav;
end;
; WebGAL 引擎会默认读取 start.txt 作为初始场景，因此请不要删除，并在初始场景内跳转到其他场景
bgm:s_Title.mp3;
unlockBgm:s_Title.mp3 -name=雲を追いかけて;
intro:你好|欢迎来到 WebGAL 的世界;
changeBg:bg.webp -next;
unlockCg:bg.webp -name=良夜; // 解锁CG并赋予名称
changeFigure:stand.webp -left -next;
setAnimation:enter-from-left -target=fig-left -next;
WebGAL:欢迎使用 WebGAL！这是一款全新的网页端视觉小说引擎。 -v1.wav;
changeFigure:stand2.webp -right -next;
WebGAL 是使用 Web 技术开发的引擎，因此在网页端有良好的表现。 -v2.wav;
由于这个特性，如果你将 WebGAL 部署到服务器或网页托管平台上，玩家只需要一串链接就可以开始游玩！ -v3.wav;
setAnimation:move-front-and-back -target=fig-left -next;
听起来是不是非常吸引人？ -v4.wav;
changeFigure:none -right -next;
setAnimation:l2c -target=fig-left -next;
WebGAL 引擎也具有动画系统和特效系统，使用 WebGAL 开发的游戏可以拥有很好的表现效果。 -v5.wav;
pixiInit;
pixiPerform:snow;
比如，这个下起小雪的特效。 -v6.wav;
除此以外，分支选择的功能也必不可少。 -v7.wav;
你可以通过以下两个分支了解 WebGAL 的更多故事。 -v8.wav;
pixiInit;
choose:WebGAL 发展历程:choose1|WebGAL 冷知识:choose2;

;分支1
label:choose1;
WebGAL 的开发初衷是能够让更多人可以更方便地制作属于自己的视觉小说。 -v9.wav;
在一开始，WebGAL 只具备很少的功能，仅仅能支持立绘和背景的显示、语音播放和分支选择。 -v10.wav;
在经历一年的发展后，现在已经是支持了很多优秀的表现效果的引擎了！ -v11.wav;
除此以外，WebGAL 编辑器的加入也使得制作和导出一个游戏更加方便快捷。 -v12.wav;
jumpLabel:end;

;分支2
label:choose2;
这个演示游戏使用的素材是 AI 生成的。 -v13.wav;
WebGAL 项目只用了一年不到就在 GitHub 获得了 1000 星标！ -v14.wav;
WebGAL 的开发历程，是一个在开发中学习开发的过程。因此她经历了3次重构，并且每次几乎都是推倒重来式的。 -v15.wav;
WebGAL 的脚本语言是为了简化制作难度而全新设计的！ -v16.wav;

;结束分支
label:end;
为了更接近桌面端视觉小说引擎的能力，我们支持很多快捷键以及可跳转的剧情回溯。 -v17.wav;
按下菜单中的“回想”按钮或者向上滚动鼠标滚轮试试吧！ -v18.wav;
快速存读挡、丰富的选项、自动播放以及快进等功能，也是应有尽有。 -v19.wav;
setTempAnimation:[{"position": {"x": 500,"y": 0},"duration": 0},{"position": {"x": 400,"y": 0},"duration": 250},{"position": {"x": 600,"y": 0},"duration": 500},{"position": {"x": 500,"y": 0},"duration": 250}] -target=fig-left -next;
当然，这不算什么，因为大多数成熟的引擎都有这些功能。但是在 Web 端，这却是很少见的。 -v20.wav;
我们为可能初次开发游戏的开发者提供了美观的通用 UI 和丰富的预设功能与动画。所以你可以没有顾虑地快速开始制作游戏。 -v21.wav;
WebGAL 项目组期待你的作品能够在 WebGAL 上呈现！只需要一个链接就可以让万千用户立刻开始享受你的作品。 -v22.wav;
感谢你关注 WebGAL 项目！ -v23.wav;
end;
; WebGAL 引擎会默认读取 start.txt 作为初始场景，因此请不要删除，并在初始场景内跳转到其他场景
bgm:s_Title.mp3;
unlockBgm:s_Title.mp3 -name=雲を追いかけて;
intro:你好|欢迎来到 WebGAL 的世界;
changeBg:bg.webp -next;
unlockCg:bg.webp -name=良夜; // 解锁CG并赋予名称
changeFigure:stand.webp -left -next;
setAnimation:enter-from-left -target=fig-left -next;
WebGAL:欢迎使用 WebGAL！这是一款全新的网页端视觉小说引擎。 -v1.wav;
changeFigure:stand2.webp -right -next;
WebGAL 是使用 Web 技术开发的引擎，因此在网页端有良好的表现。 -v2.wav;
由于这个特性，如果你将 WebGAL 部署到服务器或网页托管平台上，玩家只需要一串链接就可以开始游玩！ -v3.wav;
setAnimation:move-front-and-back -target=fig-left -next;
听起来是不是非常吸引人？ -v4.wav;
changeFigure:none -right -next;
setAnimation:l2c -target=fig-left -next;
WebGAL 引擎也具有动画系统和特效系统，使用 WebGAL 开发的游戏可以拥有很好的表现效果。 -v5.wav;
pixiInit;
pixiPerform:snow;
比如，这个下起小雪的特效。 -v6.wav;
除此以外，分支选择的功能也必不可少。 -v7.wav;
你可以通过以下两个分支了解 WebGAL 的更多故事。 -v8.wav;
pixiInit;
choose:WebGAL 发展历程:choose1|WebGAL 冷知识:choose2;

;分支1
label:choose1;
WebGAL 的开发初衷是能够让更多人可以更方便地制作属于自己的视觉小说。 -v9.wav;
在一开始，WebGAL 只具备很少的功能，仅仅能支持立绘和背景的显示、语音播放和分支选择。 -v10.wav;
在经历一年的发展后，现在已经是支持了很多优秀的表现效果的引擎了！ -v11.wav;
除此以外，WebGAL 编辑器的加入也使得制作和导出一个游戏更加方便快捷。 -v12.wav;
jumpLabel:end;

;分支2
label:choose2;
这个演示游戏使用的素材是 AI 生成的。 -v13.wav;
WebGAL 项目只用了一年不到就在 GitHub 获得了 1000 星标！ -v14.wav;
WebGAL 的开发历程，是一个在开发中学习开发的过程。因此她经历了3次重构，并且每次几乎都是推倒重来式的。 -v15.wav;
WebGAL 的脚本语言是为了简化制作难度而全新设计的！ -v16.wav;

;结束分支
label:end;
为了更接近桌面端视觉小说引擎的能力，我们支持很多快捷键以及可跳转的剧情回溯。 -v17.wav;
按下菜单中的“回想”按钮或者向上滚动鼠标滚轮试试吧！ -v18.wav;
快速存读挡、丰富的选项、自动播放以及快进等功能，也是应有尽有。 -v19.wav;
setTempAnimation:[{"position": {"x": 500,"y": 0},"duration": 0},{"position": {"x": 400,"y": 0},"duration": 250},{"position": {"x": 600,"y": 0},"duration": 500},{"position": {"x": 500,"y": 0},"duration": 250}] -target=fig-left -next;
当然，这不算什么，因为大多数成熟的引擎都有这些功能。但是在 Web 端，这却是很少见的。 -v20.wav;
我们为可能初次开发游戏的开发者提供了美观的通用 UI 和丰富的预设功能与动画。所以你可以没有顾虑地快速开始制作游戏。 -v21.wav;
WebGAL 项目组期待你的作品能够在 WebGAL 上呈现！只需要一个链接就可以让万千用户立刻开始享受你的作品。 -v22.wav;
感谢你关注 WebGAL 项目！ -v23.wav;
end;
; WebGAL 引擎会默认读取 start.txt 作为初始场景，因此请不要删除，并在初始场景内跳转到其他场景
bgm:s_Title.mp3;
unlockBgm:s_Title.mp3 -name=雲を追いかけて;
intro:你好|欢迎来到 WebGAL 的世界;
changeBg:bg.webp -next;
unlockCg:bg.webp -name=良夜; // 解锁CG并赋予名称
changeFigure:stand.webp -left -next;
setAnimation:enter-from-left -target=fig-left -next;
WebGAL:欢迎使用 WebGAL！这是一款全新的网页端视觉小说引擎。 -v1.wav;
changeFigure:stand2.webp -right -next;
WebGAL 是使用 Web 技术开发的引擎，因此在网页端有良好的表现。 -v2.wav;
由于这个特性，如果你将 WebGAL 部署到服务器或网页托管平台上，玩家只需要一串链接就可以开始游玩！ -v3.wav;
setAnimation:move-front-and-back -target=fig-left -next;
听起来是不是非常吸引人？ -v4.wav;
changeFigure:none -right -next;
setAnimation:l2c -target=fig-left -next;
WebGAL 引擎也具有动画系统和特效系统，使用 WebGAL 开发的游戏可以拥有很好的表现效果。 -v5.wav;
pixiInit;
pixiPerform:snow;
比如，这个下起小雪的特效。 -v6.wav;
除此以外，分支选择的功能也必不可少。 -v7.wav;
你可以通过以下两个分支了解 WebGAL 的更多故事。 -v8.wav;
pixiInit;
choose:WebGAL 发展历程:choose1|WebGAL 冷知识:choose2;

;分支1
label:choose1;
WebGAL 的开发初衷是能够让更多人可以更方便地制作属于自己的视觉小说。 -v9.wav;
在一开始，WebGAL 只具备很少的功能，仅仅能支持立绘和背景的显示、语音播放和分支选择。 -v10.wav;
在经历一年的发展后，现在已经是支持了很多优秀的表现效果的引擎了！ -v11.wav;
除此以外，WebGAL 编辑器的加入也使得制作和导出一个游戏更加方便快捷。 -v12.wav;
jumpLabel:end;

;分支2
label:choose2;
这个演示游戏使用的素材是 AI 生成的。 -v13.wav;
WebGAL 项目只用了一年不到就在 GitHub 获得了 1000 星标！ -v14.wav;
WebGAL 的开发历程，是一个在开发中学习开发的过程。因此她经历了3次重构，并且每次几乎都是推倒重来式的。 -v15.wav;
WebGAL 的脚本语言是为了简化制作难度而全新设计的！ -v16.wav;

;结束分支
label:end;
为了更接近桌面端视觉小说引擎的能力，我们支持很多快捷键以及可跳转的剧情回溯。 -v17.wav;
按下菜单中的“回想”按钮或者向上滚动鼠标滚轮试试吧！ -v18.wav;
快速存读挡、丰富的选项、自动播放以及快进等功能，也是应有尽有。 -v19.wav;
setTempAnimation:[{"position": {"x": 500,"y": 0},"duration": 0},{"position": {"x": 400,"y": 0},"duration": 250},{"position": {"x": 600,"y": 0},"duration": 500},{"position": {"x": 500,"y": 0},"duration": 250}] -target=fig-left -next;
当然，这不算什么，因为大多数成熟的引擎都有这些功能。但是在 Web 端，这却是很少见的。 -v20.wav;
我们为可能初次开发游戏的开发者提供了美观的通用 UI 和丰富的预设功能与动画。所以你可以没有顾虑地快速开始制作游戏。 -v21.wav;
WebGAL 项目组期待你的作品能够在 WebGAL 上呈现！只需要一个链接就可以让万千用户立刻开始享受你的作品。 -v22.wav;
感谢你关注 WebGAL 项目！ -v23.wav;
end;
; WebGAL 引擎会默认读取 start.txt 作为初始场景，因此请不要删除，并在初始场景内跳转到其他场景
bgm:s_Title.mp3;
unlockBgm:s_Title.mp3 -name=雲を追いかけて;
intro:你好|欢迎来到 WebGAL 的世界;
changeBg:bg.webp -next;
unlockCg:bg.webp -name=良夜; // 解锁CG并赋予名称
changeFigure:stand.webp -left -next;
setAnimation:enter-from-left -target=fig-left -next;
WebGAL:欢迎使用 WebGAL！这是一款全新的网页端视觉小说引擎。 -v1.wav;
changeFigure:stand2.webp -right -next;
WebGAL 是使用 Web 技术开发的引擎，因此在网页端有良好的表现。 -v2.wav;
由于这个特性，如果你将 WebGAL 部署到服务器或网页托管平台上，玩家只需要一串链接就可以开始游玩！ -v3.wav;
setAnimation:move-front-and-back -target=fig-left -next;
听起来是不是非常吸引人？ -v4.wav;
changeFigure:none -right -next;
setAnimation:l2c -target=fig-left -next;
WebGAL 引擎也具有动画系统和特效系统，使用 WebGAL 开发的游戏可以拥有很好的表现效果。 -v5.wav;
pixiInit;
pixiPerform:snow;
比如，这个下起小雪的特效。 -v6.wav;
除此以外，分支选择的功能也必不可少。 -v7.wav;
你可以通过以下两个分支了解 WebGAL 的更多故事。 -v8.wav;
pixiInit;
choose:WebGAL 发展历程:choose1|WebGAL 冷知识:choose2;

;分支1
label:choose1;
WebGAL 的开发初衷是能够让更多人可以更方便地制作属于自己的视觉小说。 -v9.wav;
在一开始，WebGAL 只具备很少的功能，仅仅能支持立绘和背景的显示、语音播放和分支选择。 -v10.wav;
在经历一年的发展后，现在已经是支持了很多优秀的表现效果的引擎了！ -v11.wav;
除此以外，WebGAL 编辑器的加入也使得制作和导出一个游戏更加方便快捷。 -v12.wav;
jumpLabel:end;

;分支2
label:choose2;
这个演示游戏使用的素材是 AI 生成的。 -v13.wav;
WebGAL 项目只用了一年不到就在 GitHub 获得了 1000 星标！ -v14.wav;
WebGAL 的开发历程，是一个在开发中学习开发的过程。因此她经历了3次重构，并且每次几乎都是推倒重来式的。 -v15.wav;
WebGAL 的脚本语言是为了简化制作难度而全新设计的！ -v16.wav;

;结束分支
label:end;
为了更接近桌面端视觉小说引擎的能力，我们支持很多快捷键以及可跳转的剧情回溯。 -v17.wav;
按下菜单中的“回想”按钮或者向上滚动鼠标滚轮试试吧！ -v18.wav;
快速存读挡、丰富的选项、自动播放以及快进等功能，也是应有尽有。 -v19.wav;
setTempAnimation:[{"position": {"x": 500,"y": 0},"duration": 0},{"position": {"x": 400,"y": 0},"duration": 250},{"position": {"x": 600,"y": 0},"duration": 500},{"position": {"x": 500,"y": 0},"duration": 250}] -target=fig-left -next;
当然，这不算什么，因为大多数成熟的引擎都有这些功能。但是在 Web 端，这却是很少见的。 -v20.wav;
我们为可能初次开发游戏的开发者提供了美观的通用 UI 和丰富的预设功能与动画。所以你可以没有顾虑地快速开始制作游戏。 -v21.wav;
WebGAL 项目组期待你的作品能够在 WebGAL 上呈现！只需要一个链接就可以让万千用户立刻开始享受你的作品。 -v22.wav;
感谢你关注 WebGAL 项目！ -v23.wav;
end;
; WebGAL 引擎会默认读取 start.txt 作为初始场景，因此请不要删除，并在初始场景内跳转到其他场景
bgm:s_Title.mp3;
unlockBgm:s_Title.mp3 -name=雲を追いかけて;
intro:你好|欢迎来到 WebGAL 的世界;
changeBg:bg.webp -next;
unlockCg:bg.webp -name=良夜; // 解锁CG并赋予名称
changeFigure:stand.webp -left -next;
setAnimation:enter-from-left -target=fig-left -next;
WebGAL:欢迎使用 WebGAL！这是一款全新的网页端视觉小说引擎。 -v1.wav;
changeFigure:stand2.webp -right -next;
WebGAL 是使用 Web 技术开发的引擎，因此在网页端有良好的表现。 -v2.wav;
由于这个特性，如果你将 WebGAL 部署到服务器或网页托管平台上，玩家只需要一串链接就可以开始游玩！ -v3.wav;
setAnimation:move-front-and-back -target=fig-left -next;
听起来是不是非常吸引人？ -v4.wav;
changeFigure:none -right -next;
setAnimation:l2c -target=fig-left -next;
WebGAL 引擎也具有动画系统和特效系统，使用 WebGAL 开发的游戏可以拥有很好的表现效果。 -v5.wav;
pixiInit;
pixiPerform:snow;
比如，这个下起小雪的特效。 -v6.wav;
除此以外，分支选择的功能也必不可少。 -v7.wav;
你可以通过以下两个分支了解 WebGAL 的更多故事。 -v8.wav;
pixiInit;
choose:WebGAL 发展历程:choose1|WebGAL 冷知识:choose2;

;分支1
label:choose1;
WebGAL 的开发初衷是能够让更多人可以更方便地制作属于自己的视觉小说。 -v9.wav;
在一开始，WebGAL 只具备很少的功能，仅仅能支持立绘和背景的显示、语音播放和分支选择。 -v10.wav;
在经历一年的发展后，现在已经是支持了很多优秀的表现效果的引擎了！ -v11.wav;
除此以外，WebGAL 编辑器的加入也使得制作和导出一个游戏更加方便快捷。 -v12.wav;
jumpLabel:end;

;分支2
label:choose2;
这个演示游戏使用的素材是 AI 生成的。 -v13.wav;
WebGAL 项目只用了一年不到就在 GitHub 获得了 1000 星标！ -v14.wav;
WebGAL 的开发历程，是一个在开发中学习开发的过程。因此她经历了3次重构，并且每次几乎都是推倒重来式的。 -v15.wav;
WebGAL 的脚本语言是为了简化制作难度而全新设计的！ -v16.wav;

;结束分支
label:end;
为了更接近桌面端视觉小说引擎的能力，我们支持很多快捷键以及可跳转的剧情回溯。 -v17.wav;
按下菜单中的“回想”按钮或者向上滚动鼠标滚轮试试吧！ -v18.wav;
快速存读挡、丰富的选项、自动播放以及快进等功能，也是应有尽有。 -v19.wav;
setTempAnimation:[{"position": {"x": 500,"y": 0},"duration": 0},{"position": {"x": 400,"y": 0},"duration": 250},{"position": {"x": 600,"y": 0},"duration": 500},{"position": {"x": 500,"y": 0},"duration": 250}] -target=fig-left -next;
当然，这不算什么，因为大多数成熟的引擎都有这些功能。但是在 Web 端，这却是很少见的。 -v20.wav;
我们为可能初次开发游戏的开发者提供了美观的通用 UI 和丰富的预设功能与动画。所以你可以没有顾虑地快速开始制作游戏。 -v21.wav;
WebGAL 项目组期待你的作品能够在 WebGAL 上呈现！只需要一个链接就可以让万千用户立刻开始享受你的作品。 -v22.wav;
感谢你关注 WebGAL 项目！ -v23.wav;
end;
; WebGAL 引擎会默认读取 start.txt 作为初始场景，因此请不要删除，并在初始场景内跳转到其他场景
bgm:s_Title.mp3;
unlockBgm:s_Title.mp3 -name=雲を追いかけて;
intro:你好|欢迎来到 WebGAL 的世界;
changeBg:bg.webp -next;
unlockCg:bg.webp -name=良夜; // 解锁CG并赋予名称
changeFigure:stand.webp -left -next;
setAnimation:enter-from-left -target=fig-left -next;
WebGAL:欢迎使用 WebGAL！这是一款全新的网页端视觉小说引擎。 -v1.wav;
changeFigure:stand2.webp -right -next;
WebGAL 是使用 Web 技术开发的引擎，因此在网页端有良好的表现。 -v2.wav;
由于这个特性，如果你将 WebGAL 部署到服务器或网页托管平台上，玩家只需要一串链接就可以开始游玩！ -v3.wav;
setAnimation:move-front-and-back -target=fig-left -next;
听起来是不是非常吸引人？ -v4.wav;
changeFigure:none -right -next;
setAnimation:l2c -target=fig-left -next;
WebGAL 引擎也具有动画系统和特效系统，使用 WebGAL 开发的游戏可以拥有很好的表现效果。 -v5.wav;
pixiInit;
pixiPerform:snow;
比如，这个下起小雪的特效。 -v6.wav;
除此以外，分支选择的功能也必不可少。 -v7.wav;
你可以通过以下两个分支了解 WebGAL 的更多故事。 -v8.wav;
pixiInit;
choose:WebGAL 发展历程:choose1|WebGAL 冷知识:choose2;

;分支1
label:choose1;
WebGAL 的开发初衷是能够让更多人可以更方便地制作属于自己的视觉小说。 -v9.wav;
在一开始，WebGAL 只具备很少的功能，仅仅能支持立绘和背景的显示、语音播放和分支选择。 -v10.wav;
在经历一年的发展后，现在已经是支持了很多优秀的表现效果的引擎了！ -v11.wav;
除此以外，WebGAL 编辑器的加入也使得制作和导出一个游戏更加方便快捷。 -v12.wav;
jumpLabel:end;

;分支2
label:choose2;
这个演示游戏使用的素材是 AI 生成的。 -v13.wav;
WebGAL 项目只用了一年不到就在 GitHub 获得了 1000 星标！ -v14.wav;
WebGAL 的开发历程，是一个在开发中学习开发的过程。因此她经历了3次重构，并且每次几乎都是推倒重来式的。 -v15.wav;
WebGAL 的脚本语言是为了简化制作难度而全新设计的！ -v16.wav;

;结束分支
label:end;
为了更接近桌面端视觉小说引擎的能力，我们支持很多快捷键以及可跳转的剧情回溯。 -v17.wav;
按下菜单中的“回想”按钮或者向上滚动鼠标滚轮试试吧！ -v18.wav;
快速存读挡、丰富的选项、自动播放以及快进等功能，也是应有尽有。 -v19.wav;
setTempAnimation:[{"position": {"x": 500,"y": 0},"duration": 0},{"position": {"x": 400,"y": 0},"duration": 250},{"position": {"x": 600,"y": 0},"duration": 500},{"position": {"x": 500,"y": 0},"duration": 250}] -target=fig-left -next;
当然，这不算什么，因为大多数成熟的引擎都有这些功能。但是在 Web 端，这却是很少见的。 -v20.wav;
我们为可能初次开发游戏的开发者提供了美观的通用 UI 和丰富的预设功能与动画。所以你可以没有顾虑地快速开始制作游戏。 -v21.wav;
WebGAL 项目组期待你的作品能够在 WebGAL 上呈现！只需要一个链接就可以让万千用户立刻开始享受你的作品。 -v22.wav;
感谢你关注 WebGAL 项目！ -v23.wav;
end;
; WebGAL 引擎会默认读取 start.txt 作为初始场景，因此请不要删除，并在初始场景内跳转到其他场景
bgm:s_Title.mp3;
unlockBgm:s_Title.mp3 -name=雲を追いかけて;
intro:你好|欢迎来到 WebGAL 的世界;
changeBg:bg.webp -next;
unlockCg:bg.webp -name=良夜; // 解锁CG并赋予名称
changeFigure:stand.webp -left -next;
setAnimation:enter-from-left -target=fig-left -next;
WebGAL:欢迎使用 WebGAL！这是一款全新的网页端视觉小说引擎。 -v1.wav;
changeFigure:stand2.webp -right -next;
WebGAL 是使用 Web 技术开发的引擎，因此在网页端有良好的表现。 -v2.wav;
由于这个特性，如果你将 WebGAL 部署到服务器或网页托管平台上，玩家只需要一串链接就可以开始游玩！ -v3.wav;
setAnimation:move-front-and-back -target=fig-left -next;
听起来是不是非常吸引人？ -v4.wav;
changeFigure:none -right -next;
setAnimation:l2c -target=fig-left -next;
WebGAL 引擎也具有动画系统和特效系统，使用 WebGAL 开发的游戏可以拥有很好的表现效果。 -v5.wav;
pixiInit;
pixiPerform:snow;
比如，这个下起小雪的特效。 -v6.wav;
除此以外，分支选择的功能也必不可少。 -v7.wav;
你可以通过以下两个分支了解 WebGAL 的更多故事。 -v8.wav;
pixiInit;
choose:WebGAL 发展历程:choose1|WebGAL 冷知识:choose2;

;分支1
label:choose1;
WebGAL 的开发初衷是能够让更多人可以更方便地制作属于自己的视觉小说。 -v9.wav;
在一开始，WebGAL 只具备很少的功能，仅仅能支持立绘和背景的显示、语音播放和分支选择。 -v10.wav;
在经历一年的发展后，现在已经是支持了很多优秀的表现效果的引擎了！ -v11.wav;
除此以外，WebGAL 编辑器的加入也使得制作和导出一个游戏更加方便快捷。 -v12.wav;
jumpLabel:end;

;分支2
label:choose2;
这个演示游戏使用的素材是 AI 生成的。 -v13.wav;
WebGAL 项目只用了一年不到就在 GitHub 获得了 1000 星标！ -v14.wav;
WebGAL 的开发历程，是一个在开发中学习开发的过程。因此她经历了3次重构，并且每次几乎都是推倒重来式的。 -v15.wav;
WebGAL 的脚本语言是为了简化制作难度而全新设计的！ -v16.wav;

;结束分支
label:end;
为了更接近桌面端视觉小说引擎的能力，我们支持很多快捷键以及可跳转的剧情回溯。 -v17.wav;
按下菜单中的“回想”按钮或者向上滚动鼠标滚轮试试吧！ -v18.wav;
快速存读挡、丰富的选项、自动播放以及快进等功能，也是应有尽有。 -v19.wav;
setTempAnimation:[{"position": {"x": 500,"y": 0},"duration": 0},{"position": {"x": 400,"y": 0},"duration": 250},{"position": {"x": 600,"y": 0},"duration": 500},{"position": {"x": 500,"y": 0},"duration": 250}] -target=fig-left -next;
当然，这不算什么，因为大多数成熟的引擎都有这些功能。但是在 Web 端，这却是很少见的。 -v20.wav;
我们为可能初次开发游戏的开发者提供了美观的通用 UI 和丰富的预设功能与动画。所以你可以没有顾虑地快速开始制作游戏。 -v21.wav;
WebGAL 项目组期待你的作品能够在 WebGAL 上呈现！只需要一个链接就可以让万千用户立刻开始享受你的作品。 -v22.wav;
感谢你关注 WebGAL 项目！ -v23.wav;
end;
; WebGAL 引擎会默认读取 start.txt 作为初始场景，因此请不要删除，并在初始场景内跳转到其他场景
bgm:s_Title.mp3;
unlockBgm:s_Title.mp3 -name=雲を追いかけて;
intro:你好|欢迎来到 WebGAL 的世界;
changeBg:bg.webp -next;
unlockCg:bg.webp -name=良夜; // 解锁CG并赋予名称
changeFigure:stand.webp -left -next;
setAnimation:enter-from-left -target=fig-left -next;
WebGAL:欢迎使用 WebGAL！这是一款全新的网页端视觉小说引擎。 -v1.wav;
changeFigure:stand2.webp -right -next;
WebGAL 是使用 Web 技术开发的引擎，因此在网页端有良好的表现。 -v2.wav;
由于这个特性，如果你将 WebGAL 部署到服务器或网页托管平台上，玩家只需要一串链接就可以开始游玩！ -v3.wav;
setAnimation:move-front-and-back -target=fig-left -next;
听起来是不是非常吸引人？ -v4.wav;
changeFigure:none -right -next;
setAnimation:l2c -target=fig-left -next;
WebGAL 引擎也具有动画系统和特效系统，使用 WebGAL 开发的游戏可以拥有很好的表现效果。 -v5.wav;
pixiInit;
pixiPerform:snow;
比如，这个下起小雪的特效。 -v6.wav;
除此以外，分支选择的功能也必不可少。 -v7.wav;
你可以通过以下两个分支了解 WebGAL 的更多故事。 -v8.wav;
pixiInit;
choose:WebGAL 发展历程:choose1|WebGAL 冷知识:choose2;

;分支1
label:choose1;
WebGAL 的开发初衷是能够让更多人可以更方便地制作属于自己的视觉小说。 -v9.wav;
在一开始，WebGAL 只具备很少的功能，仅仅能支持立绘和背景的显示、语音播放和分支选择。 -v10.wav;
在经历一年的发展后，现在已经是支持了很多优秀的表现效果的引擎了！ -v11.wav;
除此以外，WebGAL 编辑器的加入也使得制作和导出一个游戏更加方便快捷。 -v12.wav;
jumpLabel:end;

;分支2
label:choose2;
这个演示游戏使用的素材是 AI 生成的。 -v13.wav;
WebGAL 项目只用了一年不到就在 GitHub 获得了 1000 星标！ -v14.wav;
WebGAL 的开发历程，是一个在开发中学习开发的过程。因此她经历了3次重构，并且每次几乎都是推倒重来式的。 -v15.wav;
WebGAL 的脚本语言是为了简化制作难度而全新设计的！ -v16.wav;

;结束分支
label:end;
为了更接近桌面端视觉小说引擎的能力，我们支持很多快捷键以及可跳转的剧情回溯。 -v17.wav;
按下菜单中的“回想”按钮或者向上滚动鼠标滚轮试试吧！ -v18.wav;
快速存读挡、丰富的选项、自动播放以及快进等功能，也是应有尽有。 -v19.wav;
setTempAnimation:[{"position": {"x": 500,"y": 0},"duration": 0},{"position": {"x": 400,"y": 0},"duration": 250},{"position": {"x": 600,"y": 0},"duration": 500},{"position": {"x": 500,"y": 0},"duration": 250}] -target=fig-left -next;
当然，这不算什么，因为大多数成熟的引擎都有这些功能。但是在 Web 端，这却是很少见的。 -v20.wav;
我们为可能初次开发游戏的开发者提供了美观的通用 UI 和丰富的预设功能与动画。所以你可以没有顾虑地快速开始制作游戏。 -v21.wav;
WebGAL 项目组期待你的作品能够在 WebGAL 上呈现！只需要一个链接就可以让万千用户立刻开始享受你的作品。 -v22.wav;
感谢你关注 WebGAL 项目！ -v23.wav;
end;
; WebGAL 引擎会默认读取 start.txt 作为初始场景，因此请不要删除，并在初始场景内跳转到其他场景
bgm:s_Title.mp3;
unlockBgm:s_Title.mp3 -name=雲を追いかけて;
intro:你好|欢迎来到 WebGAL 的世界;
changeBg:bg.webp -next;
unlockCg:bg.webp -name=良夜; // 解锁CG并赋予名称
changeFigure:stand.webp -left -next;
setAnimation:enter-from-left -target=fig-left -next;
WebGAL:欢迎使用 WebGAL！这是一款全新的网页端视觉小说引擎。 -v1.wav;
changeFigure:stand2.webp -right -next;
WebGAL 是使用 Web 技术开发的引擎，因此在网页端有良好的表现。 -v2.wav;
由于这个特性，如果你将 WebGAL 部署到服务器或网页托管平台上，玩家只需要一串链接就可以开始游玩！ -v3.wav;
setAnimation:move-front-and-back -target=fig-left -next;
听起来是不是非常吸引人？ -v4.wav;
changeFigure:none -right -next;
setAnimation:l2c -target=fig-left -next;
WebGAL 引擎也具有动画系统和特效系统，使用 WebGAL 开发的游戏可以拥有很好的表现效果。 -v5.wav;
pixiInit;
pixiPerform:snow;
比如，这个下起小雪的特效。 -v6.wav;
除此以外，分支选择的功能也必不可少。 -v7.wav;
你可以通过以下两个分支了解 WebGAL 的更多故事。 -v8.wav;
pixiInit;
choose:WebGAL 发展历程:choose1|WebGAL 冷知识:choose2;

;分支1
label:choose1;
WebGAL 的开发初衷是能够让更多人可以更方便地制作属于自己的视觉小说。 -v9.wav;
在一开始，WebGAL 只具备很少的功能，仅仅能支持立绘和背景的显示、语音播放和分支选择。 -v10.wav;
在经历一年的发展后，现在已经是支持了很多优秀的表现效果的引擎了！ -v11.wav;
除此以外，WebGAL 编辑器的加入也使得制作和导出一个游戏更加方便快捷。 -v12.wav;
jumpLabel:end;

;分支2
label:choose2;
这个演示游戏使用的素材是 AI 生成的。 -v13.wav;
WebGAL 项目只用了一年不到就在 GitHub 获得了 1000 星标！ -v14.wav;
WebGAL 的开发历程，是一个在开发中学习开发的过程。因此她经历了3次重构，并且每次几乎都是推倒重来式的。 -v15.wav;
WebGAL 的脚本语言是为了简化制作难度而全新设计的！ -v16.wav;

;结束分支
label:end;
为了更接近桌面端视觉小说引擎的能力，我们支持很多快捷键以及可跳转的剧情回溯。 -v17.wav;
按下菜单中的“回想”按钮或者向上滚动鼠标滚轮试试吧！ -v18.wav;
快速存读挡、丰富的选项、自动播放以及快进等功能，也是应有尽有。 -v19.wav;
setTempAnimation:[{"position": {"x": 500,"y": 0},"duration": 0},{"position": {"x": 400,"y": 0},"duration": 250},{"position": {"x": 600,"y": 0},"duration": 500},{"position": {"x": 500,"y": 0},"duration": 250}] -target=fig-left -next;
当然，这不算什么，因为大多数成熟的引擎都有这些功能。但是在 Web 端，这却是很少见的。 -v20.wav;
我们为可能初次开发游戏的开发者提供了美观的通用 UI 和丰富的预设功能与动画。所以你可以没有顾虑地快速开始制作游戏。 -v21.wav;
WebGAL 项目组期待你的作品能够在 WebGAL 上呈现！只需要一个链接就可以让万千用户立刻开始享受你的作品。 -v22.wav;
感谢你关注 WebGAL 项目！ -v23.wav;
end;
; WebGAL 引擎会默认读取 start.txt 作为初始场景，因此请不要删除，并在初始场景内跳转到其他场景
bgm:s_Title.mp3;
unlockBgm:s_Title.mp3 -name=雲を追いかけて;
intro:你好|欢迎来到 WebGAL 的世界;
changeBg:bg.webp -next;
unlockCg:bg.webp -name=良夜; // 解锁CG并赋予名称
changeFigure:stand.webp -left -next;
setAnimation:enter-from-left -target=fig-left -next;
WebGAL:欢迎使用 WebGAL！这是一款全新的网页端视觉小说引擎。 -v1.wav;
changeFigure:stand2.webp -right -next;
WebGAL 是使用 Web 技术开发的引擎，因此在网页端有良好的表现。 -v2.wav;
由于这个特性，如果你将 WebGAL 部署到服务器或网页托管平台上，玩家只需要一串链接就可以开始游玩！ -v3.wav;
setAnimation:move-front-and-back -target=fig-left -next;
听起来是不是非常吸引人？ -v4.wav;
changeFigure:none -right -next;
setAnimation:l2c -target=fig-left -next;
WebGAL 引擎也具有动画系统和特效系统，使用 WebGAL 开发的游戏可以拥有很好的表现效果。 -v5.wav;
pixiInit;
pixiPerform:snow;
比如，这个下起小雪的特效。 -v6.wav;
除此以外，分支选择的功能也必不可少。 -v7.wav;
你可以通过以下两个分支了解 WebGAL 的更多故事。 -v8.wav;
pixiInit;
choose:WebGAL 发展历程:choose1|WebGAL 冷知识:choose2;

;分支1
label:choose1;
WebGAL 的开发初衷是能够让更多人可以更方便地制作属于自己的视觉小说。 -v9.wav;
在一开始，WebGAL 只具备很少的功能，仅仅能支持立绘和背景的显示、语音播放和分支选择。 -v10.wav;
在经历一年的发展后，现在已经是支持了很多优秀的表现效果的引擎了！ -v11.wav;
除此以外，WebGAL 编辑器的加入也使得制作和导出一个游戏更加方便快捷。 -v12.wav;
jumpLabel:end;

;分支2
label:choose2;
这个演示游戏使用的素材是 AI 生成的。 -v13.wav;
WebGAL 项目只用了一年不到就在 GitHub 获得了 1000 星标！ -v14.wav;
WebGAL 的开发历程，是一个在开发中学习开发的过程。因此她经历了3次重构，并且每次几乎都是推倒重来式的。 -v15.wav;
WebGAL 的脚本语言是为了简化制作难度而全新设计的！ -v16.wav;

;结束分支
label:end;
为了更接近桌面端视觉小说引擎的能力，我们支持很多快捷键以及可跳转的剧情回溯。 -v17.wav;
按下菜单中的“回想”按钮或者向上滚动鼠标滚轮试试吧！ -v18.wav;
快速存读挡、丰富的选项、自动播放以及快进等功能，也是应有尽有。 -v19.wav;
setTempAnimation:[{"position": {"x": 500,"y": 0},"duration": 0},{"position": {"x": 400,"y": 0},"duration": 250},{"position": {"x": 600,"y": 0},"duration": 500},{"position": {"x": 500,"y": 0},"duration": 250}] -target=fig-left -next;
当然，这不算什么，因为大多数成熟的引擎都有这些功能。但是在 Web 端，这却是很少见的。 -v20.wav;
我们为可能初次开发游戏的开发者提供了美观的通用 UI 和丰富的预设功能与动画。所以你可以没有顾虑地快速开始制作游戏。 -v21.wav;
WebGAL 项目组期待你的作品能够在 WebGAL 上呈现！只需要一个链接就可以让万千用户立刻开始享受你的作品。 -v22.wav;
感谢你关注 WebGAL 项目！ -v23.wav;
end;
; WebGAL 引擎会默认读取 start.txt 作为初始场景，因此请不要删除，并在初始场景内跳转到其他场景
bgm:s_Title.mp3;
unlockBgm:s_Title.mp3 -name=雲を追いかけて;
intro:你好|欢迎来到 WebGAL 的世界;
changeBg:bg.webp -next;
unlockCg:bg.webp -name=良夜; // 解锁CG并赋予名称
changeFigure:stand.webp -left -next;
setAnimation:enter-from-left -target=fig-left -next;
WebGAL:欢迎使用 WebGAL！这是一款全新的网页端视觉小说引擎。 -v1.wav;
changeFigure:stand2.webp -right -next;
WebGAL 是使用 Web 技术开发的引擎，因此在网页端有良好的表现。 -v2.wav;
由于这个特性，如果你将 WebGAL 部署到服务器或网页托管平台上，玩家只需要一串链接就可以开始游玩！ -v3.wav;
setAnimation:move-front-and-back -target=fig-left -next;
听起来是不是非常吸引人？ -v4.wav;
changeFigure:none -right -next;
setAnimation:l2c -target=fig-left -next;
WebGAL 引擎也具有动画系统和特效系统，使用 WebGAL 开发的游戏可以拥有很好的表现效果。 -v5.wav;
pixiInit;
pixiPerform:snow;
比如，这个下起小雪的特效。 -v6.wav;
除此以外，分支选择的功能也必不可少。 -v7.wav;
你可以通过以下两个分支了解 WebGAL 的更多故事。 -v8.wav;
pixiInit;
choose:WebGAL 发展历程:choose1|WebGAL 冷知识:choose2;

;分支1
label:choose1;
WebGAL 的开发初衷是能够让更多人可以更方便地制作属于自己的视觉小说。 -v9.wav;
在一开始，WebGAL 只具备很少的功能，仅仅能支持立绘和背景的显示、语音播放和分支选择。 -v10.wav;
在经历一年的发展后，现在已经是支持了很多优秀的表现效果的引擎了！ -v11.wav;
除此以外，WebGAL 编辑器的加入也使得制作和导出一个游戏更加方便快捷。 -v12.wav;
jumpLabel:end;

;分支2
label:choose2;
这个演示游戏使用的素材是 AI 生成的。 -v13.wav;
WebGAL 项目只用了一年不到就在 GitHub 获得了 1000 星标！ -v14.wav;
WebGAL 的开发历程，是一个在开发中学习开发的过程。因此她经历了3次重构，并且每次几乎都是推倒重来式的。 -v15.wav;
WebGAL 的脚本语言是为了简化制作难度而全新设计的！ -v16.wav;

;结束分支
label:end;
为了更接近桌面端视觉小说引擎的能力，我们支持很多快捷键以及可跳转的剧情回溯。 -v17.wav;
按下菜单中的“回想”按钮或者向上滚动鼠标滚轮试试吧！ -v18.wav;
快速存读挡、丰富的选项、自动播放以及快进等功能，也是应有尽有。 -v19.wav;
setTempAnimation:[{"position": {"x": 500,"y": 0},"duration": 0},{"position": {"x": 400,"y": 0},"duration": 250},{"position": {"x": 600,"y": 0},"duration": 500},{"position": {"x": 500,"y": 0},"duration": 250}] -target=fig-left -next;
当然，这不算什么，因为大多数成熟的引擎都有这些功能。但是在 Web 端，这却是很少见的。 -v20.wav;
我们为可能初次开发游戏的开发者提供了美观的通用 UI 和丰富的预设功能与动画。所以你可以没有顾虑地快速开始制作游戏。 -v21.wav;
WebGAL 项目组期待你的作品能够在 WebGAL 上呈现！只需要一个链接就可以让万千用户立刻开始享受你的作品。 -v22.wav;
感谢你关注 WebGAL 项目！ -v23.wav;
end;
; WebGAL 引擎会默认读取 start.txt 作为初始场景，因此请不要删除，并在初始场景内跳转到其他场景
bgm:s_Title.mp3;
unlockBgm:s_Title.mp3 -name=雲を追いかけて;
intro:你好|欢迎来到 WebGAL 的世界;
changeBg:bg.webp -next;
unlockCg:bg.webp -name=良夜; // 解锁CG并赋予名称
changeFigure:stand.webp -left -next;
setAnimation:enter-from-left -target=fig-left -next;
WebGAL:欢迎使用 WebGAL！这是一款全新的网页端视觉小说引擎。 -v1.wav;
changeFigure:stand2.webp -right -next;
WebGAL 是使用 Web 技术开发的引擎，因此在网页端有良好的表现。 -v2.wav;
由于这个特性，如果你将 WebGAL 部署到服务器或网页托管平台上，玩家只需要一串链接就可以开始游玩！ -v3.wav;
setAnimation:move-front-and-back -target=fig-left -next;
听起来是不是非常吸引人？ -v4.wav;
changeFigure:none -right -next;
setAnimation:l2c -target=fig-left -next;
WebGAL 引擎也具有动画系统和特效系统，使用 WebGAL 开发的游戏可以拥有很好的表现效果。 -v5.wav;
pixiInit;
pixiPerform:snow;
比如，这个下起小雪的特效。 -v6.wav;
除此以外，分支选择的功能也必不可少。 -v7.wav;
你可以通过以下两个分支了解 WebGAL 的更多故事。 -v8.wav;
pixiInit;
choose:WebGAL 发展历程:choose1|WebGAL 冷知识:choose2;

;分支1
label:choose1;
WebGAL 的开发初衷是能够让更多人可以更方便地制作属于自己的视觉小说。 -v9.wav;
在一开始，WebGAL 只具备很少的功能，仅仅能支持立绘和背景的显示、语音播放和分支选择。 -v10.wav;
在经历一年的发展后，现在已经是支持了很多优秀的表现效果的引擎了！ -v11.wav;
除此以外，WebGAL 编辑器的加入也使得制作和导出一个游戏更加方便快捷。 -v12.wav;
jumpLabel:end;

;分支2
label:choose2;
这个演示游戏使用的素材是 AI 生成的。 -v13.wav;
WebGAL 项目只用了一年不到就在 GitHub 获得了 1000 星标！ -v14.wav;
WebGAL 的开发历程，是一个在开发中学习开发的过程。因此她经历了3次重构，并且每次几乎都是推倒重来式的。 -v15.wav;
WebGAL 的脚本语言是为了简化制作难度而全新设计的！ -v16.wav;

;结束分支
label:end;
为了更接近桌面端视觉小说引擎的能力，我们支持很多快捷键以及可跳转的剧情回溯。 -v17.wav;
按下菜单中的“回想”按钮或者向上滚动鼠标滚轮试试吧！ -v18.wav;
快速存读挡、丰富的选项、自动播放以及快进等功能，也是应有尽有。 -v19.wav;
setTempAnimation:[{"position": {"x": 500,"y": 0},"duration": 0},{"position": {"x": 400,"y": 0},"duration": 250},{"position": {"x": 600,"y": 0},"duration": 500},{"position": {"x": 500,"y": 0},"duration": 250}] -target=fig-left -next;
当然，这不算什么，因为大多数成熟的引擎都有这些功能。但是在 Web 端，这却是很少见的。 -v20.wav;
我们为可能初次开发游戏的开发者提供了美观的通用 UI 和丰富的预设功能与动画。所以你可以没有顾虑地快速开始制作游戏。 -v21.wav;
WebGAL 项目组期待你的作品能够在 WebGAL 上呈现！只需要一个链接就可以让万千用户立刻开始享受你的作品。 -v22.wav;
感谢你关注 WebGAL 项目！ -v23.wav;
end;
; WebGAL 引擎会默认读取 start.txt 作为初始场景，因此请不要删除，并在初始场景内跳转到其他场景
bgm:s_Title.mp3;
unlockBgm:s_Title.mp3 -name=雲を追いかけて;
intro:你好|欢迎来到 WebGAL 的世界;
changeBg:bg.webp -next;
unlockCg:bg.webp -name=良夜; // 解锁CG并赋予名称
changeFigure:stand.webp -left -next;
setAnimation:enter-from-left -target=fig-left -next;
WebGAL:欢迎使用 WebGAL！这是一款全新的网页端视觉小说引擎。 -v1.wav;
changeFigure:stand2.webp -right -next;
WebGAL 是使用 Web 技术开发的引擎，因此在网页端有良好的表现。 -v2.wav;
由于这个特性，如果你将 WebGAL 部署到服务器或网页托管平台上，玩家只需要一串链接就可以开始游玩！ -v3.wav;
setAnimation:move-front-and-back -target=fig-left -next;
听起来是不是非常吸引人？ -v4.wav;
changeFigure:none -right -next;
setAnimation:l2c -target=fig-left -next;
WebGAL 引擎也具有动画系统和特效系统，使用 WebGAL 开发的游戏可以拥有很好的表现效果。 -v5.wav;
pixiInit;
pixiPerform:snow;
比如，这个下起小雪的特效。 -v6.wav;
除此以外，分支选择的功能也必不可少。 -v7.wav;
你可以通过以下两个分支了解 WebGAL 的更多故事。 -v8.wav;
pixiInit;
choose:WebGAL 发展历程:choose1|WebGAL 冷知识:choose2;

;分支1
label:choose1;
WebGAL 的开发初衷是能够让更多人可以更方便地制作属于自己的视觉小说。 -v9.wav;
在一开始，WebGAL 只具备很少的功能，仅仅能支持立绘和背景的显示、语音播放和分支选择。 -v10.wav;
在经历一年的发展后，现在已经是支持了很多优秀的表现效果的引擎了！ -v11.wav;
除此以外，WebGAL 编辑器的加入也使得制作和导出一个游戏更加方便快捷。 -v12.wav;
jumpLabel:end;

;分支2
label:choose2;
这个演示游戏使用的素材是 AI 生成的。 -v13.wav;
WebGAL 项目只用了一年不到就在 GitHub 获得了 1000 星标！ -v14.wav;
WebGAL 的开发历程，是一个在开发中学习开发的过程。因此她经历了3次重构，并且每次几乎都是推倒重来式的。 -v15.wav;
WebGAL 的脚本语言是为了简化制作难度而全新设计的！ -v16.wav;

;结束分支
label:end;
为了更接近桌面端视觉小说引擎的能力，我们支持很多快捷键以及可跳转的剧情回溯。 -v17.wav;
按下菜单中的“回想”按钮或者向上滚动鼠标滚轮试试吧！ -v18.wav;
快速存读挡、丰富的选项、自动播放以及快进等功能，也是应有尽有。 -v19.wav;
setTempAnimation:[{"position": {"x": 500,"y": 0},"duration": 0},{"position": {"x": 400,"y": 0},"duration": 250},{"position": {"x": 600,"y": 0},"duration": 500},{"position": {"x": 500,"y": 0},"duration": 250}] -target=fig-left -next;
当然，这不算什么，因为大多数成熟的引擎都有这些功能。但是在 Web 端，这却是很少见的。 -v20.wav;
我们为可能初次开发游戏的开发者提供了美观的通用 UI 和丰富的预设功能与动画。所以你可以没有顾虑地快速开始制作游戏。 -v21.wav;
WebGAL 项目组期待你的作品能够在 WebGAL 上呈现！只需要一个链接就可以让万千用户立刻开始享受你的作品。 -v22.wav;
感谢你关注 WebGAL 项目！ -v23.wav;
end;
; WebGAL 引擎会默认读取 start.txt 作为初始场景，因此请不要删除，并在初始场景内跳转到其他场景
bgm:s_Title.mp3;
unlockBgm:s_Title.mp3 -name=雲を追いかけて;
intro:你好|欢迎来到 WebGAL 的世界;
changeBg:bg.webp -next;
unlockCg:bg.webp -name=良夜; // 解锁CG并赋予名称
changeFigure:stand.webp -left -next;
setAnimation:enter-from-left -target=fig-left -next;
WebGAL:欢迎使用 WebGAL！这是一款全新的网页端视觉小说引擎。 -v1.wav;
changeFigure:stand2.webp -right -next;
WebGAL 是使用 Web 技术开发的引擎，因此在网页端有良好的表现。 -v2.wav;
由于这个特性，如果你将 WebGAL 部署到服务器或网页托管平台上，玩家只需要一串链接就可以开始游玩！ -v3.wav;
setAnimation:move-front-and-back -target=fig-left -next;
听起来是不是非常吸引人？ -v4.wav;
changeFigure:none -right -next;
setAnimation:l2c -target=fig-left -next;
WebGAL 引擎也具有动画系统和特效系统，使用 WebGAL 开发的游戏可以拥有很好的表现效果。 -v5.wav;
pixiInit;
pixiPerform:snow;
比如，这个下起小雪的特效。 -v6.wav;
除此以外，分支选择的功能也必不可少。 -v7.wav;
你可以通过以下两个分支了解 WebGAL 的更多故事。 -v8.wav;
pixiInit;
choose:WebGAL 发展历程:choose1|WebGAL 冷知识:choose2;

;分支1
label:choose1;
WebGAL 的开发初衷是能够让更多人可以更方便地制作属于自己的视觉小说。 -v9.wav;
在一开始，WebGAL 只具备很少的功能，仅仅能支持立绘和背景的显示、语音播放和分支选择。 -v10.wav;
在经历一年的发展后，现在已经是支持了很多优秀的表现效果的引擎了！ -v11.wav;
除此以外，WebGAL 编辑器的加入也使得制作和导出一个游戏更加方便快捷。 -v12.wav;
jumpLabel:end;

;分支2
label:choose2;
这个演示游戏使用的素材是 AI 生成的。 -v13.wav;
WebGAL 项目只用了一年不到就在 GitHub 获得了 1000 星标！ -v14.wav;
WebGAL 的开发历程，是一个在开发中学习开发的过程。因此她经历了3次重构，并且每次几乎都是推倒重来式的。 -v15.wav;
WebGAL 的脚本语言是为了简化制作难度而全新设计的！ -v16.wav;

;结束分支
label:end;
为了更接近桌面端视觉小说引擎的能力，我们支持很多快捷键以及可跳转的剧情回溯。 -v17.wav;
按下菜单中的“回想”按钮或者向上滚动鼠标滚轮试试吧！ -v18.wav;
快速存读挡、丰富的选项、自动播放以及快进等功能，也是应有尽有。 -v19.wav;
setTempAnimation:[{"position": {"x": 500,"y": 0},"duration": 0},{"position": {"x": 400,"y": 0},"duration": 250},{"position": {"x": 600,"y": 0},"duration": 500},{"position": {"x": 500,"y": 0},"duration": 250}] -target=fig-left -next;
当然，这不算什么，因为大多数成熟的引擎都有这些功能。但是在 Web 端，这却是很少见的。 -v20.wav;
我们为可能初次开发游戏的开发者提供了美观的通用 UI 和丰富的预设功能与动画。所以你可以没有顾虑地快速开始制作游戏。 -v21.wav;
WebGAL 项目组期待你的作品能够在 WebGAL 上呈现！只需要一个链接就可以让万千用户立刻开始享受你的作品。 -v22.wav;
感谢你关注 WebGAL 项目！ -v23.wav;
end;
; WebGAL 引擎会默认读取 start.txt 作为初始场景，因此请不要删除，并在初始场景内跳转到其他场景
bgm:s_Title.mp3;
unlockBgm:s_Title.mp3 -name=雲を追いかけて;
intro:你好|欢迎来到 WebGAL 的世界;
changeBg:bg.webp -next;
unlockCg:bg.webp -name=良夜; // 解锁CG并赋予名称
changeFigure:stand.webp -left -next;
setAnimation:enter-from-left -target=fig-left -next;
WebGAL:欢迎使用 WebGAL！这是一款全新的网页端视觉小说引擎。 -v1.wav;
changeFigure:stand2.webp -right -next;
WebGAL 是使用 Web 技术开发的引擎，因此在网页端有良好的表现。 -v2.wav;
由于这个特性，如果你将 WebGAL 部署到服务器或网页托管平台上，玩家只需要一串链接就可以开始游玩！ -v3.wav;
setAnimation:move-front-and-back -target=fig-left -next;
听起来是不是非常吸引人？ -v4.wav;
changeFigure:none -right -next;
setAnimation:l2c -target=fig-left -next;
WebGAL 引擎也具有动画系统和特效系统，使用 WebGAL 开发的游戏可以拥有很好的表现效果。 -v5.wav;
pixiInit;
pixiPerform:snow;
比如，这个下起小雪的特效。 -v6.wav;
除此以外，分支选择的功能也必不可少。 -v7.wav;
你可以通过以下两个分支了解 WebGAL 的更多故事。 -v8.wav;
pixiInit;
choose:WebGAL 发展历程:choose1|WebGAL 冷知识:choose2;

;分支1
label:choose1;
WebGAL 的开发初衷是能够让更多人可以更方便地制作属于自己的视觉小说。 -v9.wav;
在一开始，WebGAL 只具备很少的功能，仅仅能支持立绘和背景的显示、语音播放和分支选择。 -v10.wav;
在经历一年的发展后，现在已经是支持了很多优秀的表现效果的引擎了！ -v11.wav;
除此以外，WebGAL 编辑器的加入也使得制作和导出一个游戏更加方便快捷。 -v12.wav;
jumpLabel:end;

;分支2
label:choose2;
这个演示游戏使用的素材是 AI 生成的。 -v13.wav;
WebGAL 项目只用了一年不到就在 GitHub 获得了 1000 星标！ -v14.wav;
WebGAL 的开发历程，是一个在开发中学习开发的过程。因此她经历了3次重构，并且每次几乎都是推倒重来式的。 -v15.wav;
WebGAL 的脚本语言是为了简化制作难度而全新设计的！ -v16.wav;

;结束分支
label:end;
为了更接近桌面端视觉小说引擎的能力，我们支持很多快捷键以及可跳转的剧情回溯。 -v17.wav;
按下菜单中的“回想”按钮或者向上滚动鼠标滚轮试试吧！ -v18.wav;
快速存读挡、丰富的选项、自动播放以及快进等功能，也是应有尽有。 -v19.wav;
setTempAnimation:[{"position": {"x": 500,"y": 0},"duration": 0},{"position": {"x": 400,"y": 0},"duration": 250},{"position": {"x": 600,"y": 0},"duration": 500},{"position": {"x": 500,"y": 0},"duration": 250}] -target=fig-left -next;
当然，这不算什么，因为大多数成熟的引擎都有这些功能。但是在 Web 端，这却是很少见的。 -v20.wav;
我们为可能初次开发游戏的开发者提供了美观的通用 UI 和丰富的预设功能与动画。所以你可以没有顾虑地快速开始制作游戏。 -v21.wav;
WebGAL 项目组期待你的作品能够在 WebGAL 上呈现！只需要一个链接就可以让万千用户立刻开始享受你的作品。 -v22.wav;
感谢你关注 WebGAL 项目！ -v23.wav;
end;
; WebGAL 引擎会默认读取 start.txt 作为初始场景，因此请不要删除，并在初始场景内跳转到其他场景
bgm:s_Title.mp3;
unlockBgm:s_Title.mp3 -name=雲を追いかけて;
intro:你好|欢迎来到 WebGAL 的世界;
changeBg:bg.webp -next;
unlockCg:bg.webp -name=良夜; // 解锁CG并赋予名称
changeFigure:stand.webp -left -next;
setAnimation:enter-from-left -target=fig-left -next;
WebGAL:欢迎使用 WebGAL！这是一款全新的网页端视觉小说引擎。 -v1.wav;
changeFigure:stand2.webp -right -next;
WebGAL 是使用 Web 技术开发的引擎，因此在网页端有良好的表现。 -v2.wav;
由于这个特性，如果你将 WebGAL 部署到服务器或网页托管平台上，玩家只需要一串链接就可以开始游玩！ -v3.wav;
setAnimation:move-front-and-back -target=fig-left -next;
听起来是不是非常吸引人？ -v4.wav;
changeFigure:none -right -next;
setAnimation:l2c -target=fig-left -next;
WebGAL 引擎也具有动画系统和特效系统，使用 WebGAL 开发的游戏可以拥有很好的表现效果。 -v5.wav;
pixiInit;
pixiPerform:snow;
比如，这个下起小雪的特效。 -v6.wav;
除此以外，分支选择的功能也必不可少。 -v7.wav;
你可以通过以下两个分支了解 WebGAL 的更多故事。 -v8.wav;
pixiInit;
choose:WebGAL 发展历程:choose1|WebGAL 冷知识:choose2;

;分支1
label:choose1;
WebGAL 的开发初衷是能够让更多人可以更方便地制作属于自己的视觉小说。 -v9.wav;
在一开始，WebGAL 只具备很少的功能，仅仅能支持立绘和背景的显示、语音播放和分支选择。 -v10.wav;
在经历一年的发展后，现在已经是支持了很多优秀的表现效果的引擎了！ -v11.wav;
除此以外，WebGAL 编辑器的加入也使得制作和导出一个游戏更加方便快捷。 -v12.wav;
jumpLabel:end;

;分支2
label:choose2;
这个演示游戏使用的素材是 AI 生成的。 -v13.wav;
WebGAL 项目只用了一年不到就在 GitHub 获得了 1000 星标！ -v14.wav;
WebGAL 的开发历程，是一个在开发中学习开发的过程。因此她经历了3次重构，并且每次几乎都是推倒重来式的。 -v15.wav;
WebGAL 的脚本语言是为了简化制作难度而全新设计的！ -v16.wav;

;结束分支
label:end;
为了更接近桌面端视觉小说引擎的能力，我们支持很多快捷键以及可跳转的剧情回溯。 -v17.wav;
按下菜单中的“回想”按钮或者向上滚动鼠标滚轮试试吧！ -v18.wav;
快速存读挡、丰富的选项、自动播放以及快进等功能，也是应有尽有。 -v19.wav;
setTempAnimation:[{"position": {"x": 500,"y": 0},"duration": 0},{"position": {"x": 400,"y": 0},"duration": 250},{"position": {"x": 600,"y": 0},"duration": 500},{"position": {"x": 500,"y": 0},"duration": 250}] -target=fig-left -next;
当然，这不算什么，因为大多数成熟的引擎都有这些功能。但是在 Web 端，这却是很少见的。 -v20.wav;
我们为可能初次开发游戏的开发者提供了美观的通用 UI 和丰富的预设功能与动画。所以你可以没有顾虑地快速开始制作游戏。 -v21.wav;
WebGAL 项目组期待你的作品能够在 WebGAL 上呈现！只需要一个链接就可以让万千用户立刻开始享受你的作品。 -v22.wav;
感谢你关注 WebGAL 项目！ -v23.wav;
end;
; WebGAL 引擎会默认读取 start.txt 作为初始场景，因此请不要删除，并在初始场景内跳转到其他场景
bgm:s_Title.mp3;
unlockBgm:s_Title.mp3 -name=雲を追いかけて;
intro:你好|欢迎来到 WebGAL 的世界;
changeBg:bg.webp -next;
unlockCg:bg.webp -name=良夜; // 解锁CG并赋予名称
changeFigure:stand.webp -left -next;
setAnimation:enter-from-left -target=fig-left -next;
WebGAL:欢迎使用 WebGAL！这是一款全新的网页端视觉小说引擎。 -v1.wav;
changeFigure:stand2.webp -right -next;
WebGAL 是使用 Web 技术开发的引擎，因此在网页端有良好的表现。 -v2.wav;
由于这个特性，如果你将 WebGAL 部署到服务器或网页托管平台上，玩家只需要一串链接就可以开始游玩！ -v3.wav;
setAnimation:move-front-and-back -target=fig-left -next;
听起来是不是非常吸引人？ -v4.wav;
changeFigure:none -right -next;
setAnimation:l2c -target=fig-left -next;
WebGAL 引擎也具有动画系统和特效系统，使用 WebGAL 开发的游戏可以拥有很好的表现效果。 -v5.wav;
pixiInit;
pixiPerform:snow;
比如，这个下起小雪的特效。 -v6.wav;
除此以外，分支选择的功能也必不可少。 -v7.wav;
你可以通过以下两个分支了解 WebGAL 的更多故事。 -v8.wav;
pixiInit;
choose:WebGAL 发展历程:choose1|WebGAL 冷知识:choose2;

;分支1
label:choose1;
WebGAL 的开发初衷是能够让更多人可以更方便地制作属于自己的视觉小说。 -v9.wav;
在一开始，WebGAL 只具备很少的功能，仅仅能支持立绘和背景的显示、语音播放和分支选择。 -v10.wav;
在经历一年的发展后，现在已经是支持了很多优秀的表现效果的引擎了！ -v11.wav;
除此以外，WebGAL 编辑器的加入也使得制作和导出一个游戏更加方便快捷。 -v12.wav;
jumpLabel:end;

;分支2
label:choose2;
这个演示游戏使用的素材是 AI 生成的。 -v13.wav;
WebGAL 项目只用了一年不到就在 GitHub 获得了 1000 星标！ -v14.wav;
WebGAL 的开发历程，是一个在开发中学习开发的过程。因此她经历了3次重构，并且每次几乎都是推倒重来式的。 -v15.wav;
WebGAL 的脚本语言是为了简化制作难度而全新设计的！ -v16.wav;

;结束分支
label:end;
为了更接近桌面端视觉小说引擎的能力，我们支持很多快捷键以及可跳转的剧情回溯。 -v17.wav;
按下菜单中的“回想”按钮或者向上滚动鼠标滚轮试试吧！ -v18.wav;
快速存读挡、丰富的选项、自动播放以及快进等功能，也是应有尽有。 -v19.wav;
setTempAnimation:[{"position": {"x": 500,"y": 0},"duration": 0},{"position": {"x": 400,"y": 0},"duration": 250},{"position": {"x": 600,"y": 0},"duration": 500},{"position": {"x": 500,"y": 0},"duration": 250}] -target=fig-left -next;
当然，这不算什么，因为大多数成熟的引擎都有这些功能。但是在 Web 端，这却是很少见的。 -v20.wav;
我们为可能初次开发游戏的开发者提供了美观的通用 UI 和丰富的预设功能与动画。所以你可以没有顾虑地快速开始制作游戏。 -v21.wav;
WebGAL 项目组期待你的作品能够在 WebGAL 上呈现！只需要一个链接就可以让万千用户立刻开始享受你的作品。 -v22.wav;
感谢你关注 WebGAL 项目！ -v23.wav;
end;
; WebGAL 引擎会默认读取 start.txt 作为初始场景，因此请不要删除，并在初始场景内跳转到其他场景
bgm:s_Title.mp3;
unlockBgm:s_Title.mp3 -name=雲を追いかけて;
intro:你好|欢迎来到 WebGAL 的世界;
changeBg:bg.webp -next;
unlockCg:bg.webp -name=良夜; // 解锁CG并赋予名称
changeFigure:stand.webp -left -next;
setAnimation:enter-from-left -target=fig-left -next;
WebGAL:欢迎使用 WebGAL！这是一款全新的网页端视觉小说引擎。 -v1.wav;
changeFigure:stand2.webp -right -next;
WebGAL 是使用 Web 技术开发的引擎，因此在网页端有良好的表现。 -v2.wav;
由于这个特性，如果你将 WebGAL 部署到服务器或网页托管平台上，玩家只需要一串链接就可以开始游玩！ -v3.wav;
setAnimation:move-front-and-back -target=fig-left -next;
听起来是不是非常吸引人？ -v4.wav;
changeFigure:none -right -next;
setAnimation:l2c -target=fig-left -next;
WebGAL 引擎也具有动画系统和特效系统，使用 WebGAL 开发的游戏可以拥有很好的表现效果。 -v5.wav;
pixiInit;
pixiPerform:snow;
比如，这个下起小雪的特效。 -v6.wav;
除此以外，分支选择的功能也必不可少。 -v7.wav;
你可以通过以下两个分支了解 WebGAL 的更多故事。 -v8.wav;
pixiInit;
choose:WebGAL 发展历程:choose1|WebGAL 冷知识:choose2;

;分支1
label:choose1;
WebGAL 的开发初衷是能够让更多人可以更方便地制作属于自己的视觉小说。 -v9.wav;
在一开始，WebGAL 只具备很少的功能，仅仅能支持立绘和背景的显示、语音播放和分支选择。 -v10.wav;
在经历一年的发展后，现在已经是支持了很多优秀的表现效果的引擎了！ -v11.wav;
除此以外，WebGAL 编辑器的加入也使得制作和导出一个游戏更加方便快捷。 -v12.wav;
jumpLabel:end;

;分支2
label:choose2;
这个演示游戏使用的素材是 AI 生成的。 -v13.wav;
WebGAL 项目只用了一年不到就在 GitHub 获得了 1000 星标！ -v14.wav;
WebGAL 的开发历程，是一个在开发中学习开发的过程。因此她经历了3次重构，并且每次几乎都是推倒重来式的。 -v15.wav;
WebGAL 的脚本语言是为了简化制作难度而全新设计的！ -v16.wav;

;结束分支
label:end;
为了更接近桌面端视觉小说引擎的能力，我们支持很多快捷键以及可跳转的剧情回溯。 -v17.wav;
按下菜单中的“回想”按钮或者向上滚动鼠标滚轮试试吧！ -v18.wav;
快速存读挡、丰富的选项、自动播放以及快进等功能，也是应有尽有。 -v19.wav;
setTempAnimation:[{"position": {"x": 500,"y": 0},"duration": 0},{"position": {"x": 400,"y": 0},"duration": 250},{"position": {"x": 600,"y": 0},"duration": 500},{"position": {"x": 500,"y": 0},"duration": 250}] -target=fig-left -next;
当然，这不算什么，因为大多数成熟的引擎都有这些功能。但是在 Web 端，这却是很少见的。 -v20.wav;
我们为可能初次开发游戏的开发者提供了美观的通用 UI 和丰富的预设功能与动画。所以你可以没有顾虑地快速开始制作游戏。 -v21.wav;
WebGAL 项目组期待你的作品能够在 WebGAL 上呈现！只需要一个链接就可以让万千用户立刻开始享受你的作品。 -v22.wav;
感谢你关注 WebGAL 项目！ -v23.wav;
end;
; WebGAL 引擎会默认读取 start.txt 作为初始场景，因此请不要删除，并在初始场景内跳转到其他场景
bgm:s_Title.mp3;
unlockBgm:s_Title.mp3 -name=雲を追いかけて;
intro:你好|欢迎来到 WebGAL 的世界;
changeBg:bg.webp -next;
unlockCg:bg.webp -name=良夜; // 解锁CG并赋予名称
changeFigure:stand.webp -left -next;
setAnimation:enter-from-left -target=fig-left -next;
WebGAL:欢迎使用 WebGAL！这是一款全新的网页端视觉小说引擎。 -v1.wav;
changeFigure:stand2.webp -right -next;
WebGAL 是使用 Web 技术开发的引擎，因此在网页端有良好的表现。 -v2.wav;
由于这个特性，如果你将 WebGAL 部署到服务器或网页托管平台上，玩家只需要一串链接就可以开始游玩！ -v3.wav;
setAnimation:move-front-and-back -target=fig-left -next;
听起来是不是非常吸引人？ -v4.wav;
changeFigure:none -right -next;
setAnimation:l2c -target=fig-left -next;
WebGAL 引擎也具有动画系统和特效系统，使用 WebGAL 开发的游戏可以拥有很好的表现效果。 -v5.wav;
pixiInit;
pixiPerform:snow;
比如，这个下起小雪的特效。 -v6.wav;
除此以外，分支选择的功能也必不可少。 -v7.wav;
你可以通过以下两个分支了解 WebGAL 的更多故事。 -v8.wav;
pixiInit;
choose:WebGAL 发展历程:choose1|WebGAL 冷知识:choose2;

;分支1
label:choose1;
WebGAL 的开发初衷是能够让更多人可以更方便地制作属于自己的视觉小说。 -v9.wav;
在一开始，WebGAL 只具备很少的功能，仅仅能支持立绘和背景的显示、语音播放和分支选择。 -v10.wav;
在经历一年的发展后，现在已经是支持了很多优秀的表现效果的引擎了！ -v11.wav;
除此以外，WebGAL 编辑器的加入也使得制作和导出一个游戏更加方便快捷。 -v12.wav;
jumpLabel:end;

;分支2
label:choose2;
这个演示游戏使用的素材是 AI 生成的。 -v13.wav;
WebGAL 项目只用了一年不到就在 GitHub 获得了 1000 星标！ -v14.wav;
WebGAL 的开发历程，是一个在开发中学习开发的过程。因此她经历了3次重构，并且每次几乎都是推倒重来式的。 -v15.wav;
WebGAL 的脚本语言是为了简化制作难度而全新设计的！ -v16.wav;

;结束分支
label:end;
为了更接近桌面端视觉小说引擎的能力，我们支持很多快捷键以及可跳转的剧情回溯。 -v17.wav;
按下菜单中的“回想”按钮或者向上滚动鼠标滚轮试试吧！ -v18.wav;
快速存读挡、丰富的选项、自动播放以及快进等功能，也是应有尽有。 -v19.wav;
setTempAnimation:[{"position": {"x": 500,"y": 0},"duration": 0},{"position": {"x": 400,"y": 0},"duration": 250},{"position": {"x": 600,"y": 0},"duration": 500},{"position": {"x": 500,"y": 0},"duration": 250}] -target=fig-left -next;
当然，这不算什么，因为大多数成熟的引擎都有这些功能。但是在 Web 端，这却是很少见的。 -v20.wav;
我们为可能初次开发游戏的开发者提供了美观的通用 UI 和丰富的预设功能与动画。所以你可以没有顾虑地快速开始制作游戏。 -v21.wav;
WebGAL 项目组期待你的作品能够在 WebGAL 上呈现！只需要一个链接就可以让万千用户立刻开始享受你的作品。 -v22.wav;
感谢你关注 WebGAL 项目！ -v23.wav;
end;
; WebGAL 引擎会默认读取 start.txt 作为初始场景，因此请不要删除，并在初始场景内跳转到其他场景
bgm:s_Title.mp3;
unlockBgm:s_Title.mp3 -name=雲を追いかけて;
intro:你好|欢迎来到 WebGAL 的世界;
changeBg:bg.webp -next;
unlockCg:bg.webp -name=良夜; // 解锁CG并赋予名称
changeFigure:stand.webp -left -next;
setAnimation:enter-from-left -target=fig-left -next;
WebGAL:欢迎使用 WebGAL！这是一款全新的网页端视觉小说引擎。 -v1.wav;
changeFigure:stand2.webp -right -next;
WebGAL 是使用 Web 技术开发的引擎，因此在网页端有良好的表现。 -v2.wav;
由于这个特性，如果你将 WebGAL 部署到服务器或网页托管平台上，玩家只需要一串链接就可以开始游玩！ -v3.wav;
setAnimation:move-front-and-back -target=fig-left -next;
听起来是不是非常吸引人？ -v4.wav;
changeFigure:none -right -next;
setAnimation:l2c -target=fig-left -next;
WebGAL 引擎也具有动画系统和特效系统，使用 WebGAL 开发的游戏可以拥有很好的表现效果。 -v5.wav;
pixiInit;
pixiPerform:snow;
比如，这个下起小雪的特效。 -v6.wav;
除此以外，分支选择的功能也必不可少。 -v7.wav;
你可以通过以下两个分支了解 WebGAL 的更多故事。 -v8.wav;
pixiInit;
choose:WebGAL 发展历程:choose1|WebGAL 冷知识:choose2;

;分支1
label:choose1;
WebGAL 的开发初衷是能够让更多人可以更方便地制作属于自己的视觉小说。 -v9.wav;
在一开始，WebGAL 只具备很少的功能，仅仅能支持立绘和背景的显示、语音播放和分支选择。 -v10.wav;
在经历一年的发展后，现在已经是支持了很多优秀的表现效果的引擎了！ -v11.wav;
除此以外，WebGAL 编辑器的加入也使得制作和导出一个游戏更加方便快捷。 -v12.wav;
jumpLabel:end;

;分支2
label:choose2;
这个演示游戏使用的素材是 AI 生成的。 -v13.wav;
WebGAL 项目只用了一年不到就在 GitHub 获得了 1000 星标！ -v14.wav;
WebGAL 的开发历程，是一个在开发中学习开发的过程。因此她经历了3次重构，并且每次几乎都是推倒重来式的。 -v15.wav;
WebGAL 的脚本语言是为了简化制作难度而全新设计的！ -v16.wav;

;结束分支
label:end;
为了更接近桌面端视觉小说引擎的能力，我们支持很多快捷键以及可跳转的剧情回溯。 -v17.wav;
按下菜单中的“回想”按钮或者向上滚动鼠标滚轮试试吧！ -v18.wav;
快速存读挡、丰富的选项、自动播放以及快进等功能，也是应有尽有。 -v19.wav;
setTempAnimation:[{"position": {"x": 500,"y": 0},"duration": 0},{"position": {"x": 400,"y": 0},"duration": 250},{"position": {"x": 600,"y": 0},"duration": 500},{"position": {"x": 500,"y": 0},"duration": 250}] -target=fig-left -next;
当然，这不算什么，因为大多数成熟的引擎都有这些功能。但是在 Web 端，这却是很少见的。 -v20.wav;
我们为可能初次开发游戏的开发者提供了美观的通用 UI 和丰富的预设功能与动画。所以你可以没有顾虑地快速开始制作游戏。 -v21.wav;
WebGAL 项目组期待你的作品能够在 WebGAL 上呈现！只需要一个链接就可以让万千用户立刻开始享受你的作品。 -v22.wav;
感谢你关注 WebGAL 项目！ -v23.wav;
end;
; WebGAL 引擎会默认读取 start.txt 作为初始场景，因此请不要删除，并在初始场景内跳转到其他场景
bgm:s_Title.mp3;
unlockBgm:s_Title.mp3 -name=雲を追いかけて;
intro:你好|欢迎来到 WebGAL 的世界;
changeBg:bg.webp -next;
unlockCg:bg.webp -name=良夜; // 解锁CG并赋予名称
changeFigure:stand.webp -left -next;
setAnimation:enter-from-left -target=fig-left -next;
WebGAL:欢迎使用 WebGAL！这是一款全新的网页端视觉小说引擎。 -v1.wav;
changeFigure:stand2.webp -right -next;
WebGAL 是使用 Web 技术开发的引擎，因此在网页端有良好的表现。 -v2.wav;
由于这个特性，如果你将 WebGAL 部署到服务器或网页托管平台上，玩家只需要一串链接就可以开始游玩！ -v3.wav;
setAnimation:move-front-and-back -target=fig-left -next;
听起来是不是非常吸引人？ -v4.wav;
changeFigure:none -right -next;
setAnimation:l2c -target=fig-left -next;
WebGAL 引擎也具有动画系统和特效系统，使用 WebGAL 开发的游戏可以拥有很好的表现效果。 -v5.wav;
pixiInit;
pixiPerform:snow;
比如，这个下起小雪的特效。 -v6.wav;
除此以外，分支选择的功能也必不可少。 -v7.wav;
你可以通过以下两个分支了解 WebGAL 的更多故事。 -v8.wav;
pixiInit;
choose:WebGAL 发展历程:choose1|WebGAL 冷知识:choose2;

;分支1
label:choose1;
WebGAL 的开发初衷是能够让更多人可以更方便地制作属于自己的视觉小说。 -v9.wav;
在一开始，WebGAL 只具备很少的功能，仅仅能支持立绘和背景的显示、语音播放和分支选择。 -v10.wav;
在经历一年的发展后，现在已经是支持了很多优秀的表现效果的引擎了！ -v11.wav;
除此以外，WebGAL 编辑器的加入也使得制作和导出一个游戏更加方便快捷。 -v12.wav;
jumpLabel:end;

;分支2
label:choose2;
这个演示游戏使用的素材是 AI 生成的。 -v13.wav;
WebGAL 项目只用了一年不到就在 GitHub 获得了 1000 星标！ -v14.wav;
WebGAL 的开发历程，是一个在开发中学习开发的过程。因此她经历了3次重构，并且每次几乎都是推倒重来式的。 -v15.wav;
WebGAL 的脚本语言是为了简化制作难度而全新设计的！ -v16.wav;

;结束分支
label:end;
为了更接近桌面端视觉小说引擎的能力，我们支持很多快捷键以及可跳转的剧情回溯。 -v17.wav;
按下菜单中的“回想”按钮或者向上滚动鼠标滚轮试试吧！ -v18.wav;
快速存读挡、丰富的选项、自动播放以及快进等功能，也是应有尽有。 -v19.wav;
setTempAnimation:[{"position": {"x": 500,"y": 0},"duration": 0},{"position": {"x": 400,"y": 0},"duration": 250},{"position": {"x": 600,"y": 0},"duration": 500},{"position": {"x": 500,"y": 0},"duration": 250}] -target=fig-left -next;
当然，这不算什么，因为大多数成熟的引擎都有这些功能。但是在 Web 端，这却是很少见的。 -v20.wav;
我们为可能初次开发游戏的开发者提供了美观的通用 UI 和丰富的预设功能与动画。所以你可以没有顾虑地快速开始制作游戏。 -v21.wav;
WebGAL 项目组期待你的作品能够在 WebGAL 上呈现！只需要一个链接就可以让万千用户立刻开始享受你的作品。 -v22.wav;
感谢你关注 WebGAL 项目！ -v23.wav;
end;
; WebGAL 引擎会默认读取 start.txt 作为初始场景，因此请不要删除，并在初始场景内跳转到其他场景
bgm:s_Title.mp3;
unlockBgm:s_Title.mp3 -name=雲を追いかけて;
intro:你好|欢迎来到 WebGAL 的世界;
changeBg:bg.webp -next;
unlockCg:bg.webp -name=良夜; // 解锁CG并赋予名称
changeFigure:stand.webp -left -next;
setAnimation:enter-from-left -target=fig-left -next;
WebGAL:欢迎使用 WebGAL！这是一款全新的网页端视觉小说引擎。 -v1.wav;
changeFigure:stand2.webp -right -next;
WebGAL 是使用 Web 技术开发的引擎，因此在网页端有良好的表现。 -v2.wav;
由于这个特性，如果你将 WebGAL 部署到服务器或网页托管平台上，玩家只需要一串链接就可以开始游玩！ -v3.wav;
setAnimation:move-front-and-back -target=fig-left -next;
听起来是不是非常吸引人？ -v4.wav;
changeFigure:none -right -next;
setAnimation:l2c -target=fig-left -next;
WebGAL 引擎也具有动画系统和特效系统，使用 WebGAL 开发的游戏可以拥有很好的表现效果。 -v5.wav;
pixiInit;
pixiPerform:snow;
比如，这个下起小雪的特效。 -v6.wav;
除此以外，分支选择的功能也必不可少。 -v7.wav;
你可以通过以下两个分支了解 WebGAL 的更多故事。 -v8.wav;
pixiInit;
choose:WebGAL 发展历程:choose1|WebGAL 冷知识:choose2;

;分支1
label:choose1;
WebGAL 的开发初衷是能够让更多人可以更方便地制作属于自己的视觉小说。 -v9.wav;
在一开始，WebGAL 只具备很少的功能，仅仅能支持立绘和背景的显示、语音播放和分支选择。 -v10.wav;
在经历一年的发展后，现在已经是支持了很多优秀的表现效果的引擎了！ -v11.wav;
除此以外，WebGAL 编辑器的加入也使得制作和导出一个游戏更加方便快捷。 -v12.wav;
jumpLabel:end;

;分支2
label:choose2;
这个演示游戏使用的素材是 AI 生成的。 -v13.wav;
WebGAL 项目只用了一年不到就在 GitHub 获得了 1000 星标！ -v14.wav;
WebGAL 的开发历程，是一个在开发中学习开发的过程。因此她经历了3次重构，并且每次几乎都是推倒重来式的。 -v15.wav;
WebGAL 的脚本语言是为了简化制作难度而全新设计的！ -v16.wav;

;结束分支
label:end;
为了更接近桌面端视觉小说引擎的能力，我们支持很多快捷键以及可跳转的剧情回溯。 -v17.wav;
按下菜单中的“回想”按钮或者向上滚动鼠标滚轮试试吧！ -v18.wav;
快速存读挡、丰富的选项、自动播放以及快进等功能，也是应有尽有。 -v19.wav;
setTempAnimation:[{"position": {"x": 500,"y": 0},"duration": 0},{"position": {"x": 400,"y": 0},"duration": 250},{"position": {"x": 600,"y": 0},"duration": 500},{"position": {"x": 500,"y": 0},"duration": 250}] -target=fig-left -next;
当然，这不算什么，因为大多数成熟的引擎都有这些功能。但是在 Web 端，这却是很少见的。 -v20.wav;
我们为可能初次开发游戏的开发者提供了美观的通用 UI 和丰富的预设功能与动画。所以你可以没有顾虑地快速开始制作游戏。 -v21.wav;
WebGAL 项目组期待你的作品能够在 WebGAL 上呈现！只需要一个链接就可以让万千用户立刻开始享受你的作品。 -v22.wav;
感谢你关注 WebGAL 项目！ -v23.wav;
end;
; WebGAL 引擎会默认读取 start.txt 作为初始场景，因此请不要删除，并在初始场景内跳转到其他场景
bgm:s_Title.mp3;
unlockBgm:s_Title.mp3 -name=雲を追いかけて;
intro:你好|欢迎来到 WebGAL 的世界;
changeBg:bg.webp -next;
unlockCg:bg.webp -name=良夜; // 解锁CG并赋予名称
changeFigure:stand.webp -left -next;
setAnimation:enter-from-left -target=fig-left -next;
WebGAL:欢迎使用 WebGAL！这是一款全新的网页端视觉小说引擎。 -v1.wav;
changeFigure:stand2.webp -right -next;
WebGAL 是使用 Web 技术开发的引擎，因此在网页端有良好的表现。 -v2.wav;
由于这个特性，如果你将 WebGAL 部署到服务器或网页托管平台上，玩家只需要一串链接就可以开始游玩！ -v3.wav;
setAnimation:move-front-and-back -target=fig-left -next;
听起来是不是非常吸引人？ -v4.wav;
changeFigure:none -right -next;
setAnimation:l2c -target=fig-left -next;
WebGAL 引擎也具有动画系统和特效系统，使用 WebGAL 开发的游戏可以拥有很好的表现效果。 -v5.wav;
pixiInit;
pixiPerform:snow;
比如，这个下起小雪的特效。 -v6.wav;
除此以外，分支选择的功能也必不可少。 -v7.wav;
你可以通过以下两个分支了解 WebGAL 的更多故事。 -v8.wav;
pixiInit;
choose:WebGAL 发展历程:choose1|WebGAL 冷知识:choose2;

;分支1
label:choose1;
WebGAL 的开发初衷是能够让更多人可以更方便地制作属于自己的视觉小说。 -v9.wav;
在一开始，WebGAL 只具备很少的功能，仅仅能支持立绘和背景的显示、语音播放和分支选择。 -v10.wav;
在经历一年的发展后，现在已经是支持了很多优秀的表现效果的引擎了！ -v11.wav;
除此以外，WebGAL 编辑器的加入也使得制作和导出一个游戏更加方便快捷。 -v12.wav;
jumpLabel:end;

;分支2
label:choose2;
这个演示游戏使用的素材是 AI 生成的。 -v13.wav;
WebGAL 项目只用了一年不到就在 GitHub 获得了 1000 星标！ -v14.wav;
WebGAL 的开发历程，是一个在开发中学习开发的过程。因此她经历了3次重构，并且每次几乎都是推倒重来式的。 -v15.wav;
WebGAL 的脚本语言是为了简化制作难度而全新设计的！ -v16.wav;

;结束分支
label:end;
为了更接近桌面端视觉小说引擎的能力，我们支持很多快捷键以及可跳转的剧情回溯。 -v17.wav;
按下菜单中的“回想”按钮或者向上滚动鼠标滚轮试试吧！ -v18.wav;
快速存读挡、丰富的选项、自动播放以及快进等功能，也是应有尽有。 -v19.wav;
setTempAnimation:[{"position": {"x": 500,"y": 0},"duration": 0},{"position": {"x": 400,"y": 0},"duration": 250},{"position": {"x": 600,"y": 0},"duration": 500},{"position": {"x": 500,"y": 0},"duration": 250}] -target=fig-left -next;
当然，这不算什么，因为大多数成熟的引擎都有这些功能。但是在 Web 端，这却是很少见的。 -v20.wav;
我们为可能初次开发游戏的开发者提供了美观的通用 UI 和丰富的预设功能与动画。所以你可以没有顾虑地快速开始制作游戏。 -v21.wav;
WebGAL 项目组期待你的作品能够在 WebGAL 上呈现！只需要一个链接就可以让万千用户立刻开始享受你的作品。 -v22.wav;
感谢你关注 WebGAL 项目！ -v23.wav;
end;
; WebGAL 引擎会默认读取 start.txt 作为初始场景，因此请不要删除，并在初始场景内跳转到其他场景
bgm:s_Title.mp3;
unlockBgm:s_Title.mp3 -name=雲を追いかけて;
intro:你好|欢迎来到 WebGAL 的世界;
changeBg:bg.webp -next;
unlockCg:bg.webp -name=良夜; // 解锁CG并赋予名称
changeFigure:stand.webp -left -next;
setAnimation:enter-from-left -target=fig-left -next;
WebGAL:欢迎使用 WebGAL！这是一款全新的网页端视觉小说引擎。 -v1.wav;
changeFigure:stand2.webp -right -next;
WebGAL 是使用 Web 技术开发的引擎，因此在网页端有良好的表现。 -v2.wav;
由于这个特性，如果你将 WebGAL 部署到服务器或网页托管平台上，玩家只需要一串链接就可以开始游玩！ -v3.wav;
setAnimation:move-front-and-back -target=fig-left -next;
听起来是不是非常吸引人？ -v4.wav;
changeFigure:none -right -next;
setAnimation:l2c -target=fig-left -next;
WebGAL 引擎也具有动画系统和特效系统，使用 WebGAL 开发的游戏可以拥有很好的表现效果。 -v5.wav;
pixiInit;
pixiPerform:snow;
比如，这个下起小雪的特效。 -v6.wav;
除此以外，分支选择的功能也必不可少。 -v7.wav;
你可以通过以下两个分支了解 WebGAL 的更多故事。 -v8.wav;
pixiInit;
choose:WebGAL 发展历程:choose1|WebGAL 冷知识:choose2;

;分支1
label:choose1;
WebGAL 的开发初衷是能够让更多人可以更方便地制作属于自己的视觉小说。 -v9.wav;
在一开始，WebGAL 只具备很少的功能，仅仅能支持立绘和背景的显示、语音播放和分支选择。 -v10.wav;
在经历一年的发展后，现在已经是支持了很多优秀的表现效果的引擎了！ -v11.wav;
除此以外，WebGAL 编辑器的加入也使得制作和导出一个游戏更加方便快捷。 -v12.wav;
jumpLabel:end;

;分支2
label:choose2;
这个演示游戏使用的素材是 AI 生成的。 -v13.wav;
WebGAL 项目只用了一年不到就在 GitHub 获得了 1000 星标！ -v14.wav;
WebGAL 的开发历程，是一个在开发中学习开发的过程。因此她经历了3次重构，并且每次几乎都是推倒重来式的。 -v15.wav;
WebGAL 的脚本语言是为了简化制作难度而全新设计的！ -v16.wav;

;结束分支
label:end;
为了更接近桌面端视觉小说引擎的能力，我们支持很多快捷键以及可跳转的剧情回溯。 -v17.wav;
按下菜单中的“回想”按钮或者向上滚动鼠标滚轮试试吧！ -v18.wav;
快速存读挡、丰富的选项、自动播放以及快进等功能，也是应有尽有。 -v19.wav;
setTempAnimation:[{"position": {"x": 500,"y": 0},"duration": 0},{"position": {"x": 400,"y": 0},"duration": 250},{"position": {"x": 600,"y": 0},"duration": 500},{"position": {"x": 500,"y": 0},"duration": 250}] -target=fig-left -next;
当然，这不算什么，因为大多数成熟的引擎都有这些功能。但是在 Web 端，这却是很少见的。 -v20.wav;
我们为可能初次开发游戏的开发者提供了美观的通用 UI 和丰富的预设功能与动画。所以你可以没有顾虑地快速开始制作游戏。 -v21.wav;
WebGAL 项目组期待你的作品能够在 WebGAL 上呈现！只需要一个链接就可以让万千用户立刻开始享受你的作品。 -v22.wav;
感谢你关注 WebGAL 项目！ -v23.wav;
end;
; WebGAL 引擎会默认读取 start.txt 作为初始场景，因此请不要删除，并在初始场景内跳转到其他场景
bgm:s_Title.mp3;
unlockBgm:s_Title.mp3 -name=雲を追いかけて;
intro:你好|欢迎来到 WebGAL 的世界;
changeBg:bg.webp -next;
unlockCg:bg.webp -name=良夜; // 解锁CG并赋予名称
changeFigure:stand.webp -left -next;
setAnimation:enter-from-left -target=fig-left -next;
WebGAL:欢迎使用 WebGAL！这是一款全新的网页端视觉小说引擎。 -v1.wav;
changeFigure:stand2.webp -right -next;
WebGAL 是使用 Web 技术开发的引擎，因此在网页端有良好的表现。 -v2.wav;
由于这个特性，如果你将 WebGAL 部署到服务器或网页托管平台上，玩家只需要一串链接就可以开始游玩！ -v3.wav;
setAnimation:move-front-and-back -target=fig-left -next;
听起来是不是非常吸引人？ -v4.wav;
changeFigure:none -right -next;
setAnimation:l2c -target=fig-left -next;
WebGAL 引擎也具有动画系统和特效系统，使用 WebGAL 开发的游戏可以拥有很好的表现效果。 -v5.wav;
pixiInit;
pixiPerform:snow;
比如，这个下起小雪的特效。 -v6.wav;
除此以外，分支选择的功能也必不可少。 -v7.wav;
你可以通过以下两个分支了解 WebGAL 的更多故事。 -v8.wav;
pixiInit;
choose:WebGAL 发展历程:choose1|WebGAL 冷知识:choose2;

;分支1
label:choose1;
WebGAL 的开发初衷是能够让更多人可以更方便地制作属于自己的视觉小说。 -v9.wav;
在一开始，WebGAL 只具备很少的功能，仅仅能支持立绘和背景的显示、语音播放和分支选择。 -v10.wav;
在经历一年的发展后，现在已经是支持了很多优秀的表现效果的引擎了！ -v11.wav;
除此以外，WebGAL 编辑器的加入也使得制作和导出一个游戏更加方便快捷。 -v12.wav;
jumpLabel:end;

;分支2
label:choose2;
这个演示游戏使用的素材是 AI 生成的。 -v13.wav;
WebGAL 项目只用了一年不到就在 GitHub 获得了 1000 星标！ -v14.wav;
WebGAL 的开发历程，是一个在开发中学习开发的过程。因此她经历了3次重构，并且每次几乎都是推倒重来式的。 -v15.wav;
WebGAL 的脚本语言是为了简化制作难度而全新设计的！ -v16.wav;

;结束分支
label:end;
为了更接近桌面端视觉小说引擎的能力，我们支持很多快捷键以及可跳转的剧情回溯。 -v17.wav;
按下菜单中的“回想”按钮或者向上滚动鼠标滚轮试试吧！ -v18.wav;
快速存读挡、丰富的选项、自动播放以及快进等功能，也是应有尽有。 -v19.wav;
setTempAnimation:[{"position": {"x": 500,"y": 0},"duration": 0},{"position": {"x": 400,"y": 0},"duration": 250},{"position": {"x": 600,"y": 0},"duration": 500},{"position": {"x": 500,"y": 0},"duration": 250}] -target=fig-left -next;
当然，这不算什么，因为大多数成熟的引擎都有这些功能。但是在 Web 端，这却是很少见的。 -v20.wav;
我们为可能初次开发游戏的开发者提供了美观的通用 UI 和丰富的预设功能与动画。所以你可以没有顾虑地快速开始制作游戏。 -v21.wav;
WebGAL 项目组期待你的作品能够在 WebGAL 上呈现！只需要一个链接就可以让万千用户立刻开始享受你的作品。 -v22.wav;
感谢你关注 WebGAL 项目！ -v23.wav;
end;
; WebGAL 引擎会默认读取 start.txt 作为初始场景，因此请不要删除，并在初始场景内跳转到其他场景
bgm:s_Title.mp3;
unlockBgm:s_Title.mp3 -name=雲を追いかけて;
intro:你好|欢迎来到 WebGAL 的世界;
changeBg:bg.webp -next;
unlockCg:bg.webp -name=良夜; // 解锁CG并赋予名称
changeFigure:stand.webp -left -next;
setAnimation:enter-from-left -target=fig-left -next;
WebGAL:欢迎使用 WebGAL！这是一款全新的网页端视觉小说引擎。 -v1.wav;
changeFigure:stand2.webp -right -next;
WebGAL 是使用 Web 技术开发的引擎，因此在网页端有良好的表现。 -v2.wav;
由于这个特性，如果你将 WebGAL 部署到服务器或网页托管平台上，玩家只需要一串链接就可以开始游玩！ -v3.wav;
setAnimation:move-front-and-back -target=fig-left -next;
听起来是不是非常吸引人？ -v4.wav;
changeFigure:none -right -next;
setAnimation:l2c -target=fig-left -next;
WebGAL 引擎也具有动画系统和特效系统，使用 WebGAL 开发的游戏可以拥有很好的表现效果。 -v5.wav;
pixiInit;
pixiPerform:snow;
比如，这个下起小雪的特效。 -v6.wav;
除此以外，分支选择的功能也必不可少。 -v7.wav;
你可以通过以下两个分支了解 WebGAL 的更多故事。 -v8.wav;
pixiInit;
choose:WebGAL 发展历程:choose1|WebGAL 冷知识:choose2;

;分支1
label:choose1;
WebGAL 的开发初衷是能够让更多人可以更方便地制作属于自己的视觉小说。 -v9.wav;
在一开始，WebGAL 只具备很少的功能，仅仅能支持立绘和背景的显示、语音播放和分支选择。 -v10.wav;
在经历一年的发展后，现在已经是支持了很多优秀的表现效果的引擎了！ -v11.wav;
除此以外，WebGAL 编辑器的加入也使得制作和导出一个游戏更加方便快捷。 -v12.wav;
jumpLabel:end;

;分支2
label:choose2;
这个演示游戏使用的素材是 AI 生成的。 -v13.wav;
WebGAL 项目只用了一年不到就在 GitHub 获得了 1000 星标！ -v14.wav;
WebGAL 的开发历程，是一个在开发中学习开发的过程。因此她经历了3次重构，并且每次几乎都是推倒重来式的。 -v15.wav;
WebGAL 的脚本语言是为了简化制作难度而全新设计的！ -v16.wav;

;结束分支
label:end;
为了更接近桌面端视觉小说引擎的能力，我们支持很多快捷键以及可跳转的剧情回溯。 -v17.wav;
按下菜单中的“回想”按钮或者向上滚动鼠标滚轮试试吧！ -v18.wav;
快速存读挡、丰富的选项、自动播放以及快进等功能，也是应有尽有。 -v19.wav;
setTempAnimation:[{"position": {"x": 500,"y": 0},"duration": 0},{"position": {"x": 400,"y": 0},"duration": 250},{"position": {"x": 600,"y": 0},"duration": 500},{"position": {"x": 500,"y": 0},"duration": 250}] -target=fig-left -next;
当然，这不算什么，因为大多数成熟的引擎都有这些功能。但是在 Web 端，这却是很少见的。 -v20.wav;
我们为可能初次开发游戏的开发者提供了美观的通用 UI 和丰富的预设功能与动画。所以你可以没有顾虑地快速开始制作游戏。 -v21.wav;
WebGAL 项目组期待你的作品能够在 WebGAL 上呈现！只需要一个链接就可以让万千用户立刻开始享受你的作品。 -v22.wav;
感谢你关注 WebGAL 项目！ -v23.wav;
end;
; WebGAL 引擎会默认读取 start.txt 作为初始场景，因此请不要删除，并在初始场景内跳转到其他场景
bgm:s_Title.mp3;
unlockBgm:s_Title.mp3 -name=雲を追いかけて;
intro:你好|欢迎来到 WebGAL 的世界;
changeBg:bg.webp -next;
unlockCg:bg.webp -name=良夜; // 解锁CG并赋予名称
changeFigure:stand.webp -left -next;
setAnimation:enter-from-left -target=fig-left -next;
WebGAL:欢迎使用 WebGAL！这是一款全新的网页端视觉小说引擎。 -v1.wav;
changeFigure:stand2.webp -right -next;
WebGAL 是使用 Web 技术开发的引擎，因此在网页端有良好的表现。 -v2.wav;
由于这个特性，如果你将 WebGAL 部署到服务器或网页托管平台上，玩家只需要一串链接就可以开始游玩！ -v3.wav;
setAnimation:move-front-and-back -target=fig-left -next;
听起来是不是非常吸引人？ -v4.wav;
changeFigure:none -right -next;
setAnimation:l2c -target=fig-left -next;
WebGAL 引擎也具有动画系统和特效系统，使用 WebGAL 开发的游戏可以拥有很好的表现效果。 -v5.wav;
pixiInit;
pixiPerform:snow;
比如，这个下起小雪的特效。 -v6.wav;
除此以外，分支选择的功能也必不可少。 -v7.wav;
你可以通过以下两个分支了解 WebGAL 的更多故事。 -v8.wav;
pixiInit;
choose:WebGAL 发展历程:choose1|WebGAL 冷知识:choose2;

;分支1
label:choose1;
WebGAL 的开发初衷是能够让更多人可以更方便地制作属于自己的视觉小说。 -v9.wav;
在一开始，WebGAL 只具备很少的功能，仅仅能支持立绘和背景的显示、语音播放和分支选择。 -v10.wav;
在经历一年的发展后，现在已经是支持了很多优秀的表现效果的引擎了！ -v11.wav;
除此以外，WebGAL 编辑器的加入也使得制作和导出一个游戏更加方便快捷。 -v12.wav;
jumpLabel:end;

;分支2
label:choose2;
这个演示游戏使用的素材是 AI 生成的。 -v13.wav;
WebGAL 项目只用了一年不到就在 GitHub 获得了 1000 星标！ -v14.wav;
WebGAL 的开发历程，是一个在开发中学习开发的过程。因此她经历了3次重构，并且每次几乎都是推倒重来式的。 -v15.wav;
WebGAL 的脚本语言是为了简化制作难度而全新设计的！ -v16.wav;

;结束分支
label:end;
为了更接近桌面端视觉小说引擎的能力，我们支持很多快捷键以及可跳转的剧情回溯。 -v17.wav;
按下菜单中的“回想”按钮或者向上滚动鼠标滚轮试试吧！ -v18.wav;
快速存读挡、丰富的选项、自动播放以及快进等功能，也是应有尽有。 -v19.wav;
setTempAnimation:[{"position": {"x": 500,"y": 0},"duration": 0},{"position": {"x": 400,"y": 0},"duration": 250},{"position": {"x": 600,"y": 0},"duration": 500},{"position": {"x": 500,"y": 0},"duration": 250}] -target=fig-left -next;
当然，这不算什么，因为大多数成熟的引擎都有这些功能。但是在 Web 端，这却是很少见的。 -v20.wav;
我们为可能初次开发游戏的开发者提供了美观的通用 UI 和丰富的预设功能与动画。所以你可以没有顾虑地快速开始制作游戏。 -v21.wav;
WebGAL 项目组期待你的作品能够在 WebGAL 上呈现！只需要一个链接就可以让万千用户立刻开始享受你的作品。 -v22.wav;
感谢你关注 WebGAL 项目！ -v23.wav;
end;
; WebGAL 引擎会默认读取 start.txt 作为初始场景，因此请不要删除，并在初始场景内跳转到其他场景
bgm:s_Title.mp3;
unlockBgm:s_Title.mp3 -name=雲を追いかけて;
intro:你好|欢迎来到 WebGAL 的世界;
changeBg:bg.webp -next;
unlockCg:bg.webp -name=良夜; // 解锁CG并赋予名称
changeFigure:stand.webp -left -next;
setAnimation:enter-from-left -target=fig-left -next;
WebGAL:欢迎使用 WebGAL！这是一款全新的网页端视觉小说引擎。 -v1.wav;
changeFigure:stand2.webp -right -next;
WebGAL 是使用 Web 技术开发的引擎，因此在网页端有良好的表现。 -v2.wav;
由于这个特性，如果你将 WebGAL 部署到服务器或网页托管平台上，玩家只需要一串链接就可以开始游玩！ -v3.wav;
setAnimation:move-front-and-back -target=fig-left -next;
听起来是不是非常吸引人？ -v4.wav;
changeFigure:none -right -next;
setAnimation:l2c -target=fig-left -next;
WebGAL 引擎也具有动画系统和特效系统，使用 WebGAL 开发的游戏可以拥有很好的表现效果。 -v5.wav;
pixiInit;
pixiPerform:snow;
比如，这个下起小雪的特效。 -v6.wav;
除此以外，分支选择的功能也必不可少。 -v7.wav;
你可以通过以下两个分支了解 WebGAL 的更多故事。 -v8.wav;
pixiInit;
choose:WebGAL 发展历程:choose1|WebGAL 冷知识:choose2;

;分支1
label:choose1;
WebGAL 的开发初衷是能够让更多人可以更方便地制作属于自己的视觉小说。 -v9.wav;
在一开始，WebGAL 只具备很少的功能，仅仅能支持立绘和背景的显示、语音播放和分支选择。 -v10.wav;
在经历一年的发展后，现在已经是支持了很多优秀的表现效果的引擎了！ -v11.wav;
除此以外，WebGAL 编辑器的加入也使得制作和导出一个游戏更加方便快捷。 -v12.wav;
jumpLabel:end;

;分支2
label:choose2;
这个演示游戏使用的素材是 AI 生成的。 -v13.wav;
WebGAL 项目只用了一年不到就在 GitHub 获得了 1000 星标！ -v14.wav;
WebGAL 的开发历程，是一个在开发中学习开发的过程。因此她经历了3次重构，并且每次几乎都是推倒重来式的。 -v15.wav;
WebGAL 的脚本语言是为了简化制作难度而全新设计的！ -v16.wav;

;结束分支
label:end;
为了更接近桌面端视觉小说引擎的能力，我们支持很多快捷键以及可跳转的剧情回溯。 -v17.wav;
按下菜单中的“回想”按钮或者向上滚动鼠标滚轮试试吧！ -v18.wav;
快速存读挡、丰富的选项、自动播放以及快进等功能，也是应有尽有。 -v19.wav;
setTempAnimation:[{"position": {"x": 500,"y": 0},"duration": 0},{"position": {"x": 400,"y": 0},"duration": 250},{"position": {"x": 600,"y": 0},"duration": 500},{"position": {"x": 500,"y": 0},"duration": 250}] -target=fig-left -next;
当然，这不算什么，因为大多数成熟的引擎都有这些功能。但是在 Web 端，这却是很少见的。 -v20.wav;
我们为可能初次开发游戏的开发者提供了美观的通用 UI 和丰富的预设功能与动画。所以你可以没有顾虑地快速开始制作游戏。 -v21.wav;
WebGAL 项目组期待你的作品能够在 WebGAL 上呈现！只需要一个链接就可以让万千用户立刻开始享受你的作品。 -v22.wav;
感谢你关注 WebGAL 项目！ -v23.wav;
end;
; WebGAL 引擎会默认读取 start.txt 作为初始场景，因此请不要删除，并在初始场景内跳转到其他场景
bgm:s_Title.mp3;
unlockBgm:s_Title.mp3 -name=雲を追いかけて;
intro:你好|欢迎来到 WebGAL 的世界;
changeBg:bg.webp -next;
unlockCg:bg.webp -name=良夜; // 解锁CG并赋予名称
changeFigure:stand.webp -left -next;
setAnimation:enter-from-left -target=fig-left -next;
WebGAL:欢迎使用 WebGAL！这是一款全新的网页端视觉小说引擎。 -v1.wav;
changeFigure:stand2.webp -right -next;
WebGAL 是使用 Web 技术开发的引擎，因此在网页端有良好的表现。 -v2.wav;
由于这个特性，如果你将 WebGAL 部署到服务器或网页托管平台上，玩家只需要一串链接就可以开始游玩！ -v3.wav;
setAnimation:move-front-and-back -target=fig-left -next;
听起来是不是非常吸引人？ -v4.wav;
changeFigure:none -right -next;
setAnimation:l2c -target=fig-left -next;
WebGAL 引擎也具有动画系统和特效系统，使用 WebGAL 开发的游戏可以拥有很好的表现效果。 -v5.wav;
pixiInit;
pixiPerform:snow;
比如，这个下起小雪的特效。 -v6.wav;
除此以外，分支选择的功能也必不可少。 -v7.wav;
你可以通过以下两个分支了解 WebGAL 的更多故事。 -v8.wav;
pixiInit;
choose:WebGAL 发展历程:choose1|WebGAL 冷知识:choose2;

;分支1
label:choose1;
WebGAL 的开发初衷是能够让更多人可以更方便地制作属于自己的视觉小说。 -v9.wav;
在一开始，WebGAL 只具备很少的功能，仅仅能支持立绘和背景的显示、语音播放和分支选择。 -v10.wav;
在经历一年的发展后，现在已经是支持了很多优秀的表现效果的引擎了！ -v11.wav;
除此以外，WebGAL 编辑器的加入也使得制作和导出一个游戏更加方便快捷。 -v12.wav;
jumpLabel:end;

;分支2
label:choose2;
这个演示游戏使用的素材是 AI 生成的。 -v13.wav;
WebGAL 项目只用了一年不到就在 GitHub 获得了 1000 星标！ -v14.wav;
WebGAL 的开发历程，是一个在开发中学习开发的过程。因此她经历了3次重构，并且每次几乎都是推倒重来式的。 -v15.wav;
WebGAL 的脚本语言是为了简化制作难度而全新设计的！ -v16.wav;

;结束分支
label:end;
为了更接近桌面端视觉小说引擎的能力，我们支持很多快捷键以及可跳转的剧情回溯。 -v17.wav;
按下菜单中的“回想”按钮或者向上滚动鼠标滚轮试试吧！ -v18.wav;
快速存读挡、丰富的选项、自动播放以及快进等功能，也是应有尽有。 -v19.wav;
setTempAnimation:[{"position": {"x": 500,"y": 0},"duration": 0},{"position": {"x": 400,"y": 0},"duration": 250},{"position": {"x": 600,"y": 0},"duration": 500},{"position": {"x": 500,"y": 0},"duration": 250}] -target=fig-left -next;
当然，这不算什么，因为大多数成熟的引擎都有这些功能。但是在 Web 端，这却是很少见的。 -v20.wav;
我们为可能初次开发游戏的开发者提供了美观的通用 UI 和丰富的预设功能与动画。所以你可以没有顾虑地快速开始制作游戏。 -v21.wav;
WebGAL 项目组期待你的作品能够在 WebGAL 上呈现！只需要一个链接就可以让万千用户立刻开始享受你的作品。 -v22.wav;
感谢你关注 WebGAL 项目！ -v23.wav;
end;
; WebGAL 引擎会默认读取 start.txt 作为初始场景，因此请不要删除，并在初始场景内跳转到其他场景
bgm:s_Title.mp3;
unlockBgm:s_Title.mp3 -name=雲を追いかけて;
intro:你好|欢迎来到 WebGAL 的世界;
changeBg:bg.webp -next;
unlockCg:bg.webp -name=良夜; // 解锁CG并赋予名称
changeFigure:stand.webp -left -next;
setAnimation:enter-from-left -target=fig-left -next;
WebGAL:欢迎使用 WebGAL！这是一款全新的网页端视觉小说引擎。 -v1.wav;
changeFigure:stand2.webp -right -next;
WebGAL 是使用 Web 技术开发的引擎，因此在网页端有良好的表现。 -v2.wav;
由于这个特性，如果你将 WebGAL 部署到服务器或网页托管平台上，玩家只需要一串链接就可以开始游玩！ -v3.wav;
setAnimation:move-front-and-back -target=fig-left -next;
听起来是不是非常吸引人？ -v4.wav;
changeFigure:none -right -next;
setAnimation:l2c -target=fig-left -next;
WebGAL 引擎也具有动画系统和特效系统，使用 WebGAL 开发的游戏可以拥有很好的表现效果。 -v5.wav;
pixiInit;
pixiPerform:snow;
比如，这个下起小雪的特效。 -v6.wav;
除此以外，分支选择的功能也必不可少。 -v7.wav;
你可以通过以下两个分支了解 WebGAL 的更多故事。 -v8.wav;
pixiInit;
choose:WebGAL 发展历程:choose1|WebGAL 冷知识:choose2;

;分支1
label:choose1;
WebGAL 的开发初衷是能够让更多人可以更方便地制作属于自己的视觉小说。 -v9.wav;
在一开始，WebGAL 只具备很少的功能，仅仅能支持立绘和背景的显示、语音播放和分支选择。 -v10.wav;
在经历一年的发展后，现在已经是支持了很多优秀的表现效果的引擎了！ -v11.wav;
除此以外，WebGAL 编辑器的加入也使得制作和导出一个游戏更加方便快捷。 -v12.wav;
jumpLabel:end;

;分支2
label:choose2;
这个演示游戏使用的素材是 AI 生成的。 -v13.wav;
WebGAL 项目只用了一年不到就在 GitHub 获得了 1000 星标！ -v14.wav;
WebGAL 的开发历程，是一个在开发中学习开发的过程。因此她经历了3次重构，并且每次几乎都是推倒重来式的。 -v15.wav;
WebGAL 的脚本语言是为了简化制作难度而全新设计的！ -v16.wav;

;结束分支
label:end;
为了更接近桌面端视觉小说引擎的能力，我们支持很多快捷键以及可跳转的剧情回溯。 -v17.wav;
按下菜单中的“回想”按钮或者向上滚动鼠标滚轮试试吧！ -v18.wav;
快速存读挡、丰富的选项、自动播放以及快进等功能，也是应有尽有。 -v19.wav;
setTempAnimation:[{"position": {"x": 500,"y": 0},"duration": 0},{"position": {"x": 400,"y": 0},"duration": 250},{"position": {"x": 600,"y": 0},"duration": 500},{"position": {"x": 500,"y": 0},"duration": 250}] -target=fig-left -next;
当然，这不算什么，因为大多数成熟的引擎都有这些功能。但是在 Web 端，这却是很少见的。 -v20.wav;
我们为可能初次开发游戏的开发者提供了美观的通用 UI 和丰富的预设功能与动画。所以你可以没有顾虑地快速开始制作游戏。 -v21.wav;
WebGAL 项目组期待你的作品能够在 WebGAL 上呈现！只需要一个链接就可以让万千用户立刻开始享受你的作品。 -v22.wav;
感谢你关注 WebGAL 项目！ -v23.wav;
end;
; WebGAL 引擎会默认读取 start.txt 作为初始场景，因此请不要删除，并在初始场景内跳转到其他场景
bgm:s_Title.mp3;
unlockBgm:s_Title.mp3 -name=雲を追いかけて;
intro:你好|欢迎来到 WebGAL 的世界;
changeBg:bg.webp -next;
unlockCg:bg.webp -name=良夜; // 解锁CG并赋予名称
changeFigure:stand.webp -left -next;
setAnimation:enter-from-left -target=fig-left -next;
WebGAL:欢迎使用 WebGAL！这是一款全新的网页端视觉小说引擎。 -v1.wav;
changeFigure:stand2.webp -right -next;
WebGAL 是使用 Web 技术开发的引擎，因此在网页端有良好的表现。 -v2.wav;
由于这个特性，如果你将 WebGAL 部署到服务器或网页托管平台上，玩家只需要一串链接就可以开始游玩！ -v3.wav;
setAnimation:move-front-and-back -target=fig-left -next;
听起来是不是非常吸引人？ -v4.wav;
changeFigure:none -right -next;
setAnimation:l2c -target=fig-left -next;
WebGAL 引擎也具有动画系统和特效系统，使用 WebGAL 开发的游戏可以拥有很好的表现效果。 -v5.wav;
pixiInit;
pixiPerform:snow;
比如，这个下起小雪的特效。 -v6.wav;
除此以外，分支选择的功能也必不可少。 -v7.wav;
你可以通过以下两个分支了解 WebGAL 的更多故事。 -v8.wav;
pixiInit;
choose:WebGAL 发展历程:choose1|WebGAL 冷知识:choose2;

;分支1
label:choose1;
WebGAL 的开发初衷是能够让更多人可以更方便地制作属于自己的视觉小说。 -v9.wav;
在一开始，WebGAL 只具备很少的功能，仅仅能支持立绘和背景的显示、语音播放和分支选择。 -v10.wav;
在经历一年的发展后，现在已经是支持了很多优秀的表现效果的引擎了！ -v11.wav;
除此以外，WebGAL 编辑器的加入也使得制作和导出一个游戏更加方便快捷。 -v12.wav;
jumpLabel:end;

;分支2
label:choose2;
这个演示游戏使用的素材是 AI 生成的。 -v13.wav;
WebGAL 项目只用了一年不到就在 GitHub 获得了 1000 星标！ -v14.wav;
WebGAL 的开发历程，是一个在开发中学习开发的过程。因此她经历了3次重构，并且每次几乎都是推倒重来式的。 -v15.wav;
WebGAL 的脚本语言是为了简化制作难度而全新设计的！ -v16.wav;

;结束分支
label:end;
为了更接近桌面端视觉小说引擎的能力，我们支持很多快捷键以及可跳转的剧情回溯。 -v17.wav;
按下菜单中的“回想”按钮或者向上滚动鼠标滚轮试试吧！ -v18.wav;
快速存读挡、丰富的选项、自动播放以及快进等功能，也是应有尽有。 -v19.wav;
setTempAnimation:[{"position": {"x": 500,"y": 0},"duration": 0},{"position": {"x": 400,"y": 0},"duration": 250},{"position": {"x": 600,"y": 0},"duration": 500},{"position": {"x": 500,"y": 0},"duration": 250}] -target=fig-left -next;
当然，这不算什么，因为大多数成熟的引擎都有这些功能。但是在 Web 端，这却是很少见的。 -v20.wav;
我们为可能初次开发游戏的开发者提供了美观的通用 UI 和丰富的预设功能与动画。所以你可以没有顾虑地快速开始制作游戏。 -v21.wav;
WebGAL 项目组期待你的作品能够在 WebGAL 上呈现！只需要一个链接就可以让万千用户立刻开始享受你的作品。 -v22.wav;
感谢你关注 WebGAL 项目！ -v23.wav;
end;
; WebGAL 引擎会默认读取 start.txt 作为初始场景，因此请不要删除，并在初始场景内跳转到其他场景
bgm:s_Title.mp3;
unlockBgm:s_Title.mp3 -name=雲を追いかけて;
intro:你好|欢迎来到 WebGAL 的世界;
changeBg:bg.webp -next;
unlockCg:bg.webp -name=良夜; // 解锁CG并赋予名称
changeFigure:stand.webp -left -next;
setAnimation:enter-from-left -target=fig-left -next;
WebGAL:欢迎使用 WebGAL！这是一款全新的网页端视觉小说引擎。 -v1.wav;
changeFigure:stand2.webp -right -next;
WebGAL 是使用 Web 技术开发的引擎，因此在网页端有良好的表现。 -v2.wav;
由于这个特性，如果你将 WebGAL 部署到服务器或网页托管平台上，玩家只需要一串链接就可以开始游玩！ -v3.wav;
setAnimation:move-front-and-back -target=fig-left -next;
听起来是不是非常吸引人？ -v4.wav;
changeFigure:none -right -next;
setAnimation:l2c -target=fig-left -next;
WebGAL 引擎也具有动画系统和特效系统，使用 WebGAL 开发的游戏可以拥有很好的表现效果。 -v5.wav;
pixiInit;
pixiPerform:snow;
比如，这个下起小雪的特效。 -v6.wav;
除此以外，分支选择的功能也必不可少。 -v7.wav;
你可以通过以下两个分支了解 WebGAL 的更多故事。 -v8.wav;
pixiInit;
choose:WebGAL 发展历程:choose1|WebGAL 冷知识:choose2;

;分支1
label:choose1;
WebGAL 的开发初衷是能够让更多人可以更方便地制作属于自己的视觉小说。 -v9.wav;
在一开始，WebGAL 只具备很少的功能，仅仅能支持立绘和背景的显示、语音播放和分支选择。 -v10.wav;
在经历一年的发展后，现在已经是支持了很多优秀的表现效果的引擎了！ -v11.wav;
除此以外，WebGAL 编辑器的加入也使得制作和导出一个游戏更加方便快捷。 -v12.wav;
jumpLabel:end;

;分支2
label:choose2;
这个演示游戏使用的素材是 AI 生成的。 -v13.wav;
WebGAL 项目只用了一年不到就在 GitHub 获得了 1000 星标！ -v14.wav;
WebGAL 的开发历程，是一个在开发中学习开发的过程。因此她经历了3次重构，并且每次几乎都是推倒重来式的。 -v15.wav;
WebGAL 的脚本语言是为了简化制作难度而全新设计的！ -v16.wav;

;结束分支
label:end;
为了更接近桌面端视觉小说引擎的能力，我们支持很多快捷键以及可跳转的剧情回溯。 -v17.wav;
按下菜单中的“回想”按钮或者向上滚动鼠标滚轮试试吧！ -v18.wav;
快速存读挡、丰富的选项、自动播放以及快进等功能，也是应有尽有。 -v19.wav;
setTempAnimation:[{"position": {"x": 500,"y": 0},"duration": 0},{"position": {"x": 400,"y": 0},"duration": 250},{"position": {"x": 600,"y": 0},"duration": 500},{"position": {"x": 500,"y": 0},"duration": 250}] -target=fig-left -next;
当然，这不算什么，因为大多数成熟的引擎都有这些功能。但是在 Web 端，这却是很少见的。 -v20.wav;
我们为可能初次开发游戏的开发者提供了美观的通用 UI 和丰富的预设功能与动画。所以你可以没有顾虑地快速开始制作游戏。 -v21.wav;
WebGAL 项目组期待你的作品能够在 WebGAL 上呈现！只需要一个链接就可以让万千用户立刻开始享受你的作品。 -v22.wav;
感谢你关注 WebGAL 项目！ -v23.wav;
end;
; WebGAL 引擎会默认读取 start.txt 作为初始场景，因此请不要删除，并在初始场景内跳转到其他场景
bgm:s_Title.mp3;
unlockBgm:s_Title.mp3 -name=雲を追いかけて;
intro:你好|欢迎来到 WebGAL 的世界;
changeBg:bg.webp -next;
unlockCg:bg.webp -name=良夜; // 解锁CG并赋予名称
changeFigure:stand.webp -left -next;
setAnimation:enter-from-left -target=fig-left -next;
WebGAL:欢迎使用 WebGAL！这是一款全新的网页端视觉小说引擎。 -v1.wav;
changeFigure:stand2.webp -right -next;
WebGAL 是使用 Web 技术开发的引擎，因此在网页端有良好的表现。 -v2.wav;
由于这个特性，如果你将 WebGAL 部署到服务器或网页托管平台上，玩家只需要一串链接就可以开始游玩！ -v3.wav;
setAnimation:move-front-and-back -target=fig-left -next;
听起来是不是非常吸引人？ -v4.wav;
changeFigure:none -right -next;
setAnimation:l2c -target=fig-left -next;
WebGAL 引擎也具有动画系统和特效系统，使用 WebGAL 开发的游戏可以拥有很好的表现效果。 -v5.wav;
pixiInit;
pixiPerform:snow;
比如，这个下起小雪的特效。 -v6.wav;
除此以外，分支选择的功能也必不可少。 -v7.wav;
你可以通过以下两个分支了解 WebGAL 的更多故事。 -v8.wav;
pixiInit;
choose:WebGAL 发展历程:choose1|WebGAL 冷知识:choose2;

;分支1
label:choose1;
WebGAL 的开发初衷是能够让更多人可以更方便地制作属于自己的视觉小说。 -v9.wav;
在一开始，WebGAL 只具备很少的功能，仅仅能支持立绘和背景的显示、语音播放和分支选择。 -v10.wav;
在经历一年的发展后，现在已经是支持了很多优秀的表现效果的引擎了！ -v11.wav;
除此以外，WebGAL 编辑器的加入也使得制作和导出一个游戏更加方便快捷。 -v12.wav;
jumpLabel:end;

;分支2
label:choose2;
这个演示游戏使用的素材是 AI 生成的。 -v13.wav;
WebGAL 项目只用了一年不到就在 GitHub 获得了 1000 星标！ -v14.wav;
WebGAL 的开发历程，是一个在开发中学习开发的过程。因此她经历了3次重构，并且每次几乎都是推倒重来式的。 -v15.wav;
WebGAL 的脚本语言是为了简化制作难度而全新设计的！ -v16.wav;

;结束分支
label:end;
为了更接近桌面端视觉小说引擎的能力，我们支持很多快捷键以及可跳转的剧情回溯。 -v17.wav;
按下菜单中的“回想”按钮或者向上滚动鼠标滚轮试试吧！ -v18.wav;
快速存读挡、丰富的选项、自动播放以及快进等功能，也是应有尽有。 -v19.wav;
setTempAnimation:[{"position": {"x": 500,"y": 0},"duration": 0},{"position": {"x": 400,"y": 0},"duration": 250},{"position": {"x": 600,"y": 0},"duration": 500},{"position": {"x": 500,"y": 0},"duration": 250}] -target=fig-left -next;
当然，这不算什么，因为大多数成熟的引擎都有这些功能。但是在 Web 端，这却是很少见的。 -v20.wav;
我们为可能初次开发游戏的开发者提供了美观的通用 UI 和丰富的预设功能与动画。所以你可以没有顾虑地快速开始制作游戏。 -v21.wav;
WebGAL 项目组期待你的作品能够在 WebGAL 上呈现！只需要一个链接就可以让万千用户立刻开始享受你的作品。 -v22.wav;
感谢你关注 WebGAL 项目！ -v23.wav;
end;
; WebGAL 引擎会默认读取 start.txt 作为初始场景，因此请不要删除，并在初始场景内跳转到其他场景
bgm:s_Title.mp3;
unlockBgm:s_Title.mp3 -name=雲を追いかけて;
intro:你好|欢迎来到 WebGAL 的世界;
changeBg:bg.webp -next;
unlockCg:bg.webp -name=良夜; // 解锁CG并赋予名称
changeFigure:stand.webp -left -next;
setAnimation:enter-from-left -target=fig-left -next;
WebGAL:欢迎使用 WebGAL！这是一款全新的网页端视觉小说引擎。 -v1.wav;
changeFigure:stand2.webp -right -next;
WebGAL 是使用 Web 技术开发的引擎，因此在网页端有良好的表现。 -v2.wav;
由于这个特性，如果你将 WebGAL 部署到服务器或网页托管平台上，玩家只需要一串链接就可以开始游玩！ -v3.wav;
setAnimation:move-front-and-back -target=fig-left -next;
听起来是不是非常吸引人？ -v4.wav;
changeFigure:none -right -next;
setAnimation:l2c -target=fig-left -next;
WebGAL 引擎也具有动画系统和特效系统，使用 WebGAL 开发的游戏可以拥有很好的表现效果。 -v5.wav;
pixiInit;
pixiPerform:snow;
比如，这个下起小雪的特效。 -v6.wav;
除此以外，分支选择的功能也必不可少。 -v7.wav;
你可以通过以下两个分支了解 WebGAL 的更多故事。 -v8.wav;
pixiInit;
choose:WebGAL 发展历程:choose1|WebGAL 冷知识:choose2;

;分支1
label:choose1;
WebGAL 的开发初衷是能够让更多人可以更方便地制作属于自己的视觉小说。 -v9.wav;
在一开始，WebGAL 只具备很少的功能，仅仅能支持立绘和背景的显示、语音播放和分支选择。 -v10.wav;
在经历一年的发展后，现在已经是支持了很多优秀的表现效果的引擎了！ -v11.wav;
除此以外，WebGAL 编辑器的加入也使得制作和导出一个游戏更加方便快捷。 -v12.wav;
jumpLabel:end;

;分支2
label:choose2;
这个演示游戏使用的素材是 AI 生成的。 -v13.wav;
WebGAL 项目只用了一年不到就在 GitHub 获得了 1000 星标！ -v14.wav;
WebGAL 的开发历程，是一个在开发中学习开发的过程。因此她经历了3次重构，并且每次几乎都是推倒重来式的。 -v15.wav;
WebGAL 的脚本语言是为了简化制作难度而全新设计的！ -v16.wav;

;结束分支
label:end;
为了更接近桌面端视觉小说引擎的能力，我们支持很多快捷键以及可跳转的剧情回溯。 -v17.wav;
按下菜单中的“回想”按钮或者向上滚动鼠标滚轮试试吧！ -v18.wav;
快速存读挡、丰富的选项、自动播放以及快进等功能，也是应有尽有。 -v19.wav;
setTempAnimation:[{"position": {"x": 500,"y": 0},"duration": 0},{"position": {"x": 400,"y": 0},"duration": 250},{"position": {"x": 600,"y": 0},"duration": 500},{"position": {"x": 500,"y": 0},"duration": 250}] -target=fig-left -next;
当然，这不算什么，因为大多数成熟的引擎都有这些功能。但是在 Web 端，这却是很少见的。 -v20.wav;
我们为可能初次开发游戏的开发者提供了美观的通用 UI 和丰富的预设功能与动画。所以你可以没有顾虑地快速开始制作游戏。 -v21.wav;
WebGAL 项目组期待你的作品能够在 WebGAL 上呈现！只需要一个链接就可以让万千用户立刻开始享受你的作品。 -v22.wav;
感谢你关注 WebGAL 项目！ -v23.wav;
end;
; WebGAL 引擎会默认读取 start.txt 作为初始场景，因此请不要删除，并在初始场景内跳转到其他场景
bgm:s_Title.mp3;
unlockBgm:s_Title.mp3 -name=雲を追いかけて;
intro:你好|欢迎来到 WebGAL 的世界;
changeBg:bg.webp -next;
unlockCg:bg.webp -name=良夜; // 解锁CG并赋予名称
changeFigure:stand.webp -left -next;
setAnimation:enter-from-left -target=fig-left -next;
WebGAL:欢迎使用 WebGAL！这是一款全新的网页端视觉小说引擎。 -v1.wav;
changeFigure:stand2.webp -right -next;
WebGAL 是使用 Web 技术开发的引擎，因此在网页端有良好的表现。 -v2.wav;
由于这个特性，如果你将 WebGAL 部署到服务器或网页托管平台上，玩家只需要一串链接就可以开始游玩！ -v3.wav;
setAnimation:move-front-and-back -target=fig-left -next;
听起来是不是非常吸引人？ -v4.wav;
changeFigure:none -right -next;
setAnimation:l2c -target=fig-left -next;
WebGAL 引擎也具有动画系统和特效系统，使用 WebGAL 开发的游戏可以拥有很好的表现效果。 -v5.wav;
pixiInit;
pixiPerform:snow;
比如，这个下起小雪的特效。 -v6.wav;
除此以外，分支选择的功能也必不可少。 -v7.wav;
你可以通过以下两个分支了解 WebGAL 的更多故事。 -v8.wav;
pixiInit;
choose:WebGAL 发展历程:choose1|WebGAL 冷知识:choose2;

;分支1
label:choose1;
WebGAL 的开发初衷是能够让更多人可以更方便地制作属于自己的视觉小说。 -v9.wav;
在一开始，WebGAL 只具备很少的功能，仅仅能支持立绘和背景的显示、语音播放和分支选择。 -v10.wav;
在经历一年的发展后，现在已经是支持了很多优秀的表现效果的引擎了！ -v11.wav;
除此以外，WebGAL 编辑器的加入也使得制作和导出一个游戏更加方便快捷。 -v12.wav;
jumpLabel:end;

;分支2
label:choose2;
这个演示游戏使用的素材是 AI 生成的。 -v13.wav;
WebGAL 项目只用了一年不到就在 GitHub 获得了 1000 星标！ -v14.wav;
WebGAL 的开发历程，是一个在开发中学习开发的过程。因此她经历了3次重构，并且每次几乎都是推倒重来式的。 -v15.wav;
WebGAL 的脚本语言是为了简化制作难度而全新设计的！ -v16.wav;

;结束分支
label:end;
为了更接近桌面端视觉小说引擎的能力，我们支持很多快捷键以及可跳转的剧情回溯。 -v17.wav;
按下菜单中的“回想”按钮或者向上滚动鼠标滚轮试试吧！ -v18.wav;
快速存读挡、丰富的选项、自动播放以及快进等功能，也是应有尽有。 -v19.wav;
setTempAnimation:[{"position": {"x": 500,"y": 0},"duration": 0},{"position": {"x": 400,"y": 0},"duration": 250},{"position": {"x": 600,"y": 0},"duration": 500},{"position": {"x": 500,"y": 0},"duration": 250}] -target=fig-left -next;
当然，这不算什么，因为大多数成熟的引擎都有这些功能。但是在 Web 端，这却是很少见的。 -v20.wav;
我们为可能初次开发游戏的开发者提供了美观的通用 UI 和丰富的预设功能与动画。所以你可以没有顾虑地快速开始制作游戏。 -v21.wav;
WebGAL 项目组期待你的作品能够在 WebGAL 上呈现！只需要一个链接就可以让万千用户立刻开始享受你的作品。 -v22.wav;
感谢你关注 WebGAL 项目！ -v23.wav;
end;
; WebGAL 引擎会默认读取 start.txt 作为初始场景，因此请不要删除，并在初始场景内跳转到其他场景
bgm:s_Title.mp3;
unlockBgm:s_Title.mp3 -name=雲を追いかけて;
intro:你好|欢迎来到 WebGAL 的世界;
changeBg:bg.webp -next;
unlockCg:bg.webp -name=良夜; // 解锁CG并赋予名称
changeFigure:stand.webp -left -next;
setAnimation:enter-from-left -target=fig-left -next;
WebGAL:欢迎使用 WebGAL！这是一款全新的网页端视觉小说引擎。 -v1.wav;
changeFigure:stand2.webp -right -next;
WebGAL 是使用 Web 技术开发的引擎，因此在网页端有良好的表现。 -v2.wav;
由于这个特性，如果你将 WebGAL 部署到服务器或网页托管平台上，玩家只需要一串链接就可以开始游玩！ -v3.wav;
setAnimation:move-front-and-back -target=fig-left -next;
听起来是不是非常吸引人？ -v4.wav;
changeFigure:none -right -next;
setAnimation:l2c -target=fig-left -next;
WebGAL 引擎也具有动画系统和特效系统，使用 WebGAL 开发的游戏可以拥有很好的表现效果。 -v5.wav;
pixiInit;
pixiPerform:snow;
比如，这个下起小雪的特效。 -v6.wav;
除此以外，分支选择的功能也必不可少。 -v7.wav;
你可以通过以下两个分支了解 WebGAL 的更多故事。 -v8.wav;
pixiInit;
choose:WebGAL 发展历程:choose1|WebGAL 冷知识:choose2;

;分支1
label:choose1;
WebGAL 的开发初衷是能够让更多人可以更方便地制作属于自己的视觉小说。 -v9.wav;
在一开始，WebGAL 只具备很少的功能，仅仅能支持立绘和背景的显示、语音播放和分支选择。 -v10.wav;
在经历一年的发展后，现在已经是支持了很多优秀的表现效果的引擎了！ -v11.wav;
除此以外，WebGAL 编辑器的加入也使得制作和导出一个游戏更加方便快捷。 -v12.wav;
jumpLabel:end;

;分支2
label:choose2;
这个演示游戏使用的素材是 AI 生成的。 -v13.wav;
WebGAL 项目只用了一年不到就在 GitHub 获得了 1000 星标！ -v14.wav;
WebGAL 的开发历程，是一个在开发中学习开发的过程。因此她经历了3次重构，并且每次几乎都是推倒重来式的。 -v15.wav;
WebGAL 的脚本语言是为了简化制作难度而全新设计的！ -v16.wav;

;结束分支
label:end;
为了更接近桌面端视觉小说引擎的能力，我们支持很多快捷键以及可跳转的剧情回溯。 -v17.wav;
按下菜单中的“回想”按钮或者向上滚动鼠标滚轮试试吧！ -v18.wav;
快速存读挡、丰富的选项、自动播放以及快进等功能，也是应有尽有。 -v19.wav;
setTempAnimation:[{"position": {"x": 500,"y": 0},"duration": 0},{"position": {"x": 400,"y": 0},"duration": 250},{"position": {"x": 600,"y": 0},"duration": 500},{"position": {"x": 500,"y": 0},"duration": 250}] -target=fig-left -next;
当然，这不算什么，因为大多数成熟的引擎都有这些功能。但是在 Web 端，这却是很少见的。 -v20.wav;
我们为可能初次开发游戏的开发者提供了美观的通用 UI 和丰富的预设功能与动画。所以你可以没有顾虑地快速开始制作游戏。 -v21.wav;
WebGAL 项目组期待你的作品能够在 WebGAL 上呈现！只需要一个链接就可以让万千用户立刻开始享受你的作品。 -v22.wav;
感谢你关注 WebGAL 项目！ -v23.wav;
end;
; WebGAL 引擎会默认读取 start.txt 作为初始场景，因此请不要删除，并在初始场景内跳转到其他场景
bgm:s_Title.mp3;
unlockBgm:s_Title.mp3 -name=雲を追いかけて;
intro:你好|欢迎来到 WebGAL 的世界;
changeBg:bg.webp -next;
unlockCg:bg.webp -name=良夜; // 解锁CG并赋予名称
changeFigure:stand.webp -left -next;
setAnimation:enter-from-left -target=fig-left -next;
WebGAL:欢迎使用 WebGAL！这是一款全新的网页端视觉小说引擎。 -v1.wav;
changeFigure:stand2.webp -right -next;
WebGAL 是使用 Web 技术开发的引擎，因此在网页端有良好的表现。 -v2.wav;
由于这个特性，如果你将 WebGAL 部署到服务器或网页托管平台上，玩家只需要一串链接就可以开始游玩！ -v3.wav;
setAnimation:move-front-and-back -target=fig-left -next;
听起来是不是非常吸引人？ -v4.wav;
changeFigure:none -right -next;
setAnimation:l2c -target=fig-left -next;
WebGAL 引擎也具有动画系统和特效系统，使用 WebGAL 开发的游戏可以拥有很好的表现效果。 -v5.wav;
pixiInit;
pixiPerform:snow;
比如，这个下起小雪的特效。 -v6.wav;
除此以外，分支选择的功能也必不可少。 -v7.wav;
你可以通过以下两个分支了解 WebGAL 的更多故事。 -v8.wav;
pixiInit;
choose:WebGAL 发展历程:choose1|WebGAL 冷知识:choose2;

;分支1
label:choose1;
WebGAL 的开发初衷是能够让更多人可以更方便地制作属于自己的视觉小说。 -v9.wav;
在一开始，WebGAL 只具备很少的功能，仅仅能支持立绘和背景的显示、语音播放和分支选择。 -v10.wav;
在经历一年的发展后，现在已经是支持了很多优秀的表现效果的引擎了！ -v11.wav;
除此以外，WebGAL 编辑器的加入也使得制作和导出一个游戏更加方便快捷。 -v12.wav;
jumpLabel:end;

;分支2
label:choose2;
这个演示游戏使用的素材是 AI 生成的。 -v13.wav;
WebGAL 项目只用了一年不到就在 GitHub 获得了 1000 星标！ -v14.wav;
WebGAL 的开发历程，是一个在开发中学习开发的过程。因此她经历了3次重构，并且每次几乎都是推倒重来式的。 -v15.wav;
WebGAL 的脚本语言是为了简化制作难度而全新设计的！ -v16.wav;

;结束分支
label:end;
为了更接近桌面端视觉小说引擎的能力，我们支持很多快捷键以及可跳转的剧情回溯。 -v17.wav;
按下菜单中的“回想”按钮或者向上滚动鼠标滚轮试试吧！ -v18.wav;
快速存读挡、丰富的选项、自动播放以及快进等功能，也是应有尽有。 -v19.wav;
setTempAnimation:[{"position": {"x": 500,"y": 0},"duration": 0},{"position": {"x": 400,"y": 0},"duration": 250},{"position": {"x": 600,"y": 0},"duration": 500},{"position": {"x": 500,"y": 0},"duration": 250}] -target=fig-left -next;
当然，这不算什么，因为大多数成熟的引擎都有这些功能。但是在 Web 端，这却是很少见的。 -v20.wav;
我们为可能初次开发游戏的开发者提供了美观的通用 UI 和丰富的预设功能与动画。所以你可以没有顾虑地快速开始制作游戏。 -v21.wav;
WebGAL 项目组期待你的作品能够在 WebGAL 上呈现！只需要一个链接就可以让万千用户立刻开始享受你的作品。 -v22.wav;
感谢你关注 WebGAL 项目！ -v23.wav;
end;
; WebGAL 引擎会默认读取 start.txt 作为初始场景，因此请不要删除，并在初始场景内跳转到其他场景
bgm:s_Title.mp3;
unlockBgm:s_Title.mp3 -name=雲を追いかけて;
intro:你好|欢迎来到 WebGAL 的世界;
changeBg:bg.webp -next;
unlockCg:bg.webp -name=良夜; // 解锁CG并赋予名称
changeFigure:stand.webp -left -next;
setAnimation:enter-from-left -target=fig-left -next;
WebGAL:欢迎使用 WebGAL！这是一款全新的网页端视觉小说引擎。 -v1.wav;
changeFigure:stand2.webp -right -next;
WebGAL 是使用 Web 技术开发的引擎，因此在网页端有良好的表现。 -v2.wav;
由于这个特性，如果你将 WebGAL 部署到服务器或网页托管平台上，玩家只需要一串链接就可以开始游玩！ -v3.wav;
setAnimation:move-front-and-back -target=fig-left -next;
听起来是不是非常吸引人？ -v4.wav;
changeFigure:none -right -next;
setAnimation:l2c -target=fig-left -next;
WebGAL 引擎也具有动画系统和特效系统，使用 WebGAL 开发的游戏可以拥有很好的表现效果。 -v5.wav;
pixiInit;
pixiPerform:snow;
比如，这个下起小雪的特效。 -v6.wav;
除此以外，分支选择的功能也必不可少。 -v7.wav;
你可以通过以下两个分支了解 WebGAL 的更多故事。 -v8.wav;
pixiInit;
choose:WebGAL 发展历程:choose1|WebGAL 冷知识:choose2;

;分支1
label:choose1;
WebGAL 的开发初衷是能够让更多人可以更方便地制作属于自己的视觉小说。 -v9.wav;
在一开始，WebGAL 只具备很少的功能，仅仅能支持立绘和背景的显示、语音播放和分支选择。 -v10.wav;
在经历一年的发展后，现在已经是支持了很多优秀的表现效果的引擎了！ -v11.wav;
除此以外，WebGAL 编辑器的加入也使得制作和导出一个游戏更加方便快捷。 -v12.wav;
jumpLabel:end;

;分支2
label:choose2;
这个演示游戏使用的素材是 AI 生成的。 -v13.wav;
WebGAL 项目只用了一年不到就在 GitHub 获得了 1000 星标！ -v14.wav;
WebGAL 的开发历程，是一个在开发中学习开发的过程。因此她经历了3次重构，并且每次几乎都是推倒重来式的。 -v15.wav;
WebGAL 的脚本语言是为了简化制作难度而全新设计的！ -v16.wav;

;结束分支
label:end;
为了更接近桌面端视觉小说引擎的能力，我们支持很多快捷键以及可跳转的剧情回溯。 -v17.wav;
按下菜单中的“回想”按钮或者向上滚动鼠标滚轮试试吧！ -v18.wav;
快速存读挡、丰富的选项、自动播放以及快进等功能，也是应有尽有。 -v19.wav;
setTempAnimation:[{"position": {"x": 500,"y": 0},"duration": 0},{"position": {"x": 400,"y": 0},"duration": 250},{"position": {"x": 600,"y": 0},"duration": 500},{"position": {"x": 500,"y": 0},"duration": 250}] -target=fig-left -next;
当然，这不算什么，因为大多数成熟的引擎都有这些功能。但是在 Web 端，这却是很少见的。 -v20.wav;
我们为可能初次开发游戏的开发者提供了美观的通用 UI 和丰富的预设功能与动画。所以你可以没有顾虑地快速开始制作游戏。 -v21.wav;
WebGAL 项目组期待你的作品能够在 WebGAL 上呈现！只需要一个链接就可以让万千用户立刻开始享受你的作品。 -v22.wav;
感谢你关注 WebGAL 项目！ -v23.wav;
end;
; WebGAL 引擎会默认读取 start.txt 作为初始场景，因此请不要删除，并在初始场景内跳转到其他场景
bgm:s_Title.mp3;
unlockBgm:s_Title.mp3 -name=雲を追いかけて;
intro:你好|欢迎来到 WebGAL 的世界;
changeBg:bg.webp -next;
unlockCg:bg.webp -name=良夜; // 解锁CG并赋予名称
changeFigure:stand.webp -left -next;
setAnimation:enter-from-left -target=fig-left -next;
WebGAL:欢迎使用 WebGAL！这是一款全新的网页端视觉小说引擎。 -v1.wav;
changeFigure:stand2.webp -right -next;
WebGAL 是使用 Web 技术开发的引擎，因此在网页端有良好的表现。 -v2.wav;
由于这个特性，如果你将 WebGAL 部署到服务器或网页托管平台上，玩家只需要一串链接就可以开始游玩！ -v3.wav;
setAnimation:move-front-and-back -target=fig-left -next;
听起来是不是非常吸引人？ -v4.wav;
changeFigure:none -right -next;
setAnimation:l2c -target=fig-left -next;
WebGAL 引擎也具有动画系统和特效系统，使用 WebGAL 开发的游戏可以拥有很好的表现效果。 -v5.wav;
pixiInit;
pixiPerform:snow;
比如，这个下起小雪的特效。 -v6.wav;
除此以外，分支选择的功能也必不可少。 -v7.wav;
你可以通过以下两个分支了解 WebGAL 的更多故事。 -v8.wav;
pixiInit;
choose:WebGAL 发展历程:choose1|WebGAL 冷知识:choose2;

;分支1
label:choose1;
WebGAL 的开发初衷是能够让更多人可以更方便地制作属于自己的视觉小说。 -v9.wav;
在一开始，WebGAL 只具备很少的功能，仅仅能支持立绘和背景的显示、语音播放和分支选择。 -v10.wav;
在经历一年的发展后，现在已经是支持了很多优秀的表现效果的引擎了！ -v11.wav;
除此以外，WebGAL 编辑器的加入也使得制作和导出一个游戏更加方便快捷。 -v12.wav;
jumpLabel:end;

;分支2
label:choose2;
这个演示游戏使用的素材是 AI 生成的。 -v13.wav;
WebGAL 项目只用了一年不到就在 GitHub 获得了 1000 星标！ -v14.wav;
WebGAL 的开发历程，是一个在开发中学习开发的过程。因此她经历了3次重构，并且每次几乎都是推倒重来式的。 -v15.wav;
WebGAL 的脚本语言是为了简化制作难度而全新设计的！ -v16.wav;

;结束分支
label:end;
为了更接近桌面端视觉小说引擎的能力，我们支持很多快捷键以及可跳转的剧情回溯。 -v17.wav;
按下菜单中的“回想”按钮或者向上滚动鼠标滚轮试试吧！ -v18.wav;
快速存读挡、丰富的选项、自动播放以及快进等功能，也是应有尽有。 -v19.wav;
setTempAnimation:[{"position": {"x": 500,"y": 0},"duration": 0},{"position": {"x": 400,"y": 0},"duration": 250},{"position": {"x": 600,"y": 0},"duration": 500},{"position": {"x": 500,"y": 0},"duration": 250}] -target=fig-left -next;
当然，这不算什么，因为大多数成熟的引擎都有这些功能。但是在 Web 端，这却是很少见的。 -v20.wav;
我们为可能初次开发游戏的开发者提供了美观的通用 UI 和丰富的预设功能与动画。所以你可以没有顾虑地快速开始制作游戏。 -v21.wav;
WebGAL 项目组期待你的作品能够在 WebGAL 上呈现！只需要一个链接就可以让万千用户立刻开始享受你的作品。 -v22.wav;
感谢你关注 WebGAL 项目！ -v23.wav;
end;
; WebGAL 引擎会默认读取 start.txt 作为初始场景，因此请不要删除，并在初始场景内跳转到其他场景
bgm:s_Title.mp3;
unlockBgm:s_Title.mp3 -name=雲を追いかけて;
intro:你好|欢迎来到 WebGAL 的世界;
changeBg:bg.webp -next;
unlockCg:bg.webp -name=良夜; // 解锁CG并赋予名称
changeFigure:stand.webp -left -next;
setAnimation:enter-from-left -target=fig-left -next;
WebGAL:欢迎使用 WebGAL！这是一款全新的网页端视觉小说引擎。 -v1.wav;
changeFigure:stand2.webp -right -next;
WebGAL 是使用 Web 技术开发的引擎，因此在网页端有良好的表现。 -v2.wav;
由于这个特性，如果你将 WebGAL 部署到服务器或网页托管平台上，玩家只需要一串链接就可以开始游玩！ -v3.wav;
setAnimation:move-front-and-back -target=fig-left -next;
听起来是不是非常吸引人？ -v4.wav;
changeFigure:none -right -next;
setAnimation:l2c -target=fig-left -next;
WebGAL 引擎也具有动画系统和特效系统，使用 WebGAL 开发的游戏可以拥有很好的表现效果。 -v5.wav;
pixiInit;
pixiPerform:snow;
比如，这个下起小雪的特效。 -v6.wav;
除此以外，分支选择的功能也必不可少。 -v7.wav;
你可以通过以下两个分支了解 WebGAL 的更多故事。 -v8.wav;
pixiInit;
choose:WebGAL 发展历程:choose1|WebGAL 冷知识:choose2;

;分支1
label:choose1;
WebGAL 的开发初衷是能够让更多人可以更方便地制作属于自己的视觉小说。 -v9.wav;
在一开始，WebGAL 只具备很少的功能，仅仅能支持立绘和背景的显示、语音播放和分支选择。 -v10.wav;
在经历一年的发展后，现在已经是支持了很多优秀的表现效果的引擎了！ -v11.wav;
除此以外，WebGAL 编辑器的加入也使得制作和导出一个游戏更加方便快捷。 -v12.wav;
jumpLabel:end;

;分支2
label:choose2;
这个演示游戏使用的素材是 AI 生成的。 -v13.wav;
WebGAL 项目只用了一年不到就在 GitHub 获得了 1000 星标！ -v14.wav;
WebGAL 的开发历程，是一个在开发中学习开发的过程。因此她经历了3次重构，并且每次几乎都是推倒重来式的。 -v15.wav;
WebGAL 的脚本语言是为了简化制作难度而全新设计的！ -v16.wav;

;结束分支
label:end;
为了更接近桌面端视觉小说引擎的能力，我们支持很多快捷键以及可跳转的剧情回溯。 -v17.wav;
按下菜单中的“回想”按钮或者向上滚动鼠标滚轮试试吧！ -v18.wav;
快速存读挡、丰富的选项、自动播放以及快进等功能，也是应有尽有。 -v19.wav;
setTempAnimation:[{"position": {"x": 500,"y": 0},"duration": 0},{"position": {"x": 400,"y": 0},"duration": 250},{"position": {"x": 600,"y": 0},"duration": 500},{"position": {"x": 500,"y": 0},"duration": 250}] -target=fig-left -next;
当然，这不算什么，因为大多数成熟的引擎都有这些功能。但是在 Web 端，这却是很少见的。 -v20.wav;
我们为可能初次开发游戏的开发者提供了美观的通用 UI 和丰富的预设功能与动画。所以你可以没有顾虑地快速开始制作游戏。 -v21.wav;
WebGAL 项目组期待你的作品能够在 WebGAL 上呈现！只需要一个链接就可以让万千用户立刻开始享受你的作品。 -v22.wav;
感谢你关注 WebGAL 项目！ -v23.wav;
end;
; WebGAL 引擎会默认读取 start.txt 作为初始场景，因此请不要删除，并在初始场景内跳转到其他场景
bgm:s_Title.mp3;
unlockBgm:s_Title.mp3 -name=雲を追いかけて;
intro:你好|欢迎来到 WebGAL 的世界;
changeBg:bg.webp -next;
unlockCg:bg.webp -name=良夜; // 解锁CG并赋予名称
changeFigure:stand.webp -left -next;
setAnimation:enter-from-left -target=fig-left -next;
WebGAL:欢迎使用 WebGAL！这是一款全新的网页端视觉小说引擎。 -v1.wav;
changeFigure:stand2.webp -right -next;
WebGAL 是使用 Web 技术开发的引擎，因此在网页端有良好的表现。 -v2.wav;
由于这个特性，如果你将 WebGAL 部署到服务器或网页托管平台上，玩家只需要一串链接就可以开始游玩！ -v3.wav;
setAnimation:move-front-and-back -target=fig-left -next;
听起来是不是非常吸引人？ -v4.wav;
changeFigure:none -right -next;
setAnimation:l2c -target=fig-left -next;
WebGAL 引擎也具有动画系统和特效系统，使用 WebGAL 开发的游戏可以拥有很好的表现效果。 -v5.wav;
pixiInit;
pixiPerform:snow;
比如，这个下起小雪的特效。 -v6.wav;
除此以外，分支选择的功能也必不可少。 -v7.wav;
你可以通过以下两个分支了解 WebGAL 的更多故事。 -v8.wav;
pixiInit;
choose:WebGAL 发展历程:choose1|WebGAL 冷知识:choose2;

;分支1
label:choose1;
WebGAL 的开发初衷是能够让更多人可以更方便地制作属于自己的视觉小说。 -v9.wav;
在一开始，WebGAL 只具备很少的功能，仅仅能支持立绘和背景的显示、语音播放和分支选择。 -v10.wav;
在经历一年的发展后，现在已经是支持了很多优秀的表现效果的引擎了！ -v11.wav;
除此以外，WebGAL 编辑器的加入也使得制作和导出一个游戏更加方便快捷。 -v12.wav;
jumpLabel:end;

;分支2
label:choose2;
这个演示游戏使用的素材是 AI 生成的。 -v13.wav;
WebGAL 项目只用了一年不到就在 GitHub 获得了 1000 星标！ -v14.wav;
WebGAL 的开发历程，是一个在开发中学习开发的过程。因此她经历了3次重构，并且每次几乎都是推倒重来式的。 -v15.wav;
WebGAL 的脚本语言是为了简化制作难度而全新设计的！ -v16.wav;

;结束分支
label:end;
为了更接近桌面端视觉小说引擎的能力，我们支持很多快捷键以及可跳转的剧情回溯。 -v17.wav;
按下菜单中的“回想”按钮或者向上滚动鼠标滚轮试试吧！ -v18.wav;
快速存读挡、丰富的选项、自动播放以及快进等功能，也是应有尽有。 -v19.wav;
setTempAnimation:[{"position": {"x": 500,"y": 0},"duration": 0},{"position": {"x": 400,"y": 0},"duration": 250},{"position": {"x": 600,"y": 0},"duration": 500},{"position": {"x": 500,"y": 0},"duration": 250}] -target=fig-left -next;
当然，这不算什么，因为大多数成熟的引擎都有这些功能。但是在 Web 端，这却是很少见的。 -v20.wav;
我们为可能初次开发游戏的开发者提供了美观的通用 UI 和丰富的预设功能与动画。所以你可以没有顾虑地快速开始制作游戏。 -v21.wav;
WebGAL 项目组期待你的作品能够在 WebGAL 上呈现！只需要一个链接就可以让万千用户立刻开始享受你的作品。 -v22.wav;
感谢你关注 WebGAL 项目！ -v23.wav;
end;
; WebGAL 引擎会默认读取 start.txt 作为初始场景，因此请不要删除，并在初始场景内跳转到其他场景
bgm:s_Title.mp3;
unlockBgm:s_Title.mp3 -name=雲を追いかけて;
intro:你好|欢迎来到 WebGAL 的世界;
changeBg:bg.webp -next;
unlockCg:bg.webp -name=良夜; // 解锁CG并赋予名称
changeFigure:stand.webp -left -next;
setAnimation:enter-from-left -target=fig-left -next;
WebGAL:欢迎使用 WebGAL！这是一款全新的网页端视觉小说引擎。 -v1.wav;
changeFigure:stand2.webp -right -next;
WebGAL 是使用 Web 技术开发的引擎，因此在网页端有良好的表现。 -v2.wav;
由于这个特性，如果你将 WebGAL 部署到服务器或网页托管平台上，玩家只需要一串链接就可以开始游玩！ -v3.wav;
setAnimation:move-front-and-back -target=fig-left -next;
听起来是不是非常吸引人？ -v4.wav;
changeFigure:none -right -next;
setAnimation:l2c -target=fig-left -next;
WebGAL 引擎也具有动画系统和特效系统，使用 WebGAL 开发的游戏可以拥有很好的表现效果。 -v5.wav;
pixiInit;
pixiPerform:snow;
比如，这个下起小雪的特效。 -v6.wav;
除此以外，分支选择的功能也必不可少。 -v7.wav;
你可以通过以下两个分支了解 WebGAL 的更多故事。 -v8.wav;
pixiInit;
choose:WebGAL 发展历程:choose1|WebGAL 冷知识:choose2;

;分支1
label:choose1;
WebGAL 的开发初衷是能够让更多人可以更方便地制作属于自己的视觉小说。 -v9.wav;
在一开始，WebGAL 只具备很少的功能，仅仅能支持立绘和背景的显示、语音播放和分支选择。 -v10.wav;
在经历一年的发展后，现在已经是支持了很多优秀的表现效果的引擎了！ -v11.wav;
除此以外，WebGAL 编辑器的加入也使得制作和导出一个游戏更加方便快捷。 -v12.wav;
jumpLabel:end;

;分支2
label:choose2;
这个演示游戏使用的素材是 AI 生成的。 -v13.wav;
WebGAL 项目只用了一年不到就在 GitHub 获得了 1000 星标！ -v14.wav;
WebGAL 的开发历程，是一个在开发中学习开发的过程。因此她经历了3次重构，并且每次几乎都是推倒重来式的。 -v15.wav;
WebGAL 的脚本语言是为了简化制作难度而全新设计的！ -v16.wav;

;结束分支
label:end;
为了更接近桌面端视觉小说引擎的能力，我们支持很多快捷键以及可跳转的剧情回溯。 -v17.wav;
按下菜单中的“回想”按钮或者向上滚动鼠标滚轮试试吧！ -v18.wav;
快速存读挡、丰富的选项、自动播放以及快进等功能，也是应有尽有。 -v19.wav;
setTempAnimation:[{"position": {"x": 500,"y": 0},"duration": 0},{"position": {"x": 400,"y": 0},"duration": 250},{"position": {"x": 600,"y": 0},"duration": 500},{"position": {"x": 500,"y": 0},"duration": 250}] -target=fig-left -next;
当然，这不算什么，因为大多数成熟的引擎都有这些功能。但是在 Web 端，这却是很少见的。 -v20.wav;
我们为可能初次开发游戏的开发者提供了美观的通用 UI 和丰富的预设功能与动画。所以你可以没有顾虑地快速开始制作游戏。 -v21.wav;
WebGAL 项目组期待你的作品能够在 WebGAL 上呈现！只需要一个链接就可以让万千用户立刻开始享受你的作品。 -v22.wav;
感谢你关注 WebGAL 项目！ -v23.wav;
end;



================================================
FILE: parser/test/test-resources/start.txt
================================================
; 初始场景，以及特效演示
changeBg:c4.jpg -next;
unlockCg:c4.jpg -name=街前;  解锁部分CG
unlockCg:xgmain.jpeg -name=星光咖啡馆与死神之蝶;
unlockBgm:s_Title.mp3 -name=Smiling-Swinging!!;
WebGAL:特效系统是3.9.2版本新引入的系统，你想要看特效的演示吗？;
choose:观看特效演示:demo|我不要看特效，直接来吧！:toStart;
label:demo;
pixiInit;
pixiPerform:rain;
WebGAL:现在展示的是下雨的特效。;
pixiInit;
pixiPerform:snow;
WebGAL:现在展示的是下雪的特效。;
setTextbox:hide;
pixiInit;
setTextbox:on -next;
WebGAL:特效的演示已经结束，现在我们正式开始吧！;

; 正式场景
label:toStart;
playVideo:OP.mp4;
changeBg:c3.jpg -next;
unlockCg:c3.jpg -name=cafe;
changeFigure:m2.png -left -next;
bgm:cb1.mp3;
unlockBgm:cb1.mp3 -name=ひとすじの光明;
setAnimation:enter-from-left -target=fig-left -next;
米咖多:蛋包饭是栞那做的，但红茶是夏目泡的。 -v1.ogg;
昂晴:......;
顺便问一下，你是打算做什么的？;
changeFigure:m1.png -left -next;
米咖多:就是倒饮料。然后咖啡和红茶的冲泡方式我还是记住了的。 -v2.ogg;
昂晴:这、这样么......;
:这猫爪子真的能泡茶么。;
拿得了水壶吗？就凭他那个肉球爪子......;
难道这些也是凭借猫妖的奇特力量做到的吗？;
changeFigure:none -left -next;
changeFigure:k1.png -next;
setAnimation:enter-from-bottom -target=fig-center -next;
栞那:那么，你想先尝哪个？ -v3.ogg;
choose:品尝蛋包饭:dbf|品尝红茶:hc;

; 栞那选项
label:dbf;
昂晴:总之，先确认下蛋包饭的味道吧;
changeFigure:k2.png -next;
栞那:明白了，交给我吧 -v4.ogg;
changeFigure:none -next;
changeFigure:m2.png -left -next;
changeFigure:k3.png -right -next;
setAnimation:enter-from-left -target=fig-left -next;
setAnimation:enter-from-right -target=fig-right -next;
栞那:那么米咖多先生，我去做一下试作品 -v5.ogg;
米咖多:嗯。去吧 -v6.ogg;
changeFigure:none -left -next;
changeFigure:none -right -next;
changeFigure:k4.png -next;
setAnimation:enter-from-bottom -target=fig-center -next;
栞那:那么高岭同学，我们移动到厨房吧 -v7.ogg;
changeFigure:none -next;
bgm:cb2.mp3;
unlockBgm:cb2.mp3 -name=Tea Break;
changeBg:c2.jpg;
unlockCg:c2.jpg -name=厨房;
changeFigure:k2.png -next;
栞那:话不多说开始做吧 -v8.ogg;
jumpLabel:end;

; 夏目选项
label:hc;
changeFigure:none -next;
changeFigure:m1.png -left -next;
changeFigure:k1.png -right -next;
setAnimation:enter-from-left -target=fig-left -next;
setAnimation:enter-from-right -target=fig-right -next;
米咖多:那么就是，夏目了吧 -v9.ogg;
changeFigure:k6.png -right -next;
栞那:她刚去休息，要不要我叫回来呢？ -v10.ogg;
昂晴:没事，我自己去吧;
changeFigure:none -left -next;
changeFigure:none -right -next;
bgm:cb2.mp3;
changeBg:c1.jpg -next;
unlockCg:c1.jpg -name=休息室;
:我先敲了敲门;
miniAvatar:n1.png;
夏目:哪位？ -v11.ogg;
昂晴:我是高岭，可以进去吗？;
夏目:可以，没问题 -v12.ogg;
昂晴:打搅了;
miniAvatar:none;
changeFigure:n4.png -next;
昂晴:打搅你休息了;
夏目:不用在意，怎么了？ -v13.ogg;
changeFigure:n2.png -next;
:她并没有无精打采，比想象中精神多了;
昂晴:问道拿手菜谱，就听说四季同学泡的红茶味道不错，我也想品尝一下;
夏目:明白了，那我们回去吧 -v14.ogg;
jumpLabel:end;

; 结束场景
label:end;
changeFigure:none -next;
WebGAL:基础演出的展示已经结束。;



================================================
FILE: parser/test/test-resources/var.txt
================================================
setVar:a=1;
WebGAL:a=1? -when=a==1;

;正常解析
WebGAL:test;

; : 异常测试
WebGAL   :   test;

分号后应该被截断;看不到我！
转义分号后应该不截断\;能看到我！



================================================
FILE: server/README.md
================================================
# WebGAL-Server
WebGAL Server and Command LIne Interface.

WebGAL 本地调试服务器

## 使用说明
### 自动探测模式
自动探测模式在以下两种情况下探测 WebGAL 工程文件：

1、当前目录就是 WebGAL 工程的根目录。

2、当前目录包含名为 'WebGAL' 的目录（不区分大小写），这个目录是 WebGAL 工程的根目录。

### 指定目录模式
通过命令行运行此程序，第一个（且唯一一个）参数就是要指定的绝对或相对路径，是 WebGAL 的工程目录。

**注意：Windows 下的路径不能以 \ 分隔，请以 \\ 或 / 分隔，否则会发生错误。**



================================================
FILE: server/index-linux
================================================
[Non-text file]


================================================
FILE: server/index-macos
================================================
[Non-text file]


================================================
FILE: server/index.js
================================================
const express = require('express');
const Cloudlog = require("cloudlogjs");
const fs = require('fs');
const path = require('path');
const rl = require('readline');
const open = require('open');
const runtimeSceneProvider = require('./runtimeSceneProvider');

// 读取控制台输入
const readline = rl.createInterface({
    input: process.stdin,
    output: process.stdout
})

const server = new express();
const Port = process.env.PORT || 3000;
const logger = new Cloudlog();

const runtimeSliceRoute = /^\/games\/([^/]+)\/scene\/runtime\/(.+\.txt)$/;

server.get(runtimeSliceRoute, async (req, res) => {
    const gameSlug = req.params[0];
    const slicePath = req.params[1];
    const sliceId = slicePath.replace(/\.txt$/, '');
    try {
        const script = await runtimeSceneProvider.getRuntimeSlice(gameSlug, sliceId);
        if (!script) {
            logger.warn(`运行时切片 ${gameSlug}/${sliceId} 未返回内容`);
            return res.status(404).type('text/plain; charset=utf-8').send(`;runtime slice ${sliceId} missing;\nend;`);
        }
        return res.type('text/plain; charset=utf-8').send(script);
    } catch (err) {
        logger.error(`生成运行时切片 ${gameSlug}/${sliceId} 失败`, err);
        return res.status(500).type('text/plain; charset=utf-8').send(`;runtime slice ${sliceId} error;\nend;`);
    }
});

// 读取控制台数据
const args = process.argv;
logger.info(`WebGAL Server 启动参数：`, args);

// 读取工作目录
const cwd = process.cwd();
logger.info(`WebGAL 工作目录当前为 ${cwd}`);

// 检测并获取 WebGAL 游戏资源所在目录
let webgalWd = '';

// 参数模式
if (args.length >= 3) {
    // 参数就是工作目录
    const wdr = args[2];
    logger.info(`指定工作目录：${wdr}`);
    if (wdr[0] === '/' || wdr.match(/^\w:/)) {
        // 绝对路径模式
        logger.debug('绝对路径模式');
        webgalWd = wdr;
    } else {
        // 相对路径模式
        logger.debug('相对路径模式');
        const rwd = wdr.split(/[\\\/]/g);
        webgalWd = path.join(cwd, ...rwd);
    }
    // 输出
    logger.info(`工作目录被设置为 ${webgalWd}`);
}

// 自动探测模式
if (webgalWd === '') {
    const dirInfo = fs.readdirSync(cwd);
    if (dirInfo.includes('index.html')) {
        logger.info(`在当前工作目录下启动 WebGAL`);
        webgalWd = cwd;
    } else {
        // 全转成大写，复制一份副本
        const dirInfoUpperCase = dirInfo.map(e => e.toUpperCase());
        if (dirInfoUpperCase.includes('WEBGAL')) {
            // 找 index
            const index = dirInfoUpperCase.findIndex(e => e === 'WEBGAL');
            const trueDirName = dirInfo[index];
            webgalWd = path.join(cwd, trueDirName);
        } else {
            // 没找到
            logger.info(`未找到 WebGAL 文件，请在 WebGAL 项目目录下启动 WebGAL-Server 或在本目录下的 WebGAL 文件夹下启动。`);
        }
    }
}

if (webgalWd) {
    // 监听端口
    server.use(express.static(webgalWd))//allow browser access resources
    server.listen(Port, () => {
        logger.info(`启动 WebGAL 服务器，运行于 http://localhost:${Port} .`)
    })
    open(`http://localhost:${Port}`);
} else {
    logger.error(`未找到启动文件，请退出`);
    readline.on('line', () => {
        process.exit();
    })
}



================================================
FILE: server/LICENSE
================================================
Mozilla Public License Version 2.0
==================================

1. Definitions
--------------

1.1. "Contributor"
    means each individual or legal entity that creates, contributes to
    the creation of, or owns Covered Software.

1.2. "Contributor Version"
    means the combination of the Contributions of others (if any) used
    by a Contributor and that particular Contributor's Contribution.

1.3. "Contribution"
    means Covered Software of a particular Contributor.

1.4. "Covered Software"
    means Source Code Form to which the initial Contributor has attached
    the notice in Exhibit A, the Executable Form of such Source Code
    Form, and Modifications of such Source Code Form, in each case
    including portions thereof.

1.5. "Incompatible With Secondary Licenses"
    means

    (a) that the initial Contributor has attached the notice described
        in Exhibit B to the Covered Software; or

    (b) that the Covered Software was made available under the terms of
        version 1.1 or earlier of the License, but not also under the
        terms of a Secondary License.

1.6. "Executable Form"
    means any form of the work other than Source Code Form.

1.7. "Larger Work"
    means a work that combines Covered Software with other material, in
    a separate file or files, that is not Covered Software.

1.8. "License"
    means this document.

1.9. "Licensable"
    means having the right to grant, to the maximum extent possible,
    whether at the time of the initial grant or subsequently, any and
    all of the rights conveyed by this License.

1.10. "Modifications"
    means any of the following:

    (a) any file in Source Code Form that results from an addition to,
        deletion from, or modification of the contents of Covered
        Software; or

    (b) any new file in Source Code Form that contains any Covered
        Software.

1.11. "Patent Claims" of a Contributor
    means any patent claim(s), including without limitation, method,
    process, and apparatus claims, in any patent Licensable by such
    Contributor that would be infringed, but for the grant of the
    License, by the making, using, selling, offering for sale, having
    made, import, or transfer of either its Contributions or its
    Contributor Version.

1.12. "Secondary License"
    means either the GNU General Public License, Version 2.0, the GNU
    Lesser General Public License, Version 2.1, the GNU Affero General
    Public License, Version 3.0, or any later versions of those
    licenses.

1.13. "Source Code Form"
    means the form of the work preferred for making modifications.

1.14. "You" (or "Your")
    means an individual or a legal entity exercising rights under this
    License. For legal entities, "You" includes any entity that
    controls, is controlled by, or is under common control with You. For
    purposes of this definition, "control" means (a) the power, direct
    or indirect, to cause the direction or management of such entity,
    whether by contract or otherwise, or (b) ownership of more than
    fifty percent (50%) of the outstanding shares or beneficial
    ownership of such entity.

2. License Grants and Conditions
--------------------------------

2.1. Grants

Each Contributor hereby grants You a world-wide, royalty-free,
non-exclusive license:

(a) under intellectual property rights (other than patent or trademark)
    Licensable by such Contributor to use, reproduce, make available,
    modify, display, perform, distribute, and otherwise exploit its
    Contributions, either on an unmodified basis, with Modifications, or
    as part of a Larger Work; and

(b) under Patent Claims of such Contributor to make, use, sell, offer
    for sale, have made, import, and otherwise transfer either its
    Contributions or its Contributor Version.

2.2. Effective Date

The licenses granted in Section 2.1 with respect to any Contribution
become effective for each Contribution on the date the Contributor first
distributes such Contribution.

2.3. Limitations on Grant Scope

The licenses granted in this Section 2 are the only rights granted under
this License. No additional rights or licenses will be implied from the
distribution or licensing of Covered Software under this License.
Notwithstanding Section 2.1(b) above, no patent license is granted by a
Contributor:

(a) for any code that a Contributor has removed from Covered Software;
    or

(b) for infringements caused by: (i) Your and any other third party's
    modifications of Covered Software, or (ii) the combination of its
    Contributions with other software (except as part of its Contributor
    Version); or

(c) under Patent Claims infringed by Covered Software in the absence of
    its Contributions.

This License does not grant any rights in the trademarks, service marks,
or logos of any Contributor (except as may be necessary to comply with
the notice requirements in Section 3.4).

2.4. Subsequent Licenses

No Contributor makes additional grants as a result of Your choice to
distribute the Covered Software under a subsequent version of this
License (see Section 10.2) or under the terms of a Secondary License (if
permitted under the terms of Section 3.3).

2.5. Representation

Each Contributor represents that the Contributor believes its
Contributions are its original creation(s) or it has sufficient rights
to grant the rights to its Contributions conveyed by this License.

2.6. Fair Use

This License is not intended to limit any rights You have under
applicable copyright doctrines of fair use, fair dealing, or other
equivalents.

2.7. Conditions

Sections 3.1, 3.2, 3.3, and 3.4 are conditions of the licenses granted
in Section 2.1.

3. Responsibilities
-------------------

3.1. Distribution of Source Form

All distribution of Covered Software in Source Code Form, including any
Modifications that You create or to which You contribute, must be under
the terms of this License. You must inform recipients that the Source
Code Form of the Covered Software is governed by the terms of this
License, and how they can obtain a copy of this License. You may not
attempt to alter or restrict the recipients' rights in the Source Code
Form.

3.2. Distribution of Executable Form

If You distribute Covered Software in Executable Form then:

(a) such Covered Software must also be made available in Source Code
    Form, as described in Section 3.1, and You must inform recipients of
    the Executable Form how they can obtain a copy of such Source Code
    Form by reasonable means in a timely manner, at a charge no more
    than the cost of distribution to the recipient; and

(b) You may distribute such Executable Form under the terms of this
    License, or sublicense it under different terms, provided that the
    license for the Executable Form does not attempt to limit or alter
    the recipients' rights in the Source Code Form under this License.

3.3. Distribution of a Larger Work

You may create and distribute a Larger Work under terms of Your choice,
provided that You also comply with the requirements of this License for
the Covered Software. If the Larger Work is a combination of Covered
Software with a work governed by one or more Secondary Licenses, and the
Covered Software is not Incompatible With Secondary Licenses, this
License permits You to additionally distribute such Covered Software
under the terms of such Secondary License(s), so that the recipient of
the Larger Work may, at their option, further distribute the Covered
Software under the terms of either this License or such Secondary
License(s).

3.4. Notices

You may not remove or alter the substance of any license notices
(including copyright notices, patent notices, disclaimers of warranty,
or limitations of liability) contained within the Source Code Form of
the Covered Software, except that You may alter any license notices to
the extent required to remedy known factual inaccuracies.

3.5. Application of Additional Terms

You may choose to offer, and to charge a fee for, warranty, support,
indemnity or liability obligations to one or more recipients of Covered
Software. However, You may do so only on Your own behalf, and not on
behalf of any Contributor. You must make it absolutely clear that any
such warranty, support, indemnity, or liability obligation is offered by
You alone, and You hereby agree to indemnify every Contributor for any
liability incurred by such Contributor as a result of warranty, support,
indemnity or liability terms You offer. You may include additional
disclaimers of warranty and limitations of liability specific to any
jurisdiction.

4. Inability to Comply Due to Statute or Regulation
---------------------------------------------------

If it is impossible for You to comply with any of the terms of this
License with respect to some or all of the Covered Software due to
statute, judicial order, or regulation then You must: (a) comply with
the terms of this License to the maximum extent possible; and (b)
describe the limitations and the code they affect. Such description must
be placed in a text file included with all distributions of the Covered
Software under this License. Except to the extent prohibited by statute
or regulation, such description must be sufficiently detailed for a
recipient of ordinary skill to be able to understand it.

5. Termination
--------------

5.1. The rights granted under this License will terminate automatically
if You fail to comply with any of its terms. However, if You become
compliant, then the rights granted under this License from a particular
Contributor are reinstated (a) provisionally, unless and until such
Contributor explicitly and finally terminates Your grants, and (b) on an
ongoing basis, if such Contributor fails to notify You of the
non-compliance by some reasonable means prior to 60 days after You have
come back into compliance. Moreover, Your grants from a particular
Contributor are reinstated on an ongoing basis if such Contributor
notifies You of the non-compliance by some reasonable means, this is the
first time You have received notice of non-compliance with this License
from such Contributor, and You become compliant prior to 30 days after
Your receipt of the notice.

5.2. If You initiate litigation against any entity by asserting a patent
infringement claim (excluding declaratory judgment actions,
counter-claims, and cross-claims) alleging that a Contributor Version
directly or indirectly infringes any patent, then the rights granted to
You by any and all Contributors for the Covered Software under Section
2.1 of this License shall terminate.

5.3. In the event of termination under Sections 5.1 or 5.2 above, all
end user license agreements (excluding distributors and resellers) which
have been validly granted by You or Your distributors under this License
prior to termination shall survive termination.

************************************************************************
*                                                                      *
*  6. Disclaimer of Warranty                                           *
*  -------------------------                                           *
*                                                                      *
*  Covered Software is provided under this License on an "as is"       *
*  basis, without warranty of any kind, either expressed, implied, or  *
*  statutory, including, without limitation, warranties that the       *
*  Covered Software is free of defects, merchantable, fit for a        *
*  particular purpose or non-infringing. The entire risk as to the     *
*  quality and performance of the Covered Software is with You.        *
*  Should any Covered Software prove defective in any respect, You     *
*  (not any Contributor) assume the cost of any necessary servicing,   *
*  repair, or correction. This disclaimer of warranty constitutes an   *
*  essential part of this License. No use of any Covered Software is   *
*  authorized under this License except under this disclaimer.         *
*                                                                      *
************************************************************************

************************************************************************
*                                                                      *
*  7. Limitation of Liability                                          *
*  --------------------------                                          *
*                                                                      *
*  Under no circumstances and under no legal theory, whether tort      *
*  (including negligence), contract, or otherwise, shall any           *
*  Contributor, or anyone who distributes Covered Software as          *
*  permitted above, be liable to You for any direct, indirect,         *
*  special, incidental, or consequential damages of any character      *
*  including, without limitation, damages for lost profits, loss of    *
*  goodwill, work stoppage, computer failure or malfunction, or any    *
*  and all other commercial damages or losses, even if such party      *
*  shall have been informed of the possibility of such damages. This   *
*  limitation of liability shall not apply to liability for death or   *
*  personal injury resulting from such party's negligence to the       *
*  extent applicable law prohibits such limitation. Some               *
*  jurisdictions do not allow the exclusion or limitation of           *
*  incidental or consequential damages, so this exclusion and          *
*  limitation may not apply to You.                                    *
*                                                                      *
************************************************************************

8. Litigation
-------------

Any litigation relating to this License may be brought only in the
courts of a jurisdiction where the defendant maintains its principal
place of business and such litigation shall be governed by laws of that
jurisdiction, without reference to its conflict-of-law provisions.
Nothing in this Section shall prevent a party's ability to bring
cross-claims or counter-claims.

9. Miscellaneous
----------------

This License represents the complete agreement concerning the subject
matter hereof. If any provision of this License is held to be
unenforceable, such provision shall be reformed only to the extent
necessary to make it enforceable. Any law or regulation which provides
that the language of a contract shall be construed against the drafter
shall not be used to construe this License against a Contributor.

10. Versions of the License
---------------------------

10.1. New Versions

Mozilla Foundation is the license steward. Except as provided in Section
10.3, no one other than the license steward has the right to modify or
publish new versions of this License. Each version will be given a
distinguishing version number.

10.2. Effect of New Versions

You may distribute the Covered Software under the terms of the version
of the License under which You originally received the Covered Software,
or under the terms of any subsequent version published by the license
steward.

10.3. Modified Versions

If you create software not governed by this License, and you want to
create a new license for such software, you may create and use a
modified version of this License if you rename the license and remove
any references to the name of the license steward (except to note that
such modified license differs from this License).

10.4. Distributing Source Code Form that is Incompatible With Secondary
Licenses

If You choose to distribute Source Code Form that is Incompatible With
Secondary Licenses under the terms of this version of the License, the
notice described in Exhibit B of this License must be attached.

Exhibit A - Source Code Form License Notice
-------------------------------------------

  This Source Code Form is subject to the terms of the Mozilla Public
  License, v. 2.0. If a copy of the MPL was not distributed with this
  file, You can obtain one at http://mozilla.org/MPL/2.0/.

If it is not possible or desirable to put the notice in a particular
file, then You may include the notice in a location (such as a LICENSE
file in a relevant directory) where a recipient would be likely to look
for such a notice.

You may add additional accurate notices of copyright ownership.

Exhibit B - "Incompatible With Secondary Licenses" Notice
---------------------------------------------------------

  This Source Code Form is "Incompatible With Secondary Licenses", as
  defined by the Mozilla Public License, v. 2.0.



================================================
FILE: server/myLLMProvider.js
================================================
const fs = require('fs');
const path = require('path');

// 允许通过环境变量覆盖默认的运行时剧情生成器
let customProvider = null;
const providerPath = process.env.WEBGAL_RUNTIME_PROVIDER
  ? path.resolve(process.cwd(), process.env.WEBGAL_RUNTIME_PROVIDER)
  : null;

if (providerPath && fs.existsSync(providerPath)) {
  customProvider = require(providerPath);
}

const normalizeSliceId = (sliceId) => sliceId.replace(/\\/g, '/').replace(/\.txt$/, '');

const demoSlices = {
  'story-lab': {
    'ai-demo/entry': `
intro:正在请求即时生成的剧情|这一段内容由 server/runtimeSceneProvider.js 动态返回;
:你跟随匿名委托来到废弃的讯号塔。;
choose:追踪信号:runtime/ai-demo/signal.txt|先观察周围:runtime/ai-demo/camp.txt;
`,
    'ai-demo/signal': `
changeBg:bg.png -next;
:信号越来越清晰，塔顶忽然亮起蓝色脉冲。;
:你决定沿着扶梯往上，准备截获来源。;
changeScene:chapter_01/shop.txt;
`,
    'ai-demo/camp': `
:你蹲守在旧营地的阴影里，录下塔的每一次闪烁。;
choose:耐心等待:runtime/ai-demo/camp.txt|立刻驶向讯号塔:runtime/ai-demo/signal.txt|回到静态剧情:chapter_01/shop.txt;
`,
  },
};

const fallbackSlice = (gameSlug, sliceId) => `;${gameSlug}:${sliceId} 未提供运行时脚本，检查 server/runtimeSceneProvider.js;\nend;`;

async function getRuntimeSlice(gameSlug, rawSliceId) {
  const normalizedSlug = (gameSlug || 'default').toLowerCase();
  const sliceId = normalizeSliceId(rawSliceId);

  if (customProvider && typeof customProvider.getRuntimeSlice === 'function') {
    const customResult = await customProvider.getRuntimeSlice(normalizedSlug, sliceId);
    if (customResult) {
      return customResult;
    }
  }

  const storyDeck = demoSlices[normalizedSlug] || demoSlices['story-lab'] || {};
  return storyDeck[sliceId] || fallbackSlice(normalizedSlug, sliceId);
}

module.exports = {
  getRuntimeSlice,
};



================================================
FILE: server/package.json
================================================
{
  "name": "WebGAL-Server",
  "scripts": {
    "start": "node index.js",
    "pkg": "pkg index.js"
  },
  "version": "0.1.0",
  "description": "WebGAL Server and Command LIne Interface.",
  "main": "index.js",
  "repository": "https://github.com/WebGAL-Technical-Committee/WebGAL-Server.git",
  "author": "Mahiru <Mahiru_@outlook.com>",
  "license": "MPL-2.0",
  "devDependencies": {
    "pkg": "^5.8.0"
  },
  "dependencies": {
    "cloudlogjs": "^1.0.11",
    "express": "^4.20.0",
    "open": "^8.4.0"
  }
}



================================================
FILE: server/runtimeSceneProvider.js
================================================
const fs = require('fs');
const path = require('path');

// 允许通过环境变量覆盖默认的运行时剧情生成器
let customProvider = null;
const providerPath = process.env.WEBGAL_RUNTIME_PROVIDER
  ? path.resolve(process.cwd(), process.env.WEBGAL_RUNTIME_PROVIDER)
  : null;

if (providerPath && fs.existsSync(providerPath)) {
  customProvider = require(providerPath);
}

const normalizeSliceId = (sliceId) => sliceId.replace(/\\/g, '/').replace(/\.txt$/, '');

const demoSlices = {
  'story-lab': {
    'ai-demo/entry': `
intro:正在请求即时生成的剧情|这一段内容由 server/runtimeSceneProvider.js 动态返回;
:你跟随匿名委托来到废弃的讯号塔。;
choose:追踪信号:runtime/ai-demo/signal.txt|先观察周围:runtime/ai-demo/camp.txt;
`,
    'ai-demo/signal': `
changeBg:bg.png -next;
:信号越来越清晰，塔顶忽然亮起蓝色脉冲。;
:你决定沿着扶梯往上，准备截获来源。;
changeScene:chapter_01/shop.txt;
`,
    'ai-demo/camp': `
:你蹲守在旧营地的阴影里，录下塔的每一次闪烁。;
choose:耐心等待:runtime/ai-demo/camp.txt|立刻驶向讯号塔:runtime/ai-demo/signal.txt|回到静态剧情:chapter_01/shop.txt;
`,
  },
};

const fallbackSlice = (gameSlug, sliceId) => `;${gameSlug}:${sliceId} 未提供运行时脚本，检查 server/runtimeSceneProvider.js;\nend;`;

async function getRuntimeSlice(gameSlug, rawSliceId) {
  const normalizedSlug = (gameSlug || 'default').toLowerCase();
  const sliceId = normalizeSliceId(rawSliceId);

  if (customProvider && typeof customProvider.getRuntimeSlice === 'function') {
    const customResult = await customProvider.getRuntimeSlice(normalizedSlug, sliceId);
    if (customResult) {
      return customResult;
    }
  }

  const storyDeck = demoSlices[normalizedSlug] || demoSlices['story-lab'] || {};
  return storyDeck[sliceId] || fallbackSlice(normalizedSlug, sliceId);
}

module.exports = {
  getRuntimeSlice,
};



================================================
FILE: webgal/index.html
================================================
<!DOCTYPE html>
<html lang="zh-Hans">
  <head>
    <meta charset="UTF-8" />
    <link rel="icon" type="image/x-icon" href="/icons/favicon.ico" />
    <link rel="apple-touch-icon" href="/icons/apple-touch-icon.png" />
    <link rel="manifest" href="/manifest.json" />
    <title>WebGAL</title>
    <style>
      .html-body__effect-background {
        height: 100vh;
        width: 100vw;
        filter: blur(50px);
        background-position: center;
        background-repeat: no-repeat;
        background-size: cover;
        position: absolute;
        top: 0;
        left: 0;
      }

      .html-body__title-enter {
        width: 2560px;
        height: 1440px;
        overflow: hidden;
        position: absolute;
        top: 0;
        z-index: 14;
        opacity: 1;
        transition: opacity 1.5s;
      }

      .title-enter__initial-background {
        height: 100%;
        width: 100%;
        position: absolute;
        background: linear-gradient(135deg, #fdfbfb 0%, #ebedee 100%);
        top: 0;
        opacity: 1;
        transition: opacity 1s;
      }

      .title-enter__white-background {
        width: 100%;
        height: 100%;
        position: absolute;
        top: 0;
        opacity: 0;
        background: linear-gradient(
          165deg,
          rgba(255, 255, 255, 0.25) 0%,
          rgba(255, 255, 255, 1) 50%,
          rgba(255, 255, 255, 0.25) 100%
        );
        transition: opacity 1s;
      }

      .title-enter__container {
        width: 100%;
        position: absolute;
        top: 0;
        height: 100%;
        opacity: 1;
        font-size: 175%;
        transition: opacity 1s;
        z-index: 15;
        font-family: '思源宋体', Georgia, serif;
      }

      .title-enter-container__center-text {
        width: 100%;
        height: 100%;
        display: flex;
        justify-content: center;
        align-items: center;
      }

      .title-enter-container__center-text > div {
        letter-spacing: 0.25em;
        padding: 2em 2em 2em 2em;
        text-shadow: 0 0 30px rgba(0, 0, 0, 0.5);
        transition: text-shadow 1s;
        font-size: 175%;
        animation: title-enter-container__center-text--blink 4s infinite;
      }

      @keyframes title-enter-container__center-text--blink {
        0% {
          text-shadow: 0 0 15px rgba(0, 0, 0, 0.65);
        }
        50% {
          text-shadow: 0 0 15px rgba(255, 255, 255, 0.5);
        }
        100% {
          text-shadow: 0 0 15px rgba(0, 0, 0, 0.65);
        }
      }

      .title-enter-container__link-to-github {
        position: absolute;
        bottom: 1em;
        color: #999;
        font-size: 75%;
        display: flex;
        justify-content: center;
        width: 100%;
        flex-flow: column;
        align-items: center;
      }

      .title-enter-container__link-to-github > div {
        padding: 0 0 0.25em 0;
      }
    </style>
  </head>
  <body>
    <!-- 背景模糊 -->
    <div class="html-body__effect-background"></div>
    <!-- 落地页 -->
    <div class="html-body__title-enter">
      <div class="title-enter__initial-background"></div>
      <div class="title-enter__white-background"></div>
      <div class="title-enter__container">
        <div class="title-enter-container__center-text">
          <div>PRESS THE SCREEN TO START</div>
        </div>
        <div class="title-enter-container__link-to-github">
          <div>Powered by <a> WebGAL </a> Framework</div>
        </div>
      </div>
    </div>
    <!-- 紧急回避页挂载点 -->
    <div id="html-body__panic-overlay"></div>
    <!-- 应用挂载点 -->
    <div id="root"></div>
    <!-- 在窗口大小改变时进行强制缩放 -->
    <script>
      (() => {
        const isIOS = !!navigator.userAgent.match(/\(i[^;]+;( U;)? CPU.+Mac OS X/);
        const resize = () => {
          const targetHeight = 1440; // 目标高度
          const targetWidth = 2560; // 目标宽度

          const h = window.innerHeight; // 窗口高度
          const w = window.innerWidth; // 窗口宽度
          const zoomH = h / targetHeight; // 以窗口高度为基准的变换比
          const zoomW = w / targetWidth; // 以窗口宽度为基准的变换比
          const zoomH2 = w / targetHeight; // 竖屏时以窗口高度为基础的变换比
          const zoomW2 = h / targetWidth; // 竖屏时以窗口宽度为基础的变换比
          let mh = (targetHeight - h) / 2; // y轴移动距离
          let mw = (targetWidth - w) / 2; // x轴移动距离
          let mh2os = targetWidth / 2 - w / 2; // 竖屏时 y轴移动距离
          let mw2os = targetHeight / 2 - h / 2; // 竖屏时 x轴移动距离
          let transform = '';
          let effectBackgroundTransform = '';
          const root = document.querySelector('#root'); // 获取根元素
          const titleEnter = document.querySelector('.html-body__title-enter');
          const effectBackground = document.querySelector('.html-body__effect-background');
          const elements = [root, titleEnter];
          if (w > h) {
            if (effectBackground) {
              effectBackground.style.height = `100vh`;
              effectBackground.style.width = `100vw`;
              effectBackgroundTransform = '';
            }
            mw = -mw;
            mh = -mh;
            if (w * (9 / 16) >= h) {
              transform = `translate(${mw}px, ${mh}px) ` + `scale(${zoomH}, ${zoomH}) `;
            }
            if (w * (9 / 16) < h) {
              transform = `translate(${mw}px, ${mh}px) ` + `scale(${zoomW}, ${zoomW}) `;
            }
          } else {
            // 旋转
            if (effectBackground) {
              effectBackground.style.height = `${targetHeight}px `;
              effectBackground.style.width = `${targetWidth}px `;
            }
            mw2os = -mw2os;
            if (h * (9 / 16) >= w) {
              effectBackgroundTransform =
                `rotate(90deg) ` + `translate(${mw2os}px, ${mh2os}px) ` + `scale(${zoomH2 * 1.75}, ${zoomH2 * 1.75}) `;
              transform = `rotate(90deg) ` + `translate(${mw2os}px, ${mh2os}px) ` + `scale(${zoomH2},${zoomH2}) `;
            }
            if (h * (9 / 16) < w) {
              effectBackgroundTransform =
                `rotate(90deg) ` + ` translate(${mw2os}px, ${mh2os}px) ` + `scale(${zoomW2 * 1.75}, ${zoomW2 * 1.75}) `;
              transform = `rotate(90deg) ` + `translate(${mw2os}px, ${mh2os}px) ` + `scale(${zoomW2},${zoomW2}) `;
            }
            // iOS 不强制旋转
            if (isIOS) {
              const zoomWi = w / targetWidth;
              transform = `translate(${-mw}px, ${-mh}px) ` + `scale(${zoomWi},${zoomWi}) `;
            }
          }
          if (effectBackground) {
            effectBackground.style.transform = effectBackgroundTransform;
          }
          for (const element of elements) {
            if (element) {
              element.style.transform = transform;
            }
          }
        };
        if (!isIOS) {
          // 非 IOS
          // 创建一个新的 meta 标签
          const metaTag = document.createElement('meta');
          metaTag.name = 'viewport';
          metaTag.content = 'width=device-width, initial-scale=1, minimum-scale=1, maximum-scale=1, user-scalable=no';
          // 将该标签添加到 head 中
          document.head.appendChild(metaTag);
          resize();
          window.onload = resize;
          window.onresize = resize;
          // 监听键盘 F11 键按下事件，全屏时触发页面调整
          document.onkeydown = (e) => {
            if (e && e.key === 'F11') {
              setTimeout(() => {
                resize();
              }, 100);
            }
          };
        } else {
          // IOS
          const metaTag = document.createElement('meta');
          metaTag.name = 'viewport';
          metaTag.content = 'width=device-width, initial-scale=0.22, minimum-scale=0.01, maximum-scale=1';
          // 将该标签添加到 head 中
          document.head.appendChild(metaTag);
          const styleTag = document.createElement('style');
          styleTag.textContent = '* { font-synthesis: none !important; }';
          document.head.appendChild(styleTag);
        }
      })();
    </script>
    <!-- 注册 Service Worker -->
    <script>
      (() => {
        const isIOS = !!navigator.userAgent.match(/\(i[^;]+;( U;)? CPU.+Mac OS X/);
        if ('serviceWorker' in navigator && !isIOS) {
          navigator.serviceWorker
            .register('./webgal-serviceworker.js')
            .then((reg) => {
              console.log('Registration succeeded. Scope is ' + reg.scope);
            })
            .catch((error) => {
              console.log('Registration failed with ' + error);
            });
        }
      })();
    </script>
    <!-- 首屏加载 -->
    <script>
      (() => {
        const isIOS = !!navigator.userAgent.match(/\(i[^;]+;( U;)? CPU.+Mac OS X/);
        let enterPromiseResolve;
        const enterPromise = new Promise((res) => {
          enterPromiseResolve = res;
        });
        const renderPromise = new Promise((res) => {
          window.renderPromiseResolve = () => {
            res();
            delete window.renderPromiseResolve;
          };
        });
        // 将播放bgm的事件发送出去
        Promise.all([enterPromise, renderPromise]).then(() => {
          const event = new MouseEvent('click', {
            view: window,
            bubbles: true,
            cancelable: true,
          });
          const target = document.querySelector('.title__enter-game-target');
          if (target) {
            target.dispatchEvent(event);
          }
        });
        /** 点击屏幕，进入引擎主界面 */
        const enter = () => {
          const initialBackground = document.querySelector('.title-enter__initial-background');
          if (initialBackground) {
            initialBackground.style.opacity = '0';
          }
          const container = document.querySelector('.title-enter__container');
          if (container) {
            container.style.opacity = '0';
          }
          const whiteBackground = document.querySelector('.title-enter__white-background');
          setTimeout(() => {
            if (whiteBackground) {
              whiteBackground.style.opacity = '1';
            }
          }, 50); // 在50ms后开始显示白色渐变
          const titleEnter = document.querySelector('.html-body__title-enter');
          setTimeout(() => {
            if (titleEnter) titleEnter.style.opacity = '0';
          }, 500); // 500ms后开始降低落地页透明度
          if (!isIOS && titleEnter) {
            titleEnter.style.pointerEvents = 'none'; // 落地页不再响应点击
            titleEnter.style.background = 'linear-gradient( #a1c4fd 0%, #c2e9fb 100%)'; // 改变标题渐变效果
          }
          setTimeout(() => {
            if (titleEnter) {
              titleEnter.style.display = 'none';
            }
          }, 2000); // 将落地页设置为不显示
          enterPromiseResolve();
        };
        const titleEnter = document.querySelector('.html-body__title-enter');
        if (titleEnter) {
          titleEnter.onclick = enter;
        }
        const linkToGithub = document.querySelector('.title-enter-container__link-to-github');
        const aTag = linkToGithub?.querySelector('a');
        if (aTag) {
          aTag.href = 'https://github.com/OpenWebGAL/WebGAL';
          aTag.onclick = (event) => event.stopPropagation();
        }
      })();
    </script>
    <!-- 加载IIFE插件 -->
    <script>
      (() => {
        const loadScript = (url, type) => {
          return new Promise((resolve, reject) => {
            const script = document.createElement('script');
            script.src = url;
            if (type) script.type = type;
            script.onload = () => resolve(`Loaded: ${url}`);
            script.onerror = () => reject(new Error(`Failed to load: ${url}`));
            document.head.appendChild(script);
          });
        };
        const loadIifePlugin = async (pluginPath) => {
          try {
            const info = await loadScript(pluginPath);
            console.log(info);
            return true;
          } catch (error) {
            console.warn(error);
            return false;
          }
        };
        // 尝试加载 Live2D SDK，
        // 只有在用户自行取得 Live2D 许可并放到下面的目录时，这里才可能加载成功。
        // 本项目 **没有** 引入 Live2D SDK
        // Attempt to load the Live2D SDK.
        // This will only succeed if the user has obtained a Live2D license and placed it in the directory below.
        // This project **does not** include the Live2D SDK.
        // Live2D SDK の読み込みを試みます。
        // ユーザーが Live2D ライセンスを取得し、以下のディレクトリに配置した場合のみ、読み込みが成功します。
        // このプロジェクトには Live2D SDK は**含まれていません**
        const live2d2Promise = loadIifePlugin('lib/live2d.min.js');
        const live2d4Promise = loadIifePlugin('lib/live2dcubismcore.min.js');
        window.live2dPromise = Promise.all([live2d2Promise, live2d4Promise]);
      })();
    </script>
    <!-- main文件 -->
    <script type="module" src="/src/main.tsx"></script>
  </body>
</html>



================================================
FILE: webgal/LICENSE
================================================
Mozilla Public License Version 2.0
==================================

1. Definitions
--------------

1.1. "Contributor"
    means each individual or legal entity that creates, contributes to
    the creation of, or owns Covered Software.

1.2. "Contributor Version"
    means the combination of the Contributions of others (if any) used
    by a Contributor and that particular Contributor's Contribution.

1.3. "Contribution"
    means Covered Software of a particular Contributor.

1.4. "Covered Software"
    means Source Code Form to which the initial Contributor has attached
    the notice in Exhibit A, the Executable Form of such Source Code
    Form, and Modifications of such Source Code Form, in each case
    including portions thereof.

1.5. "Incompatible With Secondary Licenses"
    means

    (a) that the initial Contributor has attached the notice described
        in Exhibit B to the Covered Software; or

    (b) that the Covered Software was made available under the terms of
        version 1.1 or earlier of the License, but not also under the
        terms of a Secondary License.

1.6. "Executable Form"
    means any form of the work other than Source Code Form.

1.7. "Larger Work"
    means a work that combines Covered Software with other material, in
    a separate file or files, that is not Covered Software.

1.8. "License"
    means this document.

1.9. "Licensable"
    means having the right to grant, to the maximum extent possible,
    whether at the time of the initial grant or subsequently, any and
    all of the rights conveyed by this License.

1.10. "Modifications"
    means any of the following:

    (a) any file in Source Code Form that results from an addition to,
        deletion from, or modification of the contents of Covered
        Software; or

    (b) any new file in Source Code Form that contains any Covered
        Software.

1.11. "Patent Claims" of a Contributor
    means any patent claim(s), including without limitation, method,
    process, and apparatus claims, in any patent Licensable by such
    Contributor that would be infringed, but for the grant of the
    License, by the making, using, selling, offering for sale, having
    made, import, or transfer of either its Contributions or its
    Contributor Version.

1.12. "Secondary License"
    means either the GNU General Public License, Version 2.0, the GNU
    Lesser General Public License, Version 2.1, the GNU Affero General
    Public License, Version 3.0, or any later versions of those
    licenses.

1.13. "Source Code Form"
    means the form of the work preferred for making modifications.

1.14. "You" (or "Your")
    means an individual or a legal entity exercising rights under this
    License. For legal entities, "You" includes any entity that
    controls, is controlled by, or is under common control with You. For
    purposes of this definition, "control" means (a) the power, direct
    or indirect, to cause the direction or management of such entity,
    whether by contract or otherwise, or (b) ownership of more than
    fifty percent (50%) of the outstanding shares or beneficial
    ownership of such entity.

2. License Grants and Conditions
--------------------------------

2.1. Grants

Each Contributor hereby grants You a world-wide, royalty-free,
non-exclusive license:

(a) under intellectual property rights (other than patent or trademark)
    Licensable by such Contributor to use, reproduce, make available,
    modify, display, perform, distribute, and otherwise exploit its
    Contributions, either on an unmodified basis, with Modifications, or
    as part of a Larger Work; and

(b) under Patent Claims of such Contributor to make, use, sell, offer
    for sale, have made, import, and otherwise transfer either its
    Contributions or its Contributor Version.

2.2. Effective Date

The licenses granted in Section 2.1 with respect to any Contribution
become effective for each Contribution on the date the Contributor first
distributes such Contribution.

2.3. Limitations on Grant Scope

The licenses granted in this Section 2 are the only rights granted under
this License. No additional rights or licenses will be implied from the
distribution or licensing of Covered Software under this License.
Notwithstanding Section 2.1(b) above, no patent license is granted by a
Contributor:

(a) for any code that a Contributor has removed from Covered Software;
    or

(b) for infringements caused by: (i) Your and any other third party's
    modifications of Covered Software, or (ii) the combination of its
    Contributions with other software (except as part of its Contributor
    Version); or

(c) under Patent Claims infringed by Covered Software in the absence of
    its Contributions.

This License does not grant any rights in the trademarks, service marks,
or logos of any Contributor (except as may be necessary to comply with
the notice requirements in Section 3.4).

2.4. Subsequent Licenses

No Contributor makes additional grants as a result of Your choice to
distribute the Covered Software under a subsequent version of this
License (see Section 10.2) or under the terms of a Secondary License (if
permitted under the terms of Section 3.3).

2.5. Representation

Each Contributor represents that the Contributor believes its
Contributions are its original creation(s) or it has sufficient rights
to grant the rights to its Contributions conveyed by this License.

2.6. Fair Use

This License is not intended to limit any rights You have under
applicable copyright doctrines of fair use, fair dealing, or other
equivalents.

2.7. Conditions

Sections 3.1, 3.2, 3.3, and 3.4 are conditions of the licenses granted
in Section 2.1.

3. Responsibilities
-------------------

3.1. Distribution of Source Form

All distribution of Covered Software in Source Code Form, including any
Modifications that You create or to which You contribute, must be under
the terms of this License. You must inform recipients that the Source
Code Form of the Covered Software is governed by the terms of this
License, and how they can obtain a copy of this License. You may not
attempt to alter or restrict the recipients' rights in the Source Code
Form.

3.2. Distribution of Executable Form

If You distribute Covered Software in Executable Form then:

(a) such Covered Software must also be made available in Source Code
    Form, as described in Section 3.1, and You must inform recipients of
    the Executable Form how they can obtain a copy of such Source Code
    Form by reasonable means in a timely manner, at a charge no more
    than the cost of distribution to the recipient; and

(b) You may distribute such Executable Form under the terms of this
    License, or sublicense it under different terms, provided that the
    license for the Executable Form does not attempt to limit or alter
    the recipients' rights in the Source Code Form under this License.

3.3. Distribution of a Larger Work

You may create and distribute a Larger Work under terms of Your choice,
provided that You also comply with the requirements of this License for
the Covered Software. If the Larger Work is a combination of Covered
Software with a work governed by one or more Secondary Licenses, and the
Covered Software is not Incompatible With Secondary Licenses, this
License permits You to additionally distribute such Covered Software
under the terms of such Secondary License(s), so that the recipient of
the Larger Work may, at their option, further distribute the Covered
Software under the terms of either this License or such Secondary
License(s).

3.4. Notices

You may not remove or alter the substance of any license notices
(including copyright notices, patent notices, disclaimers of warranty,
or limitations of liability) contained within the Source Code Form of
the Covered Software, except that You may alter any license notices to
the extent required to remedy known factual inaccuracies.

3.5. Application of Additional Terms

You may choose to offer, and to charge a fee for, warranty, support,
indemnity or liability obligations to one or more recipients of Covered
Software. However, You may do so only on Your own behalf, and not on
behalf of any Contributor. You must make it absolutely clear that any
such warranty, support, indemnity, or liability obligation is offered by
You alone, and You hereby agree to indemnify every Contributor for any
liability incurred by such Contributor as a result of warranty, support,
indemnity or liability terms You offer. You may include additional
disclaimers of warranty and limitations of liability specific to any
jurisdiction.

4. Inability to Comply Due to Statute or Regulation
---------------------------------------------------

If it is impossible for You to comply with any of the terms of this
License with respect to some or all of the Covered Software due to
statute, judicial order, or regulation then You must: (a) comply with
the terms of this License to the maximum extent possible; and (b)
describe the limitations and the code they affect. Such description must
be placed in a text file included with all distributions of the Covered
Software under this License. Except to the extent prohibited by statute
or regulation, such description must be sufficiently detailed for a
recipient of ordinary skill to be able to understand it.

5. Termination
--------------

5.1. The rights granted under this License will terminate automatically
if You fail to comply with any of its terms. However, if You become
compliant, then the rights granted under this License from a particular
Contributor are reinstated (a) provisionally, unless and until such
Contributor explicitly and finally terminates Your grants, and (b) on an
ongoing basis, if such Contributor fails to notify You of the
non-compliance by some reasonable means prior to 60 days after You have
come back into compliance. Moreover, Your grants from a particular
Contributor are reinstated on an ongoing basis if such Contributor
notifies You of the non-compliance by some reasonable means, this is the
first time You have received notice of non-compliance with this License
from such Contributor, and You become compliant prior to 30 days after
Your receipt of the notice.

5.2. If You initiate litigation against any entity by asserting a patent
infringement claim (excluding declaratory judgment actions,
counter-claims, and cross-claims) alleging that a Contributor Version
directly or indirectly infringes any patent, then the rights granted to
You by any and all Contributors for the Covered Software under Section
2.1 of this License shall terminate.

5.3. In the event of termination under Sections 5.1 or 5.2 above, all
end user license agreements (excluding distributors and resellers) which
have been validly granted by You or Your distributors under this License
prior to termination shall survive termination.

************************************************************************
*                                                                      *
*  6. Disclaimer of Warranty                                           *
*  -------------------------                                           *
*                                                                      *
*  Covered Software is provided under this License on an "as is"       *
*  basis, without warranty of any kind, either expressed, implied, or  *
*  statutory, including, without limitation, warranties that the       *
*  Covered Software is free of defects, merchantable, fit for a        *
*  particular purpose or non-infringing. The entire risk as to the     *
*  quality and performance of the Covered Software is with You.        *
*  Should any Covered Software prove defective in any respect, You     *
*  (not any Contributor) assume the cost of any necessary servicing,   *
*  repair, or correction. This disclaimer of warranty constitutes an   *
*  essential part of this License. No use of any Covered Software is   *
*  authorized under this License except under this disclaimer.         *
*                                                                      *
************************************************************************

************************************************************************
*                                                                      *
*  7. Limitation of Liability                                          *
*  --------------------------                                          *
*                                                                      *
*  Under no circumstances and under no legal theory, whether tort      *
*  (including negligence), contract, or otherwise, shall any           *
*  Contributor, or anyone who distributes Covered Software as          *
*  permitted above, be liable to You for any direct, indirect,         *
*  special, incidental, or consequential damages of any character      *
*  including, without limitation, damages for lost profits, loss of    *
*  goodwill, work stoppage, computer failure or malfunction, or any    *
*  and all other commercial damages or losses, even if such party      *
*  shall have been informed of the possibility of such damages. This   *
*  limitation of liability shall not apply to liability for death or   *
*  personal injury resulting from such party's negligence to the       *
*  extent applicable law prohibits such limitation. Some               *
*  jurisdictions do not allow the exclusion or limitation of           *
*  incidental or consequential damages, so this exclusion and          *
*  limitation may not apply to You.                                    *
*                                                                      *
************************************************************************

8. Litigation
-------------

Any litigation relating to this License may be brought only in the
courts of a jurisdiction where the defendant maintains its principal
place of business and such litigation shall be governed by laws of that
jurisdiction, without reference to its conflict-of-law provisions.
Nothing in this Section shall prevent a party's ability to bring
cross-claims or counter-claims.

9. Miscellaneous
----------------

This License represents the complete agreement concerning the subject
matter hereof. If any provision of this License is held to be
unenforceable, such provision shall be reformed only to the extent
necessary to make it enforceable. Any law or regulation which provides
that the language of a contract shall be construed against the drafter
shall not be used to construe this License against a Contributor.

10. Versions of the License
---------------------------

10.1. New Versions

Mozilla Foundation is the license steward. Except as provided in Section
10.3, no one other than the license steward has the right to modify or
publish new versions of this License. Each version will be given a
distinguishing version number.

10.2. Effect of New Versions

You may distribute the Covered Software under the terms of the version
of the License under which You originally received the Covered Software,
or under the terms of any subsequent version published by the license
steward.

10.3. Modified Versions

If you create software not governed by this License, and you want to
create a new license for such software, you may create and use a
modified version of this License if you rename the license and remove
any references to the name of the license steward (except to note that
such modified license differs from this License).

10.4. Distributing Source Code Form that is Incompatible With Secondary
Licenses

If You choose to distribute Source Code Form that is Incompatible With
Secondary Licenses under the terms of this version of the License, the
notice described in Exhibit B of this License must be attached.

Exhibit A - Source Code Form License Notice
-------------------------------------------

  This Source Code Form is subject to the terms of the Mozilla Public
  License, v. 2.0. If a copy of the MPL was not distributed with this
  file, You can obtain one at http://mozilla.org/MPL/2.0/.

If it is not possible or desirable to put the notice in a particular
file, then You may include the notice in a location (such as a LICENSE
file in a relevant directory) where a recipient would be likely to look
for such a notice.

You may add additional accurate notices of copyright ownership.

Exhibit B - "Incompatible With Secondary Licenses" Notice
---------------------------------------------------------

  This Source Code Form is "Incompatible With Secondary Licenses", as
  defined by the Mozilla Public License, v. 2.0.



================================================
FILE: webgal/package.json
================================================
{
  "name": "webgal-engine",
  "version": "4.5.16",
  "scripts": {
    "dev": "vite --host --port 3000",
    "build": "cross-env NODE_ENV=production tsc && vite build --base=./",
    "preview": "vite preview",
    "lint": "eslint src/** --fix"
  },
  "dependencies": {
    "@emotion/css": "^11.11.2",
    "@icon-park/react": "^1.4.2",
    "@reduxjs/toolkit": "^1.8.1",
    "angular-expressions": "^1.4.3",
    "axios": "^0.30.2",
    "cloudlogjs": "^1.0.9",
    "i18next": "^22.4.15",
    "localforage": "^1.10.0",
    "lodash": "^4.17.21",
    "mitt": "^3.0.0",
    "modern-css-reset": "^1.4.0",
    "pixi-filters": "^4.2.0",
    "pixi-live2d-display-webgal": "^0.5.12",
    "pixi.js": "^6.3.0",
    "popmotion": "^11.0.5",
    "react": "^17.0.2",
    "react-dom": "^17.0.2",
    "react-i18next": "^12.2.2",
    "react-redux": "^8.0.1",
    "sass": "^1.49.9",
    "uuid": "^9.0.0",
    "vite-plugin-package-version": "^1.0.2"
  },
  "devDependencies": {
    "@types/lodash": "^4.14.180",
    "@types/node": "^17.0.23",
    "@types/react": "^17.0.33",
    "@types/react-dom": "^17.0.10",
    "@types/uuid": "^8.3.4",
    "@typescript-eslint/eslint-plugin": "^5.18.0",
    "@typescript-eslint/parser": "^5.18.0",
    "@vitejs/plugin-react": "^4.0.4",
    "cross-env": "^7.0.3",
    "eslint": "^8.13.0",
    "eslint-config-alloy": "^4.5.1",
    "eslint-config-prettier": "^8.5.0",
    "eslint-plugin-prettier": "^4.2.1",
    "eslint-plugin-react": "^7.29.4",
    "lint-staged": "^12.3.7",
    "prettier": "^2.6.2",
    "rollup-plugin-visualizer": "^5.6.0",
    "typescript": "^4.5.4",
    "unplugin-info": "^1.2.2",
    "vite": "^4.5.5",
    "vite-plugin-compression": "^0.5.1"
  }
}



================================================
FILE: webgal/tsconfig.json
================================================
{
  "compilerOptions": {
    "target": "ESNext",
    "useDefineForClassFields": true,
    "lib": ["DOM", "DOM.Iterable", "ESNext"],
    "allowJs": false,
    "skipLibCheck": true,
    "esModuleInterop": false,
    "allowSyntheticDefaultImports": true,
    "strict": true,
    "forceConsistentCasingInFileNames": true,
    "module": "ESNext",
    "moduleResolution": "Node",
    "resolveJsonModule": true,
    "isolatedModules": true,
    "noEmit": true,
    "jsx": "react-jsx",
    "paths": {
      "@/*": ["./src/*"]
    }
  },
  "include": [
    "src"
  ],
  "references": [{ "path": "./tsconfig.node.json"}]
}



================================================
FILE: webgal/tsconfig.node.json
================================================
{
    "compilerOptions": {
      "target": "ES2017",
      "lib": ["ES2021.String"],
        "composite": true,
        "module": "esnext",
        "moduleResolution": "node"
    },
    "include": [
      "vite.config.ts"
    ]
}



================================================
FILE: webgal/vite.config.ts
================================================
import { defineConfig } from 'vite';
import react from '@vitejs/plugin-react';
import loadVersion from 'vite-plugin-package-version';
import { resolve, relative } from 'path';
import { visualizer } from 'rollup-plugin-visualizer';
import { readdirSync, watch, writeFileSync } from 'fs';
import { isEqual } from 'lodash';
import Info from 'unplugin-info/vite';
import viteCompression from 'vite-plugin-compression';

// https://vitejs.dev/config/

// @ts-ignore
const env = process.env.NODE_ENV;
console.log(env);
(() => {
  const pixiPerformScriptDirPath = './src/Core/gameScripts/pixi/performs/';
  const pixiPerformManagerDirPath = './src/Core/util/pixiPerformManager/';
  const relativePath = relative(pixiPerformManagerDirPath, pixiPerformScriptDirPath).replaceAll('\\', '/');
  let lastFiles: string[] = [];

  function setInitFile() {
    console.log('正在自动编写pixi特效依赖注入');
    writeFileSync(
      resolve(pixiPerformManagerDirPath, 'initRegister.ts'),
      lastFiles
        .map((v) => {
          const filePath = relativePath + '/' + v.slice(0, v.lastIndexOf('.'));
          return `import '${filePath}';`;
        })
        .join('\n') + '\n',
      { encoding: 'utf-8' },
    );
  }

  function getPixiPerformScriptFiles() {
    const pixiPerformScriptFiles = readdirSync(pixiPerformScriptDirPath, { encoding: 'utf-8' }).filter((v) =>
      ['ts', 'js', 'tsx', 'jsx'].includes(v.slice(v.indexOf('.') + 1, v.length)),
    );
    if (!isEqual(pixiPerformScriptFiles, lastFiles)) {
      lastFiles = pixiPerformScriptFiles;
      setInitFile();
    }
  }

  getPixiPerformScriptFiles();

  if (env !== 'production') watch(pixiPerformScriptDirPath, { encoding: 'utf-8' }, getPixiPerformScriptFiles);
})();

export default defineConfig({
  plugins: [
    react(),
    loadVersion(),
    Info(),
    viteCompression({
      filter: /^(.*assets).*\.(js|css|ttf)$/,
    }),
    // @ts-ignore
    // visualizer(),
  ],
  resolve: {
    alias: {
      '@': resolve('src'),
    },
  },
  build: {
    // sourcemap: true,
  },
});



================================================
FILE: webgal/.eslintignore
================================================
*.md
*.css
*.scss
*.otf
*.svg
*.ttf
*.ico
*.mp3
*.wav
*.txt



================================================
FILE: webgal/.eslintrc.js
================================================
module.exports = {
  extends: ['alloy', 'alloy/react', 'alloy/typescript', 'plugin:prettier/recommended'],
  env: {
    // 你的环境变量（包含多个预定义的全局变量）
    //
    // browser: true,
    // node: true,
    // mocha: true,
    // jest: true,
    // jquery: true
  },
  globals: {
    // 你的全局变量（设置为 false 表示它不允许被重新赋值）
    //
    // myGlobal: false
  },
  rules: {
    // 自定义你的规则
    // 最大圈复杂度
    complexity: ['error', 30],
    'linebreak-style': ['error', 'unix'],
    semi: 2,
    // indent: ['error', 2],
    'semi-style': ['error', 'last'],
    'react/jsx-no-useless-fragment': [
      'error',
      {
        allowExpressions: true,
      },
    ],
  },
};



================================================
FILE: webgal/.npmignore
================================================

*
!dist/index.html
!dist/assets/**
!dist/webgal-serviceworker.js
!package.json
!README.md
!LICENSE


================================================
FILE: webgal/.prettierignore
================================================
*.md
*.css
*.scss
*.otf
*.svg



================================================
FILE: webgal/.prettierrc.js
================================================
// .prettierrc.js
module.exports = {
    // 一行最多 120 字符
    printWidth: 120,
    // 使用 n 个空格缩进
    tabWidth: 2,
    // 不使用缩进符，而使用空格
    useTabs: false,
    // 行尾需要有分号
    semi: true,
    // 使用单引号
    singleQuote: true,
    // 对象的 key 仅在必要时用引号
    quoteProps: 'as-needed',
    // jsx 不使用单引号，而使用双引号
    jsxSingleQuote: false,
    // 末尾需要有逗号
    trailingComma: 'all',
    // 大括号内的首尾需要空格
    bracketSpacing: true,
    // jsx 标签的反尖括号需要换行
    bracketSameLine: false,
    // 箭头函数，只有一个参数的时候，也需要括号
    arrowParens: 'always',
    // 每个文件格式化的范围是文件的全部内容
    rangeStart: 0,
    rangeEnd: Infinity,
    // 不需要写文件开头的 @prettier
    requirePragma: false,
    // 不需要自动在文件开头插入 @prettier
    insertPragma: false,
    // 使用默认的折行标准
    proseWrap: 'preserve',
    // 根据显示样式决定 html 要不要折行
    htmlWhitespaceSensitivity: 'css',
    // vue 文件中的 script 和 style 内不用缩进
    vueIndentScriptAndStyle: false,
    // 换行符使用 lf
    endOfLine: 'lf',
    // 格式化内嵌代码
    embeddedLanguageFormatting: 'auto',
}



================================================
FILE: webgal/public/games.json
================================================
[
  {
    "slug": "defaultgame",
    "name": "欢迎使用 WebGAL",
    "author": "WebGAL Team",
    "cover": "games/defaultgame/background/WebGalEnter.webp"
  },
  {
    "slug": "story-lab",
    "name": "Story Lab",
    "author": "Local Draft",
    "cover": "games/story-lab/background/cover.png"
  }
]



================================================
FILE: webgal/public/manifest.json
================================================
{
  "name": "WebGAL",
  "short_name": "WebGAL",
  "start_url": ".",
  "display": "fullscreen",
  "description": "WebGAL DEMO",
  "dir": "auto",
  "orientation": "landscape",
  "icons": [
    {
      "src": "./icons/icon-192.png",
      "type": "image/png",
      "sizes": "192x192"
    },
    {
      "src": "./icons/icon-512.png",
      "type": "image/png",
      "sizes": "512x512"
    },
    {
      "src": "./icons/icon-192-maskable.png",
      "type": "image/png",
      "sizes": "192x192",
      "purpose": "maskable"
    },
    {
      "src": "./icons/icon-512-maskable.png",
      "type": "image/png",
      "sizes": "512x512",
      "purpose": "maskable"
    }
  ]
}


================================================
FILE: webgal/public/webgal-serviceworker.js
================================================
self.addEventListener('install', (ev) => {
  // console.log('[service worker] installing');
  ev.waitUntil(self.skipWaiting());
});

// fetch事件是每次页面请求资源时触发的
self.addEventListener('fetch', function (event) {
  const url = event.request.url;
  const isReturnCache = !!(url.match('/assets/') && !url.match('game'));
  if (isReturnCache) {
    // console.log('%cCACHED: ' + url, 'color: #005CAF; padding: 2px;');
  }
  if (!isReturnCache) {
    event.respondWith(fetch(event.request));
  } else {
    event.respondWith(
      // 检查在缓存中是否有匹配的资源
      caches.match(event.request).then(function (response) {
        // 如果缓存中有匹配的资源，则返回缓存资源
        if (response) {
          return response;
        }
        // 如果没有匹配的资源，则尝试从网络请求
        // 同时将获取的资源存入缓存
        return fetch(event.request)
          .then(function (networkResponse) {
            console.log('%cCACHED: ' + url, 'color: #005CAF; padding: 2px;');
            if (networkResponse.status === 206 && event.request.headers.has('range')) {
              // 如果是部分响应且请求带有Range头，则创建新的请求，将完整响应返回给客户端
              // eslint-disable-next-line max-nested-callbacks
              return fetch(event.request.url).then(function (fullNetworkResponse) {
                const headers = {};
                for (let entry of fullNetworkResponse.headers.entries()) {
                  headers[entry[0]] = entry[1];
                }
                const fullResponse = new Response(fullNetworkResponse.body, {
                  status: fullNetworkResponse.status,
                  statusText: fullNetworkResponse.statusText,
                  headers: headers,
                });
                const clonedResponse = fullResponse.clone();
                // eslint-disable-next-line max-nested-callbacks
                caches.open('my-cache').then(function (cache) {
                  cache.put(event.request, clonedResponse);
                });
                return fullResponse;
              });
            }
            const clonedResponse = networkResponse.clone();
            // eslint-disable-next-line max-nested-callbacks
            caches.open('my-cache').then(function (cache) {
              cache.put(event.request, clonedResponse);
            });
            return networkResponse;
          })
          .catch(function (error) {
            console.error('Fetching failed:', error);
            throw error;
          });
      }),
    );
  }
});



================================================
FILE: webgal/public/games/defaultgame/config.txt
================================================
Game_name:欢迎使用WebGAL！;
Game_key:0f87dstRg;
Title_img:WebGAL_New_Enter_Image.webp;
Title_bgm:s_Title.mp3;
Game_Logo:WebGalEnter.webp;
Enable_Appreciation:true;



================================================
FILE: webgal/public/games/defaultgame/userStyleSheet.css
================================================



================================================
FILE: webgal/public/games/defaultgame/animation/animationTable.json
================================================
[
  "enter-from-left",
  "enter-from-bottom",
  "enter-from-right",
  "shake",
  "move-front-and-back",
  "enter",
  "exit",
  "blur",
  "oldFilm",
  "dotFilm",
  "reflectionFilm",
  "glitchFilm",
  "rgbFilm",
  "godrayFilm",
  "removeFilm",
  "shockwaveIn",
  "shockwaveOut"
]



================================================
FILE: webgal/public/games/defaultgame/animation/blur.json
================================================
[
  {
    "blur": 0,
    "duration": 0
  },
  {
    "blur": 5,
    "duration": 300
  }
]



================================================
FILE: webgal/public/games/defaultgame/animation/dotFilm.json
================================================
[
  {
    "dotFilm": 1,
    "duration": 0
  }
]



================================================
FILE: webgal/public/games/defaultgame/animation/enter-from-bottom.json
================================================
[
  {
    "alpha": 0,
    "position": {
      "x": 0,
      "y": 50
    },
    "blur": 5,
    "duration": 0
  },
  {
    "alpha": 1,
    "position": {
      "x": 0,
      "y": 0
    },
    "blur": 0,
    "duration": 500
  }
]



================================================
FILE: webgal/public/games/defaultgame/animation/enter-from-left.json
================================================
[
  {
    "alpha": 0,
    "scale": {
      "x": 1,
      "y": 1
    },
    "position": {
      "x": -50,
      "y": 0
    },
    "rotation": 0,
    "blur": 5,
    "duration": 0
  },
  {
    "alpha": 1,
    "scale": {
      "x": 1,
      "y": 1
    },
    "position": {
      "x": 0,
      "y": 0
    },
    "rotation": 0,
    "blur": 0,
    "duration": 500
  }
]



================================================
FILE: webgal/public/games/defaultgame/animation/enter-from-right.json
================================================
[
  {
    "alpha": 0,
    "position": {
      "x": 50,
      "y": 0
    },
    "blur": 5,
    "duration": 0
  },
  {
    "alpha": 1,
    "position": {
      "x": 0,
      "y": 0
    },
    "blur": 0,
    "duration": 500
  }
]



================================================
FILE: webgal/public/games/defaultgame/animation/enter.json
================================================
[
  {
    "alpha": 0,
    "duration": 0
  },
  {
    "alpha": 1,
    "duration": 300
  }
]



================================================
FILE: webgal/public/games/defaultgame/animation/exit.json
================================================
[
  {
    "alpha": 1,
    "duration": 0
  },
  {
    "alpha": 0,
    "duration": 300
  }
]



================================================
FILE: webgal/public/games/defaultgame/animation/glitchFilm.json
================================================
[
  {
    "glitchFilm": 1,
    "duration": 0
  }
]


================================================
FILE: webgal/public/games/defaultgame/animation/godrayFilm.json
================================================
[
  {
    "godrayFilm": 1,
    "duration": 0
  }
]



================================================
FILE: webgal/public/games/defaultgame/animation/move-front-and-back.json
================================================
[
  {
    "scale": {
      "x": 1,
      "y": 1
    },
    "duration": 0
  },
  {
    "scale": {
      "x": 1.15,
      "y": 1.15
    },
    "duration": 500
  },
  {
    "scale": {
      "x": 1,
      "y": 1
    },
    "duration": 500
  }
]



================================================
FILE: webgal/public/games/defaultgame/animation/oldFilm.json
================================================
[
  {
    "oldFilm": 1,
    "duration": 0
  }
]



================================================
FILE: webgal/public/games/defaultgame/animation/reflectionFilm.json
================================================
[
  {
    "reflectionFilm": 1,
    "duration": 0
  }
]



================================================
FILE: webgal/public/games/defaultgame/animation/removeFilm.json
================================================
[
  {
    "oldFilm": 0,
    "dotFilm": 0,
    "reflectionFilm": 0,
    "glitchFilm": 0,
    "rgbFilm": 0,
    "godrayFilm": 0,
    "duration": 0
  }
]



================================================
FILE: webgal/public/games/defaultgame/animation/rgbFilm.json
================================================
[
  {
    "rgbFilm": 1,
    "duration": 0
  }
]



================================================
FILE: webgal/public/games/defaultgame/animation/shake.json
================================================
[
  {
    "position": {
      "x": 0,
      "y": 0
    },
    "duration": 0
  },
  {
    "position": {
      "x": -100,
      "y": 0
    },
    "duration": 250
  },
  {
    "position": {
      "x": 100,
      "y": 0
    },
    "duration": 500
  },
  {
    "position": {
      "x": 0,
      "y": 0
    },
    "duration": 250
  }
]



================================================
FILE: webgal/public/games/defaultgame/animation/shockwaveIn.json
================================================
[
  {
    "shockwaveFilter": 0,
    "alpha": 1,
    "radiusAlphaFilter": 0,
    "duration": 0
  },
  {
    "shockwaveFilter": 3.05,
    "alpha": 1,
    "radiusAlphaFilter": 1.05,
    "duration": 2000
  }
]



================================================
FILE: webgal/public/games/defaultgame/animation/shockwaveOut.json
================================================
[
  {
    "shockwaveFilter": 0,
    "alpha": 1,
    "duration": 0
  },
  {
    "shockwaveFilter": 3,
    "alpha": 1,
    "duration": 2000
  }
]



================================================
FILE: webgal/public/games/defaultgame/background/bg.webp
================================================
[Non-text file]


================================================
FILE: webgal/public/games/defaultgame/background/WebGAL_New_Enter_Image.webp
================================================
[Non-text file]


================================================
FILE: webgal/public/games/defaultgame/background/WebGalEnter.webp
================================================
[Non-text file]


================================================
FILE: webgal/public/games/defaultgame/figure/miniavatar.webp
================================================
[Non-text file]


================================================
FILE: webgal/public/games/defaultgame/figure/stand.webp
================================================
[Non-text file]


================================================
FILE: webgal/public/games/defaultgame/figure/stand2.webp
================================================
[Non-text file]


================================================
FILE: webgal/public/games/defaultgame/figure/1/closed_eyes.webp
================================================
[Non-text file]


================================================
FILE: webgal/public/games/defaultgame/figure/1/closed_mouth.webp
================================================
[Non-text file]


================================================
FILE: webgal/public/games/defaultgame/figure/1/halfopen_mouth.webp
================================================
[Non-text file]


================================================
FILE: webgal/public/games/defaultgame/figure/1/open_eyes.webp
================================================
[Non-text file]


================================================
FILE: webgal/public/games/defaultgame/figure/1/open_mouth.webp
================================================
[Non-text file]


================================================
FILE: webgal/public/games/defaultgame/figure/2/closed_eyes.webp
================================================
[Non-text file]


================================================
FILE: webgal/public/games/defaultgame/figure/2/closed_mouth.webp
================================================
[Non-text file]


================================================
FILE: webgal/public/games/defaultgame/figure/2/halfopen_mouth.webp
================================================
[Non-text file]


================================================
FILE: webgal/public/games/defaultgame/figure/2/open_eyes.webp
================================================
[Non-text file]


================================================
FILE: webgal/public/games/defaultgame/figure/2/open_mouth.webp
================================================
[Non-text file]


================================================
FILE: webgal/public/games/defaultgame/figure/3/closed_eyes.webp
================================================
[Non-text file]


================================================
FILE: webgal/public/games/defaultgame/figure/3/closed_mouth.webp
================================================
[Non-text file]


================================================
FILE: webgal/public/games/defaultgame/figure/3/halfopen_mouth.webp
================================================
[Non-text file]


================================================
FILE: webgal/public/games/defaultgame/figure/3/open_eyes.webp
================================================
[Non-text file]


================================================
FILE: webgal/public/games/defaultgame/figure/3/open_mouth.webp
================================================
[Non-text file]


================================================
FILE: webgal/public/games/defaultgame/scene/demo_animation.txt
================================================
bgm:s_Title.mp3 -volume=80 -enter=3000;
unlockBgm:s_Title.mp3 -name=ようこそ;
intro:■初めに| このデモゲームで使用している画像素材は、AI生成画像です;
intro:■クレジット| 「VOICEVOX:小夜/SAYO」;
intro:まばたき、口パクのアニメーションテストです;
changeBg:bg.webp;
changeFigure:1/open_mouth.webp -left -next -id=test1 -animationFlag=on -eyesOpen=1/open_eyes.webp  -eyesClose=1/closed_eyes.webp -mouthOpen=1/open_mouth.webp -mouthHalfOpen=1/halfopen_mouth.webp -mouthClose=1/closed_mouth.webp;
WebGAL:こんにちは -001_小夜SAYO（ノーマル）_こんにちは。.wav -fontSize=default -animationFlag=on -figureId=test1;
WebGALは、かつてないまったく新しいビジュアルノベルエンジンです。  -003_小夜SAYO（ノーマル）_ウェブギャルは、か….wav -fontSize=default -animationFlag=on -figureId=test1;
changeFigure:2/open_mouth.webp -next -id=test2 -animationFlag=on -eyesOpen=2/open_eyes.webp  -eyesClose=2/closed_eyes.webp -mouthOpen=2/open_mouth.webp -mouthHalfOpen=2/halfopen_mouth.webp -mouthClose=2/closed_mouth.webp;
WebGAL2:WebGALへようこそ -002_小夜SAYO（ノーマル）_ウェブギャルへよう….wav -fontSize=large -right -animationFlag=on;
Web技術を使用して開発されたエンジンであるため、ウェブページで優れたパフォーマンスを発揮します。 -004_小夜SAYO（ノーマル）_Web技術を使用し….wav -fontSize=default -right -animationFlag=on -figureId=test2;
changeFigure:3/open_mouth.webp -right -next -id=test3 -animationFlag=on -eyesOpen=3/open_eyes.webp -eyesClose=3/closed_eyes.webp -mouthOpen=3/open_mouth.webp -mouthHalfOpen=3/halfopen_mouth.webp -mouthClose=3/closed_mouth.webp;
WebGAL3:この機能のおかげで、ウェブサイト上に公開すると、プレイヤーはリンクを押すだけで -005_小夜SAYO（ノーマル）_この機能のおかげで….wav -fontSize=default -id -figureId=test3;
いつでも、どこでも、ウェブサイト上でゲームをプレイすることができます！ -006_小夜SAYO（ノーマル）_いつでも、どこでも….wav -fontSize=default -id -figureId=test3;
changeFigure: -id=test1;
changeFigure: -id=test2;
changeFigure: -id=test3;
choose:简体中文:demo_zh_cn.txt|日本語:demo_ja.txt|English:demo_en.txt;



================================================
FILE: webgal/public/games/defaultgame/scene/demo_changeConfig.txt
================================================
webgal:我会修改标题 -hold;
setVar:Game_name=WebGal_Change -global;
webgal:游戏标题已经被我修改为{Game_name} -hold;
webgal:我会修改游戏背景 -hold;
setVar:Title_img=bg.webp -global;
webgal:游戏背景已经被我修改为{Title_img} -hold;
webgal:获取Debug值：{Debug} -hold;
setVar:GameNum=15 -global;
webgal:获取并修改GameNum的值：{GameNum} -hold;
setVar:GameNum_Double=GameNum_Double + 5;
webgal:获取GameNum_Double的值，但我不会修改它原本的值：{GameNum_Double} -hold;
webgal:获取bgm声音：{$stage.bgm.volume} -hold;
setVar:bgm_calc= $stage.bgm.volume * 2 ;
webgal:获取bgm声音的两倍是{bgm_calc} -hold;
end;



================================================
FILE: webgal/public/games/defaultgame/scene/demo_en.txt
================================================
bgm:s_Title.mp3 -volume=80 -enter=3000;
unlockBgm:s_Title.mp3 -name=welcome;
intro:*Getting started| The image materials used in this demo game are AI-generated images;
intro:*Credit| Created By ondoku3.com;
changeBg:bg.webp -next;
unlockCg:bg.webp -name=良い夜;
changeFigure:stand.webp -left -enter=enter-from-left -next;
miniAvatar:miniavatar.webp;
WebGAL:Hello -e001_Hello.mp3;
Welcome to WebGAL! -e002_Welcome_to_WebGAL.mp3;
WebGAL is a completely new web visual engine never seen before. -e003_WebGAL_is_a_completely_new_web.mp3;
changeFigure:stand2.webp -right -next;
It is an engine developed using web technology, so it performs well on web pages. -e004_It_is_an_engine_developedusing_web.mp3;
Thanks to this feature, once published on your website's platform, players can simply click a link to play your game on your website anytime, anywhere! -e005_Thanks_to_this_ feature_once.mp3;
setAnimation:move-front-and-back -target=fig-left -next;
Very attractive, don't you think? -e006_Very attractive.mp3;
changeFigure:none -right -next;
setAnimation:l2c -target=fig-left -next;
In addition, WebGAL allows you to add animations and special effects to create high quality games. -e007_In_addition_ WebGAL_allows you.mp3;
pixiInit;
pixiPerform:snow;
For example, let's make it snow as a special effect. -e008_For_example_let's_make.mp3;
As you can see, WebGAL has attractive features. |Try it out and experience it. -e009_As_you_can see_WebGAL.mp3;
That's all for the feature introduction. -e010_That's_all_for_the_feature introduction.mp3;
Next,I will introduce the history and trivia of WebGAL. -e011_Next_I_will introduce_the_ history.mp3;
pixiInit;
choose:WebGAL History:choose1|WebGAL Trivia:choose2;
;選択１
label:choose1;
WebGAL was developed to make it easier for more people to create their own visual novel games. -e012_WebGAL _was_developed to_make_it_ easier.mp3;
Initially, WebGAL had very few features, supporting only standing and background image display, audio playback, and choices. -e013_Initially_ WebGAL_had_very_few_features.mp3;
After a long development period, it has now been reborn as an engine with many excellent functions. -e014_After_a_long _development period.mp3;
Additionally, the release of the WebGAL editor makes creating and outputting games simpler and easier. -e015_Additionally,_the release_of_the WebGAL_editor.mp3;
jumpLabel:end;
;選択２
label:choose2;
The WebGAL project has reached 1000 stars on GitHub in just under a year! -e016_The_WebGAL project_has reached_1000.mp3;
The development process of WebGAL is a process of learning development while developing. -e017_The_development process_of WebGAL_is_a process.mp3;
WebGAL's scripting language was designed from the ground up to simplify production difficulty! -e018_WebGAL's _scripting language_was designed_from the_ground.mp3;
;エンド
label:end;
;changeFigure:none -left -next;
;changeFigure:stand.webp -next;
The WebGAL project supports many keyboard shortcuts and the ability to go back to scenes to more closely match the functionality of a visual novel game engine for the desktop. -e019_The_WebGAL_project_supports_many_keyboard shortcuts.mp3;
Try pressing the "Backlog" button on the menu or scrolling the mouse wheel up! -e020_Try_pressing the_Backlog button.mp3;
Features like quick save, quick load, auto mode and skip mode are also supported. -e021_Features_like_quick_save_quick_load.mp3;
setTempAnimation:[{"position": {"x": 500,"y": 0},"duration": 0},{"position": {"x": 400,"y": 0},"duration": 250},{"position": {"x": 600,"y": 0},"duration": 500},{"position": {"x": 500,"y": 0},"duration": 250}] -target=fig-left -next;
For developers who are developing games for the first time, we provide beautiful general-purpose UI and rich preset functions and animations. -e022_For developers_who_ are_developing_ games.mp3;
So you can start making games quickly. -e023_So_you_can_ start_making_ games_quickly.mp3;
We hope that your work will be exhibited at WebGAL. -e024_We_hope_ that_your_work.mp3;
Thank you for your interest in the WebGAL project! -e025_Thank_you_ for_your_interest_in_the_WebGAL_project!.mp3;
end;



================================================
FILE: webgal/public/games/defaultgame/scene/demo_escape.txt
================================================
intro:我会显示出来：\:\,\.\;不信你看看 -hold;
WebGal:我会显示出来：\:\,\.\;不信你看看;
choose:我会显示出来：\:\,\.\;不信你看看;



================================================
FILE: webgal/public/games/defaultgame/scene/demo_ja.txt
================================================
bgm:s_Title.mp3 -volume=80 -enter=3000;
unlockBgm:s_Title.mp3 -name=ようこそ;
intro:■初めに| このデモゲームで使用している画像素材は、AI生成画像です;
intro:■クレジット| 「VOICEVOX:小夜/SAYO」;
changeBg:bg.webp -next;
unlockCg:bg.webp -name=良い夜; // CGのロックを解いて、名前をつけます。
changeFigure:stand.webp -left -enter=enter-from-left -next;
miniAvatar:miniavatar.webp;
WebGAL:こんにちは。 -001_小夜SAYO（ノーマル）_こんにちは。.wav;
WebGALへようこそ！ -002_小夜SAYO（ノーマル）_ウェブギャルへよう….wav;
WebGALは、かつてないまったく新しいビジュアルノベルエンジンです。 -003_小夜SAYO（ノーマル）_ウェブギャルは、か….wav;
changeFigure:stand2.webp -right -next;
Web技術を使用して開発されたエンジンであるため、ウェブページで優れたパフォーマンスを発揮します。 -004_小夜SAYO（ノーマル）_Web技術を使用し….wav;
この機能のおかげで、ウェブサイト上に公開すると、プレイヤーはリンクを押すだけで、 -005_小夜SAYO（ノーマル）_この機能のおかげで….wav;
いつでも、どこでも、ウェブサイト上でゲームをプレイすることができます！ -006_小夜SAYO（ノーマル）_いつでも、どこでも….wav;
setAnimation:move-front-and-back -target=fig-left -next;
とっても、魅力的ではありませんか？ -007_小夜SAYO（ノーマル）_とっても、魅力的で….wav;
changeFigure:none -right -next;
setAnimation:l2c -target=fig-left -next;
さらに、WebGALでは、アニメーションや特殊効果を追加することができ、クオリティの高いゲームを作成することができます。 -008_小夜SAYO（ノーマル）_さらに、ウェブギャ….wav;
pixiInit;
pixiPerform:snow;
例えば、特殊効果として、雪を降らせてみます。 -009_小夜SAYO（ノーマル）_例えば、特殊効果と….wav;
こんな感じに、WebGALには、魅力的な機能があります。| ぜひ、使ってみて体験してみてください。 -010_小夜SAYO（ノーマル）_こんな感じに、ウェ….wav;
機能の紹介は以上です。 -011_小夜SAYO（ノーマル）_機能の紹介は以上で….wav;
次に、WebGALの歴史と豆知識について紹介します。 -012_小夜SAYO（ノーマル）_次に、ウェブギャル….wav;
興味があれば、引き続きお聞きください。 -013_小夜SAYO（ノーマル）_興味があれば、引き….wav;
pixiInit;
choose:WebGAL 歴史:choose1|WebGAL 豆知識:choose2;

;選択１
label:choose1;
WebGALは、より多くの人が自分のビジュアルノベルゲームを簡単に作成できるようにと、開発されました。 -014_小夜SAYO（ノーマル）_ウェブギャルは、よ….wav;
当初のWebGALには、機能がほとんどなく、立ち絵と背景画像の表示、音声再生、選択肢の選択機能のみをサポートしていました。 -015_小夜SAYO（ノーマル）_当初のウェブギャル….wav;
長きにわたる開発期間を経て、今では多くの優れた機能があるエンジンとして、生まれ変わりました。  -016_小夜SAYO（ノーマル）_長きにわたる開発期….wav;
さらに、WebGALエディターのリリースにより、ゲームの作成と出力がよりシンプルかつ容易になりました。 -017_小夜SAYO（ノーマル）_さらに、ウェブギャ….wav;
jumpLabel:end;

;選択２
label:choose2;
WebGALプロジェクトは、わずか1年足らずでGitHubで1000スターを獲得しました！ -019_小夜SAYO（ノーマル）_ウェブギャルプロジ….wav;
WebGALの開発過程は、開発しながら開発を学ぶプロセスです。 -020_小夜SAYO（ノーマル）_ウェブギャルの開発….wav;
そのため、彼女は3回のリファクタリングを経験し、毎回ほぼゼロからやり直す形となりました。 -021_小夜SAYO（ノーマル）_そのため、彼女は3….wav;
WebGALのスクリプト言語は、制作の難易度を簡素化するためにゼロから設計されました！ -022_小夜SAYO（ノーマル）_ウェブギャルのスク….wav;
;
;l2d
;label:l2d;
;changeFigure:hiyori/hiyori_pro_t11.model3.json -left -motion=Idle -next;
;WebGALプロジェクトでは、現在Live2Dの実験的なサポートも始まっています！これからは正式な機能として成長する可能性もあります！ -023_小夜SAYO（ノーマル）_ウェブギャルプロジ….wav
;
;エンド
label:end;
;changeFigure:none -left -next;
;changeFigure:stand.webp -next;
WebGALプロジェクトは、デスクトップ向けのビジュアルノベルゲームエンジンの機能により近づくため、多くのショートカットキーとシーンの戻る機能をサポートしています。 -024_小夜SAYO（ノーマル）_ウェブギャルプロジ….wav;
メニューの「LOG」ボタンを押すか、マウスホイールを上にスクロールしてみてください！ -025_小夜SAYO（ノーマル）_メニューのログボタ….wav;
豊富な設定、クイックセーブ、クイックロード、自動モード、スキップモードなどの機能もサポートされています。 -026_小夜SAYO（ノーマル）_豊富な設定、クイッ….wav;
setTempAnimation:[{"position": {"x": 500,"y": 0},"duration": 0},{"position": {"x": 400,"y": 0},"duration": 250},{"position": {"x": 600,"y": 0},"duration": 500},{"position": {"x": 500,"y": 0},"duration": 250}] -target=fig-left -next;
初めてゲームを開発する開発者のために、美しい汎用UIと豊富なプリセット機能やアニメーションを提供しています。 -028_小夜SAYO（ノーマル）_初めてゲームを開発….wav
ですから、心配せずに素早くゲーム制作を始めることができます。 -029_小夜SAYO（ノーマル）_ですから、心配せず….wav;
WebGALプロジェクトチームは、あなたの作品がWebGALで展示されることを期待しています！ -030_小夜SAYO（ノーマル）_ウェブギャルプロジ….wav
リンクを1つ用意するだけで、無数のユーザーがあなたの作品をすぐに楽しめるようになります。 -031_小夜SAYO（ノーマル）_リンクを1つ用意す….wav;
WebGALプロジェクトへのご注目、ありがとうございます！ -032_小夜SAYO（ノーマル）_ウェブギャルプロジ….wav;
end;



================================================
FILE: webgal/public/games/defaultgame/scene/demo_performs.txt
================================================
label: performs;
choose: cherryBlossoms:cherryBlossoms | rain:rain | snow:snow | heavySnow:heavySnow;

label: cherryBlossoms;
pixiInit;
pixiPerform: cherryBlossoms;
jumpLabel: performs;

label: rain;
pixiInit;
pixiPerform: rain;
jumpLabel: performs;

label: snow;
pixiInit;
pixiPerform: snow;
jumpLabel: performs;

label: heavySnow;
pixiInit;
pixiPerform: heavySnow;
jumpLabel: performs;


================================================
FILE: webgal/public/games/defaultgame/scene/demo_var.txt
================================================
setVar:bg=bg.webp;
changeBg:{bg} -next;
setVar:speaker=WebGAL;
{speaker}:Background now is {bg}.;
{speaker}:\{bg\} is not use interpolation.;
setVar:a=3;
setVar:bg=WebGalEnter.webp -when=a>2;
changeBg:{bg} -next;
setVar:func=variable interpolation;
{speaker}:Bg changed! Welcome to {speaker} {func}!;
end;



================================================
FILE: webgal/public/games/defaultgame/scene/demo_zh_cn.txt
================================================
bgm:s_Title.mp3 -volume=80 -enter=3000;
unlockBgm:s_Title.mp3 -name=雲を追いかけて;
intro:你好|欢迎来到 {egine} 的世界;
changeBg:WebGalEnter.webp -next;
setTransition: -target=bg-main -exit=shockwaveOut;
:你好|欢迎来到 {egine} 的世界;
changeBg:bg.webp -next;
setTransition: -target=bg-main -enter=shockwaveIn -next;
unlockCg:bg.webp -name=良い夜; // 解锁CG并赋予名称
changeFigure:stand.webp -left -enter=enter-from-left -next;
miniAvatar:miniavatar.webp;
{heroine}:欢迎使用 {egine}！这是一款全新的网页端视觉小说引擎。 -v1.wav;
changeFigure:stand2.webp -right -next;
{egine} 是使用 Web 技术开发的引擎，因此在网页端有良好的表现。 -v2.wav;
由于这个特性，如果你将 {egine} 部署到服务器或网页托管平台上，玩家只需要一串链接就可以开始游玩！ -v3.wav;
setAnimation:move-front-and-back -target=fig-left -continue;
听起来是不是非常吸引人？ -v4.wav;
changeFigure:none -right -next;
setTransform:{"position": {"x": 500,"y": 0}} -target=fig-left -next;
{egine} 引擎也具有动画系统和特效系统，使用 {egine} 开发的游戏可以拥有很好的表现效果。 -v5.wav;
pixiInit;
pixiPerform:snow;
比如，这个下起小雪的特效。 -v6.wav;
除此以外，分支选择的功能也必不可少。 -v7.wav;
pixiInit;
WebGAL:接下来介绍一些新版本功能！
WebGAL:比如这个[注](zhù)[音](yīn)功能，可以为游戏带来更好的体验！
WebGAL:我们也支持了[文本拓展语法](style=color:#B5495B\;)，可以为[文](wen)[本](ben)带来[富文本支持](style-alltext=font-style:italic\; style=color:#66327C\;)、交互等特性。
WebGAL:新版本添加了特性：获取用户输入，你要尝试一下吗？
choose:尝试一下:userInput|算了吧:toNextPart;

label:userInput;
getUserInput:name -title=如何称呼你 -buttonText=确认 -defaultValue=WebGALPlayer;
WebGAL:很高兴遇见你，{name}！
jumpLabel:toNextPart;

label:toNextPart;
你可以通过以下两个分支了解 {egine} 的更多故事。 -v8.wav;
choose:{egine} 发展历程:choose1|{egine} 冷知识:choose2;

;分支1
label:choose1;
{egine} 的开发初衷是能够让更多人可以更方便地制作属于自己的视觉小说。 -v9.wav;
在一开始，{egine} 只具备很少的功能，仅仅能支持立绘和背景的显示、语音播放和分支选择。 -v10.wav;
setAnimation:move-front-and-back -target=fig-left -next;
在经历一年的发展后，现在已经是支持了很多优秀的表现效果的引擎了！ -v11.wav;
除此以外，{egine} 编辑器的加入也使得制作和导出一个游戏更加方便快捷。 -v12.wav;
jumpLabel:end;

;分支2
label:choose2;
这个演示游戏使用的素材是 AI 生成的。 -v13.wav;
{egine} 项目只用了一年不到就在 GitHub 获得了 1000 星标！ -v14.wav;
{egine} 的开发历程，是一个在开发中学习开发的过程。因此她经历了3次重构，并且每次几乎都是推倒重来式的。 -v15.wav;
{egine} 的脚本语言是为了简化制作难度而全新设计的！ -v16.wav;
;
;l2d
;label:l2d;
;changeFigure:hiyori/hiyori_pro_t11.model3.json -left -motion=Idle -next;
;{egine} 项目现在也开始尝试实验性支持 live2D！今后可能会成为一个正式功能！
;
;结束分支
label:end;
;changeFigure:none -left -next;
;changeFigure:stand.webp -next;
为了更接近桌面端视觉小说引擎的能力，我们支持很多快捷键以及可跳转的剧情回溯。 -v17.wav;
按下菜单中的“回想”按钮或者向上滚动鼠标滚轮试试吧！ -v18.wav;
快速存读挡、丰富的选项、自动播放以及快进等功能，也是应有尽有。 -v19.wav;
setTempAnimation:[{"position": {"x": 500,"y": 0},"duration": 0},{"position": {"x": 400,"y": 0},"duration": 250},{"position": {"x": 600,"y": 0},"duration": 500},{"position": {"x": 500,"y": 0},"duration": 250}] -target=fig-left -next;
当然，这不算什么，因为大多数成熟的引擎都有这些功能。但是在 Web 端，这却是很少见的。 -v20.wav;
我们为可能初次开发游戏的开发者提供了美观的通用 UI 和丰富的预设功能与动画。所以你可以没有顾虑地快速开始制作游戏。 -v21.wav;
{egine} 项目组期待你的作品能够在 {egine} 上呈现！只需要一个链接就可以让万千用户立刻开始享受你的作品。 -v22.wav;
感谢你关注 {egine} 项目！ -v23.wav;
end;



================================================
FILE: webgal/public/games/defaultgame/scene/function_test.txt
================================================
choose: Lip Sync Animation Test:demo_animation.txt | Variable interpolation test:demo_var.txt | Change Config:demo_changeConfig.txt | Performs:demo_performs.txt;



================================================
FILE: webgal/public/games/defaultgame/scene/start.txt
================================================
setVar:heroine=WebGAL;
setVar:egine=WebGAL;
choose:简体中文:demo_zh_cn.txt|日本語:demo_ja.txt|English:demo_en.txt|Test:function_test.txt;



================================================
FILE: webgal/public/games/defaultgame/template/template.json
================================================
{
  "name":"Default Template",
  "webgal-version":"4.5.16"
}



================================================
FILE: webgal/public/games/defaultgame/template/Stage/Choose/choose.scss
================================================
.Choose_Main {
  position: absolute;
  width: 100%;
  height: 100%;
  display: flex;
  flex-flow: column;
  justify-content: center;
  align-items: center;
  z-index: 13;
  background: rgba(0, 0, 0, 0.05);
}

.Choose_item {
  font-family: "WebgalUI", serif;
  cursor: pointer;
  min-width: 50%;
  padding: 0.25em 1em 0.25em 1em;
  font-size: 265%;
  color: #8E354A;
  text-align: center;
  border-radius: 4px;
  border: 3px solid rgba(0, 0, 0, 0);
  box-shadow: 0 0 25px rgba(0, 0, 0, 0.25);
  background: rgba(255, 255, 255, 0.65);
  margin: 0.25em 0 0.25em 0;
  transition: background-color 0.5s, border 0.5s, font-weight 0.5s, box-shadow 0.5s;

  &:hover {
    background: rgba(255, 255, 255, 0.9);
    box-shadow: 0 0 25px rgba(0, 0, 0, 0.35);
    border: 3px solid #8E354A;
  }
}

.Choose_item_disabled {
  font-family: "WebgalUI", serif;
  cursor: not-allowed;
  min-width: 50%;
  padding: 0.25em 1em 0.25em 1em;
  font-size: 265%;
  color: rgba(142, 53, 74, 0.5);
  text-align: center;
  border-radius: 4px;
  border: 3px solid rgba(0, 0, 0, 0);
  box-shadow: 0 0 25px rgba(0, 0, 0, 0.25);
  background: rgba(255, 255, 255, 0.5);
  margin: 0.25em 0 0.25em 0;
  transition: background-color 0.5s, border 0.5s, font-weight 0.5s, box-shadow 0.5s;
}

.Choose_item_outer {
  color: #000;
  min-width: 50%;
}



================================================
FILE: webgal/public/games/defaultgame/template/Stage/TextBox/textbox.scss
================================================
.TextBox_main {
  z-index: 3;
  position: absolute;
  right: 25px;
  min-height: 330px;
  max-height: 330px;
  background-blend-mode: darken;
  border-radius: 165px 20px 20px 165px;
  bottom: 20px;
  left: 275px;
  font-weight: bold;
  color: white;
  padding: 1em 50px 70px 200px;
  box-sizing: border-box;
  display: flex;
  flex-flow: column;
  align-items: flex-start;
  letter-spacing: 0.2em;
  transition: left 0.33s;
}

.TextBox_main_miniavatarOff {
  left: 25px;
}

.TextBox_Background {
  z-index: 2;
  background: linear-gradient(rgba(245, 247, 250, 1) 0%, rgba(189, 198, 222, 1) 100%);
}

@keyframes showSoftly {
  0% {
    opacity: 0;
  }

  100% {
    opacity: 1;
  }
}

.TextBox_textElement_start {
  position: relative;
  animation: TextDelayShow 1000ms ease-out forwards;
  opacity: 0;
}

.outer {
  position: absolute;
  white-space: nowrap;
  left: 0;
  top: 0;
  background-image: linear-gradient(#0B346E 0%, #141423 100%);
  background-clip: text;
  -webkit-background-clip: text;
  color: transparent;
  z-index: 2;
}

.inner {
  white-space: nowrap;
  position: absolute;
  left: 0;
  top: 0;
  -webkit-text-stroke: 0.1em rgba(255, 255, 255, 1);
  z-index: 1;
}

.zhanwei {
  color: transparent;
  white-space: nowrap;
}


.TextBox_textElement_Settled {
  position: relative;
  opacity: 1;
}


.TextBox_showName {
  font-size: 85%;
  padding: 0 2em 0 2em;
  position: absolute;
  left: 150px;
  top: -68px;
  height: 80px;
  line-height: 68px;
  border-radius: 40px;
  z-index: 3;
  border: 4px solid rgba(255, 255, 255, 0);
}

.TextBox_ShowName_Background {
  z-index: 2;
  background: rgba(11, 52, 110, 1);
  border: 4px solid rgba(255, 255, 255, 0.75);
  box-shadow: 3px 3px 10px rgba(100, 100, 100, 0.5);
}

@keyframes TextDelayShow {
  0% {
    opacity: 0;
  }

  100% {
    opacity: 1;
  }
}

.miniAvatarContainer {
  position: absolute;
  height: 450px;
  width: 450px;
  bottom: 0;
  left: -250px;
  border-radius: 100% 0 0 100%;
  overflow: hidden;
}

.miniAvatarImg {
  max-height: 100%;
  max-width: 100%;
  position: absolute;
  bottom: 0;
  filter: drop-shadow(15px 0 3px rgba(0, 0, 0, 0.5));
}

.nameContainer {
  position: absolute;
  left: 2em;
  top: -3.5em;
}

.outerName {
  position: absolute;
  left: 0;
  top: 0;
  background: linear-gradient(150deg, rgb(255, 255, 255) 0%, rgb(255, 255, 255) 35%, rgb(165, 212, 228) 100%);
  background-clip: text;
  -webkit-background-clip: text;
  color: transparent;
  z-index: 2;
}

.innerName {
  position: absolute;
  left: 0;
  top: 0;
  z-index: 1;
}

.text {
  overflow: hidden;
}



================================================
FILE: webgal/public/games/defaultgame/template/UI/Title/title.scss
================================================
.Title_main {
  width: 100%;
  height: 100%;
  position: absolute;
  z-index: 13;
}

.Title_buttonList {
  font-family: "思源宋体", serif;
  display: flex;
  position: absolute;
  left: 0;
  min-width: 25%;
  height: 100%;
  justify-content: center;
  align-items: flex-start;
  flex-flow: column;
  transition: background 0.75s;
  padding-left: 120px;
}

.Title_button {
  font-weight: bold;
  text-align: center;
  flex: 0 1 auto;
  cursor: pointer;
  padding: 1em 2em 1em 2em;
  margin: 20px 0;
  transition: all 0.33s;
  background: rgba(255, 255, 255, 0.15);
  backdrop-filter: blur(5px);
  border-radius: 4px;
  transform: skewX(-10deg);
  background: linear-gradient(to right, rgba(0, 0, 0, 0.3), rgba(0, 0, 0, 0.1));

  &:hover {
    text-shadow: 0 0 10px rgba(255, 255, 255, 1);
    padding: 1em 6em 1em 3em;
  }
}

.Title_button_text {
  color: transparent;
  background: linear-gradient(135deg, #fdfbfb 0%, #dcddde 100%);
  -webkit-background-clip: text;
  padding: 0 0.5em 0 0.5em;
  font-size: 200%;
  font-family: WebgalUI, -apple-system, BlinkMacSystemFont, Segoe UI, Roboto, Oxygen, Ubuntu, Cantarell, Fira Sans, Droid Sans, Helvetica Neue, sans-serif;
  letter-spacing: 0.15em;
}

.Title_backup_background {
  width: 100%;
  height: 100%;
  position: absolute;
  z-index: 13;
  background: linear-gradient(135deg, #fdfbfb 0%, #dcddde 100%);
}



================================================
FILE: webgal/public/games/defaultgame/tex/cherryBlossoms.webp
================================================
[Non-text file]


================================================
FILE: webgal/public/games/story-lab/config.txt
================================================
Game_name:My First WebGAL;
Game_key:mygm01;
Title_img:Title.png;
Enable_Appreciation:false;
Default_Language:zh_CN;



================================================
FILE: webgal/public/games/story-lab/userStyleSheet.css
================================================
/* Custom per-game styles go here */



================================================
FILE: webgal/public/games/story-lab/animation/animationTable.json
================================================
[]



================================================
FILE: webgal/public/games/story-lab/scene/start.txt
================================================
intro:这是我们用纯代码做的第一个 demo|不需要 GUI，只用仓库 + 脚本;
; 你可以不放图，先跑文本；放图的话把 bg.png 丢到 background 目录
changeBg:bg.png -next;
:今天去哪儿呢？;
choose:去商店:chapter_01/shop.txt|在家:home|体验AI剧情:runtime/ai-demo/entry.txt;
;
label:home;
:还是在家写点代码吧……;
end;



================================================
FILE: webgal/public/games/story-lab/scene/chapter_01/shop.txt
================================================
:走到商店门口，突然想起忘带钱包……;
choose:返回:../start.txt|硬着头皮进:hard;
;
label:hard;
:你决定靠嘴炮结账——别，还是回去拿钱包吧。;
end;



================================================
FILE: webgal/public/games/story-lab/template/template.json
================================================
{
  "name": "Story Lab Minimal Template"
}



================================================
FILE: webgal/public/games/story-lab/template/Stage/Choose/choose.scss
================================================
.Choose_main { }



================================================
FILE: webgal/public/games/story-lab/template/Stage/TextBox/textbox.scss
================================================
.TextBox_main { }



================================================
FILE: webgal/public/games/story-lab/template/UI/Title/title.scss
================================================
.Title_main { }



================================================
FILE: webgal/src/App.tsx
================================================
import { useState } from 'react';
import { initializeScript } from '@/Core/initializeScript';
import Translation from '@/UI/Translation/Translation';
import { Stage } from '@/Stage/Stage';
import { BottomControlPanel } from '@/UI/BottomControlPanel/BottomControlPanel';
import { BottomControlPanelFilm } from '@/UI/BottomControlPanel/BottomControlPanelFilm';
import { Backlog } from '@/UI/Backlog/Backlog';
import Title from '@/UI/Title/Title';
import Logo from '@/UI/Logo/Logo';
import { Extra } from '@/UI/Extra/Extra';
import Menu from '@/UI/Menu/Menu';
import GlobalDialog from '@/UI/GlobalDialog/GlobalDialog';
import PanicOverlay from '@/UI/PanicOverlay/PanicOverlay';
import DevPanel from '@/UI/DevPanel/DevPanel';
import { Gallery } from '@/Gallery/Gallery';
import { gameState } from '@/Core/gameState';

export default function App() {
  const [view, setView] = useState<'gallery' | 'game'>('gallery');
  const [hasStarted, setHasStarted] = useState(false);

  const handleGameStart = (slug: string) => {
    gameState.activeGameSlug = slug;
    if (!hasStarted) {
      initializeScript();
      setHasStarted(true);
    }
    setView('game');
  };

  if (view === 'gallery') {
    return <Gallery onGameSelect={handleGameStart} />;
  }

  return (
    <div className="App">
      <Translation />
      <Stage />
      <BottomControlPanel />
      <BottomControlPanelFilm />
      <Backlog />
      <Title />
      <Logo />
      <Extra />
      <Menu />
      <GlobalDialog />
      <PanicOverlay />
      <DevPanel />
    </div>
  );
}



================================================
FILE: webgal/src/index.scss
================================================
@charset "UTF-8";

@import 'Core/util/constants';

@font-face {
  font-family: '思源宋体';
  src: url('assets/fonts/SourceHanSerifCN-Regular.ttf') format('truetype');
}

@font-face {
  font-family: 'LXGW';
  src: url('assets/fonts/LXGWWenKai-Regular.ttf') format('truetype');
}

@font-face {
  font-family: 'WebgalUI';
  src: url('assets/fonts/OPPOSans-R.ttf') format('truetype');
}

a {
  transition: color 1s;
}

a:link {
  color: #434343;
}

a:visited {
  color: #434343;
}

a:hover {
  color: #434343;
}

a:active {
  color: #434343;
}

body {
  background-color: #000;
  font-size: 16px;
  margin: 0;
  font-family: 'WebgalUI', -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Oxygen', 'Ubuntu', 'Cantarell',
    'Fira Sans', 'Droid Sans', 'Helvetica Neue', sans-serif;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
  overflow: hidden;
  user-select: none;
}

code {
  font-family: source-code-pro, Menlo, Monaco, Consolas, 'Courier New', monospace;
}

#root {
  width: $screenWidth;
  height: $screenHeight;
  overflow: hidden;
  font-size: 160%;
}

/* 设置滚动条的样式 */
::-webkit-scrollbar {
  width: 12px;
}

/* 滚动槽 */
::-webkit-scrollbar-track {
  box-shadow: 0 0 10px rgba(255, 255, 255, 0.2);
  -webkit-box-shadow: 0 0 10px rgba(255, 255, 255, 0.2);
  background: rgba(255, 255, 255, 0.2);
  border-radius: 10px;
}

/* 滚动条滑块 */
::-webkit-scrollbar-thumb {
  border-radius: 10px;
  background: rgba(255, 255, 255, 0.5);
  box-shadow: 0 0 10px rgba(0, 0, 0, 0.15);
  -webkit-box-shadow: 0 0 10px rgba(0, 0, 0, 0.15);
}

.App {
  height: 100%;
  width: 100%;
  background: rgba(0, 0, 0, 1);
  overflow: hidden;
  perspective: 0;
  -webkit-overflow-scrolling: auto;
}

#pixiCanvas {
  z-index: 5;
}



================================================
FILE: webgal/src/main.tsx
================================================
import { StrictMode } from 'react';
import ReactDOM from 'react-dom';
import App from './App';
import './index.scss';
import './assets/style/animation.scss';
import 'modern-css-reset/dist/reset.min.css';

/** i18n */
import i18n from 'i18next';
import { initReactI18next, Trans } from 'react-i18next';
import { defaultLanguage, i18nTranslationResources, language } from './config/language';
import { Provider } from 'react-redux';
import { webgalStore } from './store/store';

i18n
  .use(initReactI18next) // passes i18n down to react-i18next
  .init({
    // the translations
    // (tip move them in a JSON file and import them,
    // or even better, manage them via a UI: https://react.i18next.com/guides/multiple-translation-files#manage-your-translations-with-a-management-gui)
    resources: i18nTranslationResources || {},
    lng: language[defaultLanguage] || 'zhCn', // if you're using a language detector, do not define the lng option
    fallbackLng: 'zhCn',

    interpolation: {
      escapeValue: false, // react already safes from xss => https://www.i18next.com/translation-function/interpolation#unescape
    },
  })
  .then(() => console.log('WebGAL i18n Ready!'));

// eslint-disable-next-line react/no-deprecated
ReactDOM.render(
  <StrictMode>
    <Trans>
      <Provider store={webgalStore}>
        <App />
      </Provider>
    </Trans>
  </StrictMode>,
  document.querySelector('#root'),
);



================================================
FILE: webgal/src/vite-env.d.ts
================================================
/// <reference types="vite/client" />
/// <reference types="unplugin-info/client" />



================================================
FILE: webgal/src/assets/fonts/LXGWWenKai-Regular.ttf
================================================
[Non-text file]


================================================
FILE: webgal/src/assets/fonts/OPPOSans-R.ttf
================================================
[Non-text file]


================================================
FILE: webgal/src/assets/fonts/SourceHanSerifCN-Regular.ttf
================================================
[Non-text file]


================================================
FILE: webgal/src/assets/se/license.txt
================================================
mouse-enter.mp3
协议：CC0 作者：deadsillyrabbit 来源：https://www.aigei.com

dialog.mp3
协议：CC0 作者：wobbleboxx 来源：https://www.aigei.com

click.mp3
协议：CC0 作者：OwlishMedia 来源：https://www.aigei.com

page-flip-1.mp3
switch-1.wav
This work has been identified as being free of known restrictions under copyright law, including all related and neighboring rights.
You can copy, modify, distribute and perform the work, even for commercial purposes, all without asking permission.



================================================
FILE: webgal/src/assets/style/animation.scss
================================================
@keyframes centerIn {
  0% {
    opacity: 0;
    transform: scale(1, 1);
  }

  100% {
    opacity: 1;
    transform: scale(1, 1);
  }
}

@keyframes upIn {
  0% {
    opacity: 0;
    transform: scale(1, 1) translate(0, 3%);
  }

  100% {
    opacity: 1;
    transform: scale(1, 1) translate(0, 0);
  }
}

@keyframes leftIn {
  0% {
    opacity: 0;
    transform: scale(1, 1) translate(-3%, 0);
  }

  100% {
    opacity: 1;
    transform: scale(1, 1) translate(0, 0);
  }
}

@keyframes rightIn {
  0% {
    opacity: 0;
    transform: scale(1, 1) translate(3%, 0);
  }

  100% {
    opacity: 1;
    transform: scale(1, 1) translate(0, 0);
  }
}

@keyframes bg_down {
  0% {
    opacity: 0;
    transform: scale(1.1, 1.1) translate(0, -3%);
  }

  100% {
    opacity: 1;
    transform: scale(1, 1) translate(0, 0);
  }
}

@keyframes bg_softIn {
  0% {
    opacity: 0;
  }

  100% {
    opacity: 1;
  }
}

@keyframes hideBG {
  0% {
    opacity: 1;
  }

  100% {
    opacity: 0;
  }
}

@keyframes shake {
  0% {
    transform: translate(0, 0);
  }

  25% {
    transform: translate(-2%, 0);
  }

  75% {
    transform: translate(2%, 0);
  }

  100% {
    transform: translate(0, 0);
  }
}

@keyframes moveBaF {
  0% {
    transform: scale(1, 1);
  }

  50% {
    transform: scale(1.1, 1.1);
  }

  100% {
    transform: scale(1, 1);
  }
}

@keyframes showSoftly /* Safari 与 Chrome */
{
  0% {
    opacity: 0;
  }
  100% {
    opacity: 1;
  }
}

@keyframes elementFadeIn {
  0% {
    transform: translate(-15px, -20px) scale(1.03, 1.03);
    opacity: 0;
  }
  100% {
    opacity: 1;
  }
}

@keyframes controlButtonHover {
  0% {
    background-color: rgba(0, 0, 0, 0);
    box-shadow: none;
  }
  100% {
    background-color: rgba(255, 255, 255, 0.25);
    box-shadow: 5px 5px 15px rgba(0, 0, 0, 0.65);
  }
}

@keyframes controlButtonHoverBack {
  0% {
    /*background-color: rgba(255, 255, 255, 0.25);*/
    /*box-shadow: 5px 5px 15px rgba(0, 0, 0, 0.65);*/
  }
  100% {

  }
}

@keyframes TitleButtonOnChoose {
  0% {
    transform: scale(1, 1);
    /*background-color: rgba(255,255,255,0.8);*/
  }

  100% {
    /*box-shadow: 3px 3px 15px rgba(0, 0, 0, 0.5);*/
    transform: scale(1.1, 1.1);
    /*background-color: rgba(0,0,0,0.15);*/
  }
}

@keyframes TitleButtonNoneChoose {
  0% {
    /*box-shadow: 3px 3px 15px rgba(0, 0, 0, 0.5);*/
    transform: scale(1.1, 1.1);
    /*background-color: rgba(0,0,0,0.15);*/
  }

  100% {

  }
}

@keyframes TitleModelHover {
  0% {
    background-color: rgba(0, 0, 0, 0.35);
  }
  100% {
    background-color: rgba(0, 0, 0, 0.65);
  }
}

@keyframes TitleModelNoneHover {
  0% {
    background-color: rgba(0, 0, 0, 0.65);
  }
  100% {
    background-color: rgba(0, 0, 0, 0.35);
  }
}


/*背景的演出效果*/
@keyframes bg_focusLeft {
  0% {
    transform: scale(1, 1) translate(0, 0);
    filter: blur(0);
  }
  100% {
    transform: scale(1.15, 1.15) translate(5%, 0);
    filter: blur(1px);
  }
}

@keyframes bg_focusRight {
  0% {
    transform: scale(1, 1) translate(0, 0);
    filter: blur(0);
  }
  100% {
    transform: scale(1.15, 1.15) translate(-5%, 0);
    filter: blur(1px);
  }
}

@keyframes bg_LtoR {
  0% {
    transform: scale(1.15, 1.15) translate(5%, 0);
    filter: blur(1px);
  }
  100% {
    transform: scale(1.15, 1.15) translate(-5%, 0);
    filter: blur(1px);
  }
}

@keyframes bg_RtoL {
  0% {
    transform: scale(1.15, 1.15) translate(-5%, 0);
    filter: blur(1px);
  }
  100% {
    transform: scale(1.15, 1.15) translate(5%, 0);
    filter: blur(1px);
  }
}

@keyframes bg_LtoC {
  0% {
    transform: scale(1.15, 1.15) translate(5%, 0);
    filter: blur(1px);
  }
  100% {
    transform: scale(1, 1) translate(0, 0);
    filter: blur(0);
  }
}

@keyframes bg_RtoC {
  0% {
    transform: scale(1.15, 1.15) translate(-5%, 0);
    filter: blur(1px);
  }
  100% {
    transform: scale(1, 1) translate(0, 0);
    filter: blur(0);
  }
}

@keyframes bg_focus {
  0% {
    transform: scale(1, 1) translate(0, 0);
    filter: blur(0);
  }
  100% {
    transform: scale(1.15, 1.15);
    filter: blur(1px);
  }
}

@keyframes bg_LtoF {
  0% {
    transform: scale(1.15, 1.15) translate(5%, 0);
    filter: blur(1px);
  }
  100% {
    transform: scale(1.15, 1.15);
    filter: blur(1px);
  }
}

@keyframes bg_RtoF {
  0% {
    transform: scale(1.15, 1.15) translate(-5%, 0);
    filter: blur(1px);
  }
  100% {
    transform: scale(1.15, 1.15);
    filter: blur(1px);
  }
}

@keyframes bg_FtoL {
  0% {
    transform: scale(1.15, 1.15);
    filter: blur(1px);
  }
  100% {
    transform: scale(1.15, 1.15) translate(5%, 0);
    filter: blur(1px);
  }
}

@keyframes bg_FtoR {
  0% {
    transform: scale(1.15, 1.15);
    filter: blur(1px);
  }
  100% {
    transform: scale(1.15, 1.15) translate(-5%, 0);
    filter: blur(1px);
  }
}

@keyframes bg_FtoC {
  0% {
    transform: scale(1.15, 1.15);
    filter: blur(1px);
  }
  100% {
    transform: scale(1, 1) translate(0, 0);
    filter: blur(0);
  }
}



================================================
FILE: webgal/src/config/index.ts
================================================
export const SYSTEM_CONFIG = {
  backlog_size: 200,
  fast_timeout: 50,
};
export const PERFORM_CONFIG = {
  // 不能小于50
  textInitialDelay: 80,
};



================================================
FILE: webgal/src/config/info.ts
================================================
import { version } from '~build/package';

export const __INFO = {
  version,
  contributors: [
    // 现在改为跳转到 GitHub 了
  ],
};



================================================
FILE: webgal/src/config/language.ts
================================================
/**
 * You can config the languages display in this file.
 * If you want close someone, please add "//" forward that line.
 * If you want to add language, please add the language English abbreviation name into language and languages,
 * also you need to code the name of it show.
 */

import en from '@/translations/en';
import jp from '@/translations/jp';
import zhCn from '@/translations/zh-cn';
import fr from '@/translations/fr';
import de from '@/translations/de';
import zhTw from '@/translations/zh-tw';
/*
  Import your translation configs here;
  example:
  import myLang from '@/translations/filename of your config file';
*/

export enum language {
  zhCn,
  en,
  jp,
  fr,
  de,
  zhTw,
}

const languages: Record<string, string> = {
  zhCn: '简体中文',
  en: 'English',
  jp: '日本語',
  fr: 'Français',
  de: 'Deutsch',
  zhTw: '繁體中文',
};

export const i18nTranslationResources: Record<string, { translation: Record<string, any> }> = {
  en: { translation: en },
  zhCn: { translation: zhCn },
  jp: { translation: jp },
  fr: { translation: fr },
  de: { translation: de },
  zhTw: { translation: zhTw },
};

export const defaultLanguage: language = language.zhCn;

export default languages;



================================================
FILE: webgal/src/Core/constants.ts
================================================
export const STAGE_KEYS = {
  STAGE_MAIN: 'stage-main',
  BGMAIN: 'bg-main',
  FIG_C: 'fig-center',
  FIG_L: 'fig-left',
  FIG_R: 'fig-right',
};

export const WEBGAL_NONE = 'none';
export const DEFALUT_FIG_IN_DURATION = 300;
export const DEFALUT_FIG_OUT_DURATION = 450;



================================================
FILE: webgal/src/Core/gameState.ts
================================================
export const DEFAULT_GAME_SLUG = 'defaultgame';

/**
 * Simple runtime container storing which game is currently active.
 * The slug is used to resolve assets inside public/games/<slug>.
 */
export const gameState = {
  activeGameSlug: DEFAULT_GAME_SLUG,
};

/**
 * Returns the base path (relative to /public) of the active game.
 */
export const getActiveGameBasePath = (): string => `./games/${gameState.activeGameSlug}`;

/**
 * Resolve a relative resource path for the active game.
 * @param subPath path inside the game folder, e.g. `scene/start.txt`
 */
export const getGameAssetPath = (subPath = ''): string => {
  const base = getActiveGameBasePath();
  const normalizedSubPath = subPath.replace(/^\/+/, '');
  return normalizedSubPath.length > 0 ? `${base}/${normalizedSubPath}` : base;
};



================================================
FILE: webgal/src/Core/initializeScript.ts
================================================
/**
 * @file 引擎初始化时会执行的脚本，包括获取游戏信息，初始化运行时变量，初始化用户数据存储
 */
import { logger } from './util/logger';
import { infoFetcher } from './util/coreInitialFunction/infoFetcher';
import { assetSetter, fileType } from './util/gameAssetsAccess/assetSetter';
import { sceneFetcher } from './controller/scene/sceneFetcher';
import { sceneParser } from './parser/sceneParser';
import { bindExtraFunc } from '@/Core/util/coreInitialFunction/bindExtraFunc';
import { webSocketFunc } from '@/Core/util/syncWithEditor/webSocketFunc';
import uniqWith from 'lodash/uniqWith';
import { scenePrefetcher } from './util/prefetcher/scenePrefetcher';
import PixiStage from '@/Core/controller/stage/pixi/PixiController';
import axios from 'axios';
import { __INFO } from '@/config/info';
import { WebGAL } from '@/Core/WebGAL';
import { getGameAssetPath } from '@/Core/gameState';

const u = navigator.userAgent;
export const isIOS = !!u.match(/\(i[^;]+;( U;)? CPU.+Mac OS X/); // 判断是否是 iOS终端

/**
 * 引擎初始化函数
 */
export const initializeScript = (): void => {
  // 打印初始log信息
  logger.info(`WebGAL v${__INFO.version}`);
  logger.info('Github: https://github.com/OpenWebGAL/WebGAL ');
  logger.info('Made with ❤ by OpenWebGAL');
  // 激活强制缩放
  // 在调整窗口大小时重新计算宽高，设计稿按照 1600*900。
  if (isIOS) {
    /**
     * iOS
     */
    alert(
      `iOS 用户请横屏使用以获得最佳体验
| Please use landscape mode on iOS for the best experience
| iOS ユーザーは横画面での使用をお勧めします`,
    );
  }

  // 获得 userAnimation
  loadStyle(getGameAssetPath('userStyleSheet.css'));
  // 获得 user Animation
  getUserAnimation();
  // 获取游戏信息
  infoFetcher(getGameAssetPath('config.txt'));
  // 获取start场景
  const sceneUrl: string = assetSetter('start.txt', fileType.scene);
  // 场景写入到运行时
  sceneFetcher(sceneUrl).then((rawScene) => {
    WebGAL.sceneManager.sceneData.currentScene = sceneParser(rawScene, 'start.txt', sceneUrl);
    // 开始场景的预加载
    const subSceneList = WebGAL.sceneManager.sceneData.currentScene.subSceneList;
    WebGAL.sceneManager.settledScenes.push(sceneUrl); // 放入已加载场景列表，避免递归加载相同场景
    const subSceneListUniq = uniqWith(subSceneList); // 去重
    scenePrefetcher(subSceneListUniq);
  });
  /**
   * 启动Pixi
   */
  WebGAL.gameplay.pixiStage = new PixiStage();

  /**
   * iOS 设备 卸载所有 Service Worker
   */
  // if ('serviceWorker' in navigator && isIOS) {
  //   navigator.serviceWorker.getRegistrations().then((registrations) => {
  //     for (const registration of registrations) {
  //       registration.unregister().then(() => {
  //         logger.info('已卸载 Service Worker');
  //       });
  //     }
  //   });
  // }

  /**
   * 绑定工具函数
   */
  bindExtraFunc();
  webSocketFunc();
};

function loadStyle(url: string) {
  const link = document.createElement('link');
  link.type = 'text/css';
  link.rel = 'stylesheet';
  link.href = url;
  const head = document.getElementsByTagName('head')[0];
  head.appendChild(link);
}

function getUserAnimation() {
  axios.get(getGameAssetPath('animation/animationTable.json')).then((res) => {
    const animations: Array<string> = res.data;
    for (const animationName of animations) {
      axios.get(getGameAssetPath(`animation/${animationName}.json`)).then((res) => {
        if (res.data) {
          const userAnimation = {
            name: animationName,
            effects: res.data,
          };
          WebGAL.animationManager.addAnimation(userAnimation);
        }
      });
    }
  });
}



================================================
FILE: webgal/src/Core/live2DCore.ts
================================================
/** 眨眼参数，毫秒 */
export interface BlinkParam {
  blinkInterval: number; // 眨眼间隔
  blinkIntervalRandom: number; // 眨眼间隔随机范围
  closingDuration: number; // 闭眼
  closedDuration: number; // 保持闭眼
  openingDuration: number; // 睁眼
}

export const baseBlinkParam: BlinkParam = {
  blinkInterval: 24 * 60 * 60 * 1000, // 24小时
  blinkIntervalRandom: 1000,
  closingDuration: 100,
  closedDuration: 50,
  openingDuration: 150,
};

export interface FocusParam {
  x: number; // 焦点X位置
  y: number; // 焦点Y位置
  instant: boolean; // 是否瞬间切换焦点
}

export const baseFocusParam: FocusParam = {
  x: 0,
  y: 0,
  instant: false,
};

export class Live2DCore {
  public isAvailable = false;

  public Live2DModel: any;
  public SoundManager: any;
  public Config: any;

  // 临时记录未初始化前的数据
  // 旧版表情混合模式
  private _legacyExpressionBlendMode = false;
  public get legacyExpressionBlendMode() {
    return this._legacyExpressionBlendMode;
  }
  public set legacyExpressionBlendMode(value: boolean) {
    this._legacyExpressionBlendMode = value;
    if (this.isAvailable) {
      this.Config.legacyExpressionBlendMode = value;
    }
  }

  public constructor() {
    this.initLive2D();
  }

  public initLive2D() {
    // @ts-expect-error live2dPromise is a global variable
    (window.live2dPromise as Promise<[boolean, boolean]>)
      .then(async ([live2d2dAvailable, live2d4Available]) => {
        const _isAvailable = live2d2dAvailable && live2d4Available;
        if (!_isAvailable) {
          console.warn('live2d plugin load failed');
          return;
        }
        const { Live2DModel, SoundManager, config } = await import('pixi-live2d-display-webgal');
        this.Live2DModel = Live2DModel;
        this.SoundManager = SoundManager;
        this.Config = config;
        this.isAvailable = true;
        console.log('Live2D plugin load success');
        this.initConfig();
      })
      .catch((error) => {
        this.isAvailable = false;
        console.warn('Live2D plugin load failed', error);
      })
      .finally(() => {
        // @ts-expect-error live2dPromise is a global variable
        delete window.live2dPromise;
      });
  }

  /** 初始化配置 */
  private initConfig() {
    this.Config.legacyExpressionBlendMode = this._legacyExpressionBlendMode;
  }
}



================================================
FILE: webgal/src/Core/WebGAL.ts
================================================
import { WebgalCore } from '@/Core/webgalCore';
import { Live2DCore } from '@/Core/live2DCore';

export const WebGAL = new WebgalCore();
export const Live2D = new Live2DCore();

// 调试，不调试给去掉
// @ts-ignore
// window.WebGAL = WebGAL;



================================================
FILE: webgal/src/Core/webgalCore.ts
================================================
import { BacklogManager } from '@/Core/Modules/backlog';
import mitt from 'mitt';
import { SceneManager } from '@/Core/Modules/scene';
import { AnimationManager } from '@/Core/Modules/animations';
import { Gameplay } from './Modules/gamePlay';
import { Events } from '@/Core/Modules/events';

export class WebgalCore {
  public sceneManager = new SceneManager();
  public backlogManager = new BacklogManager(this.sceneManager);
  public animationManager = new AnimationManager();
  public gameplay = new Gameplay();
  public gameName = '';
  public gameKey = '';
  public events = new Events();
}



================================================
FILE: webgal/src/Core/controller/customUI/scss2cssinjsParser.ts
================================================
import { IWebGALStyleObj } from 'webgal-parser/build/types/styleParser';
import { WebgalParser } from '@/Core/parser/sceneParser';

export function scss2cssinjsParser(scssString: string): IWebGALStyleObj {
  return WebgalParser.parseScssToWebgalStyleObj(scssString);
}



================================================
FILE: webgal/src/Core/controller/gamePlay/autoPlay.ts
================================================
// import {logger} from '../../util/logger';
import styles from '@/UI/BottomControlPanel/bottomControlPanel.module.scss';
import { webgalStore } from '@/store/store';
import { nextSentence } from '@/Core/controller/gamePlay/nextSentence';

import { WebGAL } from '@/Core/WebGAL';

/**
 * 设置 autoplay 按钮的激活与否
 * @param on
 */
const setButton = (on: boolean) => {
  const autoIcon = document.getElementById('Button_ControlPanel_auto');
  if (autoIcon) {
    if (on) {
      autoIcon.className = styles.button_on;
    } else autoIcon.className = styles.singleButton;
  }
};

/**
 * 停止自动播放
 */
export const stopAuto = () => {
  WebGAL.gameplay.isAuto = false;
  setButton(false);
  if (WebGAL.gameplay.autoInterval !== null) {
    clearInterval(WebGAL.gameplay.autoInterval);
    WebGAL.gameplay.autoInterval = null;
  }
  if (WebGAL.gameplay.autoTimeout !== null) {
    clearTimeout(WebGAL.gameplay.autoTimeout);
    WebGAL.gameplay.autoTimeout = null;
  }
};

/**
 * 切换自动播放状态
 */
export const switchAuto = () => {
  // 现在正在自动播放
  if (WebGAL.gameplay.isAuto) {
    stopAuto();
  } else {
    // 当前不在自动播放
    WebGAL.gameplay.isAuto = true;
    setButton(true);
    WebGAL.gameplay.autoInterval = setInterval(autoPlay, 100);
  }
};

export const autoNextSentence = () => {
  nextSentence();
  WebGAL.gameplay.autoTimeout = null;
};

/**
 * 自动播放的执行函数
 */
const autoPlay = () => {
  const data = webgalStore.getState().userData.optionData.autoSpeed;
  // 范围为 [250, 1750]
  const autoPlayDelay = 250 + (100 - data) * 15;
  let isBlockingAuto = false;
  WebGAL.gameplay.performController.performList.forEach((e) => {
    if (e.blockingAuto())
      // 阻塞且没有结束的演出
      isBlockingAuto = true;
  });
  if (isBlockingAuto) {
    // 有阻塞，提前结束
    return;
  }
  // nextSentence();
  if (WebGAL.gameplay.autoTimeout === null) {
    WebGAL.gameplay.autoTimeout = setTimeout(autoNextSentence, autoPlayDelay);
  }
};



================================================
FILE: webgal/src/Core/controller/gamePlay/backToTitle.ts
================================================
import { webgalStore } from '@/store/store';
import { setStage } from '@/store/stageReducer';
import { setVisibility } from '@/store/GUIReducer';
import { stopAllPerform } from '@/Core/controller/gamePlay/stopAllPerform';
import { stopAuto } from '@/Core/controller/gamePlay/autoPlay';
import { stopFast } from '@/Core/controller/gamePlay/fastSkip';
import { setEbg } from '@/Core/gameScripts/changeBg/setEbg';

export const backToTitle = () => {
  if (webgalStore.getState().GUI.showTitle) return;
  const dispatch = webgalStore.dispatch;
  stopAllPerform();
  stopAuto();
  stopFast();
  // 清除语音
  dispatch(setStage({ key: 'playVocal', value: '' }));
  // 重新打开标题界面
  dispatch(setVisibility({ component: 'showTitle', visibility: true }));
  /**
   * 重设为标题背景
   */
  setEbg(webgalStore.getState().GUI.titleBg);
};



================================================
FILE: webgal/src/Core/controller/gamePlay/fastSkip.ts
================================================
// 切换自动播放状态
import { stopAuto } from './autoPlay';
import styles from '@/UI/BottomControlPanel/bottomControlPanel.module.scss';
import { nextSentence } from '@/Core/controller/gamePlay/nextSentence';

import { WebGAL } from '@/Core/WebGAL';
import { SYSTEM_CONFIG } from '@/config';

/**
 * 设置 fast 按钮的激活与否
 * @param on
 */
const setButton = (on: boolean) => {
  const autoIcon = document.getElementById('Button_ControlPanel_fast');
  if (autoIcon) {
    if (on) {
      autoIcon.className = styles.button_on;
    } else autoIcon.className = styles.singleButton;
  }
};

/**
 * 停止快进模式
 */
export const stopFast = () => {
  if (!isFast()) {
    return;
  }
  WebGAL.gameplay.isFast = false;
  setButton(false);
  if (WebGAL.gameplay.fastInterval !== null) {
    clearInterval(WebGAL.gameplay.fastInterval);
    WebGAL.gameplay.fastInterval = null;
  }
};

/**
 * 开启快进
 */
export const startFast = () => {
  if (isFast()) {
    return;
  }
  WebGAL.gameplay.isFast = true;
  setButton(true);
  WebGAL.gameplay.fastInterval = setInterval(() => {
    nextSentence();
  }, SYSTEM_CONFIG.fast_timeout);
};

// 判断是否是快进模式
export const isFast = function () {
  return WebGAL.gameplay.isFast;
};

/**
 * 停止快进模式与自动播放
 */
export const stopAll = () => {
  stopFast();
  stopAuto();
};

/**
 * 切换快进模式
 */
export const switchFast = () => {
  // 现在正在快进
  if (WebGAL.gameplay.isFast) {
    stopFast();
  } else {
    // 当前不在快进
    startFast();
  }
};



================================================
FILE: webgal/src/Core/controller/gamePlay/nextSentence.ts
================================================
import { scriptExecutor } from './scriptExecutor';
import { logger } from '../../util/logger';
import { webgalStore } from '@/store/store';
import { resetStageState } from '@/store/stageReducer';
import cloneDeep from 'lodash/cloneDeep';
import { IBacklogItem } from '@/Core/Modules/backlog';

import { SYSTEM_CONFIG } from '@/config';
import { WebGAL } from '@/Core/WebGAL';
import { IRunPerform } from '@/store/stageInterface';

/**
 * 进行下一句
 */
export const nextSentence = () => {
  /**
   * 发送 “发生点击下一句” 事件。
   */
  WebGAL.events.userInteractNext.emit();

  // 如果当前显示标题，那么不进行下一句
  const GUIState = webgalStore.getState().GUI;
  if (GUIState.showTitle) {
    return;
  }

  // 第一步，检查是否存在 blockNext 的演出
  let isBlockingNext = false;
  WebGAL.gameplay.performController.performList.forEach((e) => {
    if (e.blockingNext())
      // 阻塞且没有结束的演出
      isBlockingNext = true;
  });
  if (isBlockingNext) {
    // 有阻塞，提前结束
    logger.warn('next 被阻塞！');
    return;
  }

  // 检查是否处于演出完成状态，不是则结束所有普通演出（保持演出不算做普通演出）
  let allSettled = true;
  WebGAL.gameplay.performController.performList.forEach((e) => {
    if (!e.isHoldOn && !e.skipNextCollect) allSettled = false;
  });
  if (allSettled) {
    // 所有普通演出已经结束
    // if (WebGAL.backlogManager.isSaveBacklogNext) {
    //   WebGAL.backlogManager.isSaveBacklogNext = false;
    // }
    // 清除状态表的演出序列（因为这时候已经准备进行下一句了）
    const stageState = webgalStore.getState().stage;
    const newStageState = cloneDeep(stageState);
    for (let i = 0; i < newStageState.PerformList.length; i++) {
      const e: IRunPerform = newStageState.PerformList[i];
      if (!e.isHoldOn) {
        newStageState.PerformList.splice(i, 1);
        i--;
      }
    }
    webgalStore.dispatch(resetStageState(newStageState));
    scriptExecutor();
    return;
  }

  // 不处于 allSettled 状态，清除所有普通演出，强制进入settled。
  logger.debug('提前结束被触发，现在清除普通演出');
  let isGoNext = false;
  for (let i = 0; i < WebGAL.gameplay.performController.performList.length; i++) {
    const e = WebGAL.gameplay.performController.performList[i];
    if (!e.isHoldOn) {
      if (e.goNextWhenOver) {
        isGoNext = true;
      } // 先检查是不是要跳过收集
      if (!e.skipNextCollect) {
        // 由于提前结束使用的不是 unmountPerform 标准 API，所以不会触发两次 nextSentence
        e.stopFunction();
        clearTimeout(e.stopTimeout as unknown as number);
        WebGAL.gameplay.performController.performList.splice(i, 1);
        i--;
      }
    }
  }
  if (isGoNext) {
    // 由于不使用 unmountPerform 标准 API，这里需要手动收集一下 isGoNext
    nextSentence();
  }
};



================================================
FILE: webgal/src/Core/controller/gamePlay/runScript.ts
================================================
import { ISentence } from '@/Core/controller/scene/sceneInterface';
import { initPerform, IPerform } from '@/Core/Modules/perform/performInterface';

import { WebGAL } from '@/Core/WebGAL';
import { scriptRegistry, SCRIPT_TAG_MAP, ScriptFunction } from '@/Core/parser/sceneParser';

/**
 * 语句调用器，真正执行语句的调用，并自动将演出在指定时间卸载
 * @param script 调用的语句
 */
export const runScript = (script: ISentence) => {
  let perform: IPerform = initPerform;
  const funcToRun: ScriptFunction = scriptRegistry[script.command]?.scriptFunction ?? SCRIPT_TAG_MAP.say.scriptFunction; // 默认是say

  // 调用脚本对应的函数
  perform = funcToRun(script);

  if (perform.arrangePerformPromise) {
    perform.arrangePerformPromise.then((resolovedPerform) =>
      WebGAL.gameplay.performController.arrangeNewPerform(resolovedPerform, script),
    );
  } else {
    WebGAL.gameplay.performController.arrangeNewPerform(perform, script);
  }
};



================================================
FILE: webgal/src/Core/controller/gamePlay/scriptExecutor.ts
================================================
import { commandType, ISentence } from '@/Core/controller/scene/sceneInterface';
import { runScript } from './runScript';
import { logger } from '../../util/logger';
import { IStageState } from '@/store/stageInterface';
import { restoreScene } from '../scene/restoreScene';
import { webgalStore } from '@/store/store';
import { getValueFromStateElseKey } from '@/Core/gameScripts/setVar';
import { strIf } from '@/Core/controller/gamePlay/strIf';
import { nextSentence } from '@/Core/controller/gamePlay/nextSentence';
import cloneDeep from 'lodash/cloneDeep';
import { ISceneEntry } from '@/Core/Modules/scene';
import { IBacklogItem } from '@/Core/Modules/backlog';
import { SYSTEM_CONFIG } from '@/config';
import { WebGAL } from '@/Core/WebGAL';
import { getBooleanArgByKey, getStringArgByKey } from '@/Core/util/getSentenceArg';

export const whenChecker = (whenValue: string | undefined): boolean => {
  if (whenValue === undefined) {
    return true;
  }
  // 先把变量解析出来
  const valExpArr = whenValue.split(/([+\-*\/()><!]|>=|<=|==|&&|\|\||!=)/g);
  const valExp = valExpArr
    .map((e) => {
      if (e.match(/[a-zA-Z]/)) {
        if (e.match(/true/) || e.match(/false/)) {
          return e;
        }
        return getValueFromStateElseKey(e, true);
      } else return e;
    })
    .reduce((pre, curr) => pre + curr, '');
  return !!strIf(valExp);
};

/**
 * 语句执行器
 * 执行语句，同步场景状态，并根据情况立即执行下一句或者加入backlog
 */
export const scriptExecutor = () => {
  // 超过总语句数量，则从场景栈拿出一个需要继续的场景，然后继续流程。若场景栈清空，则停止流程
  if (
    WebGAL.sceneManager.sceneData.currentSentenceId >
    WebGAL.sceneManager.sceneData.currentScene.sentenceList.length - 1
  ) {
    if (WebGAL.sceneManager.sceneData.sceneStack.length !== 0) {
      const sceneToRestore: ISceneEntry | undefined = WebGAL.sceneManager.sceneData.sceneStack.pop();
      if (sceneToRestore !== undefined) {
        restoreScene(sceneToRestore);
      }
    }
    return;
  }
  const currentScript: ISentence = cloneDeep(
    WebGAL.sceneManager.sceneData.currentScene.sentenceList[WebGAL.sceneManager.sceneData.currentSentenceId],
  );

  const interpolationOneItem = (content: string): string => {
    let retContent = content;
    const contentExp = retContent.match(/(?<!\\)\{(.*?)\}/g);

    if (contentExp !== null) {
      contentExp.forEach((e) => {
        const contentVarValue = getValueFromStateElseKey(e.replace(/(?<!\\)\{(.*)\}/, '$1'));
        retContent = retContent.replace(e, contentVarValue);
      });
    }
    retContent = retContent.replace(/\\{/g, '{').replace(/\\}/g, '}');
    return retContent;
  };

  /**
   * Variable interpolation
   */
  const variableInterpolation = () => {
    currentScript.content = interpolationOneItem(currentScript.content);

    currentScript.args.forEach((arg) => {
      if (arg.value && typeof arg.value === 'string') {
        arg.value = interpolationOneItem(arg.value);
      }
    });
  };

  variableInterpolation();

  // 判断这个脚本要不要执行
  let runThis = true;
  let whenValue = getStringArgByKey(currentScript, 'when');
  // 如果语句有 when
  if (whenValue) {
    runThis = whenChecker(whenValue);
  }

  // 执行语句
  if (!runThis) {
    logger.warn('不满足条件，跳过本句！');
    WebGAL.sceneManager.sceneData.currentSentenceId++;
    nextSentence();
    return;
  }
  runScript(currentScript);
  // 是否要进行下一句
  let isNext = getBooleanArgByKey(currentScript, 'next') ?? false;

  let isSaveBacklog = currentScript.command === commandType.say; // 是否在本句保存backlog（一般遇到对话保存）
  // 检查当前对话是否有 notend 参数
  const hasNotEnd = getBooleanArgByKey(currentScript, 'notend') ?? false;
  isSaveBacklog = isSaveBacklog && !hasNotEnd;

  let currentStageState: IStageState;

  // 执行至指定 sentenceID
  // if (runToSentence >= 0 && runtime_currentSceneData.currentSentenceId < runToSentence) {
  //   runtime_currentSceneData.currentSentenceId++;
  //   scriptExecutor(runToSentence);
  //   return;
  // }

  // 执行“下一句”
  if (isNext) {
    WebGAL.sceneManager.sceneData.currentSentenceId++;
    scriptExecutor();
    return;
  }

  /**
   * 为了让 backlog 拿到连续执行了多条语句后正确的数据，放到下一个宏任务中执行（我也不知道为什么这样能正常，有能力的可以研究一下
   */
  setTimeout(() => {
    // 同步当前舞台数据
    currentStageState = webgalStore.getState().stage;
    const allState = {
      currentStageState: currentStageState,
      globalGameVar: webgalStore.getState().userData.globalGameVar,
    };
    logger.debug('本条语句执行结果', allState);
    // 保存 backlog
    if (isSaveBacklog) {
      // WebGAL.backlogManager.isSaveBacklogNext = true;
      WebGAL.backlogManager.saveCurrentStateToBacklog();
    }
  }, 0);
  WebGAL.sceneManager.sceneData.currentSentenceId++;
};



================================================
FILE: webgal/src/Core/controller/gamePlay/startContinueGame.ts
================================================
import { assetSetter, fileType } from '../../util/gameAssetsAccess/assetSetter';
import { sceneFetcher } from '../scene/sceneFetcher';
import { sceneParser } from '../../parser/sceneParser';
import { resetStage } from '@/Core/controller/stage/resetStage';
import { webgalStore } from '@/store/store';
import { setVisibility } from '@/store/GUIReducer';
import { nextSentence } from '@/Core/controller/gamePlay/nextSentence';
import { setEbg } from '@/Core/gameScripts/changeBg/setEbg';
import { restorePerform } from '@/Core/controller/storage/jumpFromBacklog';

import { hasFastSaveRecord, loadFastSaveGame } from '@/Core/controller/storage/fastSaveLoad';
import { WebGAL } from '@/Core/WebGAL';

/**
 * 从头开始游戏
 */
export const startGame = () => {
  resetStage(true);

  // 重新获取初始场景
  const sceneUrl: string = assetSetter('start.txt', fileType.scene);
  // 场景写入到运行时
  sceneFetcher(sceneUrl).then((rawScene) => {
    WebGAL.sceneManager.sceneData.currentScene = sceneParser(rawScene, 'start.txt', sceneUrl);
    // 开始第一条语句
    nextSentence();
  });
  webgalStore.dispatch(setVisibility({ component: 'showTitle', visibility: false }));
};

export async function continueGame() {
  /**
   * 重设模糊背景
   */
  setEbg(webgalStore.getState().stage.bgName);
  // 当且仅当游戏未开始时使用快速存档
  // 当游戏开始后 使用原来的逻辑
  if ((await hasFastSaveRecord()) && WebGAL.sceneManager.sceneData.currentSentenceId === 0) {
    // 恢复记录
    await loadFastSaveGame();
    return;
  }
  if (
    WebGAL.sceneManager.sceneData.currentSentenceId === 0 &&
    WebGAL.sceneManager.sceneData.currentScene.sceneName === 'start.txt'
  ) {
    // 如果游戏没有开始，开始游戏
    nextSentence();
  } else {
    restorePerform();
  }
}



================================================
FILE: webgal/src/Core/controller/gamePlay/stopAllPerform.ts
================================================
import { logger } from '@/Core/util/logger';

import { WebGAL } from '@/Core/WebGAL';

export const stopAllPerform = () => {
  logger.warn('清除所有演出');
  for (let i = 0; i < WebGAL.gameplay.performController.performList.length; i++) {
    const e = WebGAL.gameplay.performController.performList[i];
    e.stopFunction();
    clearTimeout(e.stopTimeout as unknown as number);
    WebGAL.gameplay.performController.performList.splice(i, 1);
    i--;
  }
};



================================================
FILE: webgal/src/Core/controller/gamePlay/strIf.ts
================================================
import { compile } from 'angular-expressions';

export function strIf(s: string) {
  try {
    const res = compile(s);
    return res();
  } catch {
    return false;
  }
}



================================================
FILE: webgal/src/Core/controller/scene/callScene.ts
================================================
import { sceneFetcher } from './sceneFetcher';
import { sceneParser } from '../../parser/sceneParser';
import { logger } from '../../util/logger';
import { nextSentence } from '@/Core/controller/gamePlay/nextSentence';
import uniqWith from 'lodash/uniqWith';
import { scenePrefetcher } from '@/Core/util/prefetcher/scenePrefetcher';

import { WebGAL } from '@/Core/WebGAL';

/**
 * 调用场景
 * @param sceneUrl 场景路径
 * @param sceneName 场景名称
 */
export const callScene = (sceneUrl: string, sceneName: string) => {
  if (WebGAL.sceneManager.lockSceneWrite) {
    return;
  }
  WebGAL.sceneManager.lockSceneWrite = true;
  // 先将本场景压入场景栈
  WebGAL.sceneManager.sceneData.sceneStack.push({
    sceneName: WebGAL.sceneManager.sceneData.currentScene.sceneName,
    sceneUrl: WebGAL.sceneManager.sceneData.currentScene.sceneUrl,
    continueLine: WebGAL.sceneManager.sceneData.currentSentenceId,
  });
  // 场景写入到运行时
  sceneFetcher(sceneUrl)
    .then((rawScene) => {
      WebGAL.sceneManager.sceneData.currentScene = sceneParser(rawScene, sceneName, sceneUrl);
      WebGAL.sceneManager.sceneData.currentSentenceId = 0;
      // 开始场景的预加载
      const subSceneList = WebGAL.sceneManager.sceneData.currentScene.subSceneList;
      WebGAL.sceneManager.settledScenes.push(sceneUrl); // 放入已加载场景列表，避免递归加载相同场景
      const subSceneListUniq = uniqWith(subSceneList); // 去重
      scenePrefetcher(subSceneListUniq);
      logger.debug('现在调用场景，调用结果：', WebGAL.sceneManager.sceneData);
      WebGAL.sceneManager.lockSceneWrite = false;
      nextSentence();
    })
    .catch((e) => {
      logger.error('场景调用错误', e);
      WebGAL.sceneManager.lockSceneWrite = false;
    });
};



================================================
FILE: webgal/src/Core/controller/scene/changeScene.ts
================================================
import { sceneFetcher } from './sceneFetcher';
import { sceneParser } from '../../parser/sceneParser';
import { logger } from '../../util/logger';
import { nextSentence } from '@/Core/controller/gamePlay/nextSentence';
import uniqWith from 'lodash/uniqWith';
import { scenePrefetcher } from '@/Core/util/prefetcher/scenePrefetcher';

import { WebGAL } from '@/Core/WebGAL';

/**
 * 切换场景
 * @param sceneUrl 场景路径
 * @param sceneName 场景名称
 */
export const changeScene = (sceneUrl: string, sceneName: string) => {
  if (WebGAL.sceneManager.lockSceneWrite) {
    return;
  }
  WebGAL.sceneManager.lockSceneWrite = true;
  // 场景写入到运行时
  sceneFetcher(sceneUrl)
    .then((rawScene) => {
      WebGAL.sceneManager.sceneData.currentScene = sceneParser(rawScene, sceneName, sceneUrl);
      WebGAL.sceneManager.sceneData.currentSentenceId = 0;
      // 开始场景的预加载
      const subSceneList = WebGAL.sceneManager.sceneData.currentScene.subSceneList;
      WebGAL.sceneManager.settledScenes.push(sceneUrl); // 放入已加载场景列表，避免递归加载相同场景
      const subSceneListUniq = uniqWith(subSceneList); // 去重
      scenePrefetcher(subSceneListUniq);
      logger.debug('现在切换场景，切换后的结果：', WebGAL.sceneManager.sceneData);
      WebGAL.sceneManager.lockSceneWrite = false;
      nextSentence();
    })
    .catch((e) => {
      logger.error('场景调用错误', e);
      WebGAL.sceneManager.lockSceneWrite = false;
    });
};



================================================
FILE: webgal/src/Core/controller/scene/restoreScene.ts
================================================
import { sceneFetcher } from './sceneFetcher';
import { sceneParser } from '../../parser/sceneParser';
import { logger } from '../../util/logger';
import { nextSentence } from '@/Core/controller/gamePlay/nextSentence';
import { ISceneEntry } from '@/Core/Modules/scene';

import { WebGAL } from '@/Core/WebGAL';

/**
 * 恢复场景
 * @param entry 场景入口
 */
export const restoreScene = (entry: ISceneEntry) => {
  if (WebGAL.sceneManager.lockSceneWrite) {
    return;
  }
  WebGAL.sceneManager.lockSceneWrite = true;
  // 场景写入到运行时
  sceneFetcher(entry.sceneUrl)
    .then((rawScene) => {
      WebGAL.sceneManager.sceneData.currentScene = sceneParser(rawScene, entry.sceneName, entry.sceneUrl);
      WebGAL.sceneManager.sceneData.currentSentenceId = entry.continueLine + 1; // 重设场景
      logger.debug('现在恢复场景，恢复后场景：', WebGAL.sceneManager.sceneData.currentScene);
      WebGAL.sceneManager.lockSceneWrite = false;
      nextSentence();
    })
    .catch((e) => {
      logger.error('场景调用错误', e);
      WebGAL.sceneManager.lockSceneWrite = false;
    });
};



================================================
FILE: webgal/src/Core/controller/scene/sceneFetcher.ts
================================================
import axios from 'axios';

/**
 * 原始场景文件获取函数
 * @param sceneUrl 场景文件路径
 */
export const sceneFetcher = (sceneUrl: string) => {
  return new Promise<string>((resolve, reject) => {
    axios
      .get(sceneUrl)
      .then((response) => {
        const rawScene: string = response.data.toString();
        resolve(rawScene);
      })
      .catch((e) => {
        reject(e);
      });
  });
};



================================================
FILE: webgal/src/Core/controller/scene/sceneInterface.ts
================================================
/**
 * 语句类型
 */
import { fileType } from '@/Core/util/gameAssetsAccess/assetSetter';
import { ISceneEntry } from '@/Core/Modules/scene';

export enum commandType {
  say, // 对话
  changeBg, // 更改背景
  changeFigure, // 更改立绘
  bgm, // 更改背景音乐
  video, // 播放视频
  pixi, // pixi演出
  pixiInit, // pixi初始化
  intro, // 黑屏文字演示
  miniAvatar, // 小头像
  changeScene, // 切换场景
  choose, // 分支选择
  end, // 结束游戏
  setComplexAnimation, // 动画演出
  setFilter, // 设置效果
  label, // 标签
  jumpLabel, // 跳转标签
  chooseLabel, // 选择标签
  setVar, // 设置变量
  if, // 条件跳转
  callScene, // 调用场景
  showVars,
  unlockCg,
  unlockBgm,
  filmMode,
  setTextbox,
  setAnimation,
  playEffect,
  setTempAnimation,
  comment,
  setTransform,
  setTransition,
  getUserInput,
  applyStyle,
  wait,
}

/**
 * 单个参数接口
 * @interface arg
 */
export interface arg {
  key: string; // 参数键
  value: string | boolean | number; // 参数值
}

/**
 * 资源接口
 * @interface IAsset
 */
export interface IAsset {
  name: string; // 资源名称
  type: fileType; // 资源类型
  url: string; // 资源url
  lineNumber: number; // 触发资源语句的行号
}

/**
 * 单条语句接口
 * @interface ISentence
 */
export interface ISentence {
  command: commandType; // 语句类型
  commandRaw: string; // 命令的原始内容，方便调试
  content: string; // 语句内容
  args: Array<arg>; // 参数列表
  sentenceAssets: Array<IAsset>; // 语句携带的资源列表
  subScene: Array<string>; // 语句包含子场景列表
}

/**
 * 场景接口
 * @interface IScene
 */
export interface IScene {
  sceneName: string; // 场景名称
  sceneUrl: string; // 场景url
  sentenceList: Array<ISentence>; // 语句列表
  assetsList: Array<IAsset>; // 资源列表
  subSceneList: Array<string>; // 子场景的url列表
}

/**
 * 当前的场景数据
 * @interface ISceneData
 */
export interface ISceneData {
  currentSentenceId: number; // 当前语句ID
  sceneStack: Array<ISceneEntry>; // 场景栈
  currentScene: IScene; // 当前场景数据
}

/**
 * 处理后的命令接口
 * @interface parsedCommand
 */
export interface parsedCommand {
  type: commandType;
  additionalArgs: Array<arg>;
}



================================================
FILE: webgal/src/Core/controller/stage/playBgm.ts
================================================
import { webgalStore } from '@/store/store';
import { setStage } from '@/store/stageReducer';
import { logger } from '@/Core/util/logger';

// /**
//  * 停止bgm
//  */
// export const eraseBgm = () => {
//   logger.debug(`停止bgm`);
//   // 停止之前的bgm
//   let VocalControl: any = document.getElementById('currentBgm');
//   if (VocalControl !== null) {
//     VocalControl.currentTime = 0;
//     if (!VocalControl.paused) VocalControl.pause();
//   }
//   // 获得舞台状态并设置
//   webgalStore.dispatch(setStage({key: 'bgm', value: ''}));
// };

let emptyBgmTimeout: ReturnType<typeof setTimeout>;

/**
 * 播放bgm
 * @param url bgm路径
 * @param enter 淡入时间（单位毫秒）
 * @param volume 背景音乐 音量调整（0 - 100）
 */
export function playBgm(url: string, enter = 0, volume = 100): void {
  logger.debug('playing bgm' + url);
  if (url === '') {
    emptyBgmTimeout = setTimeout(() => {
      // 淡入淡出效果结束后，将 bgm 置空
      webgalStore.dispatch(setStage({ key: 'bgm', value: { src: '', enter: 0, volume: 100 } }));
    }, enter);
    const lastSrc = webgalStore.getState().stage.bgm.src;
    webgalStore.dispatch(setStage({ key: 'bgm', value: { src: lastSrc, enter: -enter, volume: volume } }));
  } else {
    // 不要清除bgm了！
    clearTimeout(emptyBgmTimeout);
    webgalStore.dispatch(setStage({ key: 'bgm', value: { src: url, enter: enter, volume: volume } }));
  }
  setTimeout(() => {
    const audioElement = document.getElementById('currentBgm') as HTMLAudioElement;
    if (audioElement.src) {
      audioElement?.play();
    }
  }, 0);
}



================================================
FILE: webgal/src/Core/controller/stage/resetStage.ts
================================================
import { initState, resetStageState, setStage } from '@/store/stageReducer';
import { webgalStore } from '@/store/store';
import cloneDeep from 'lodash/cloneDeep';
import { WebGAL } from '@/Core/WebGAL';

export const resetStage = (resetBacklog: boolean, resetSceneAndVar = true) => {
  /**
   * 清空运行时
   */
  if (resetBacklog) {
    WebGAL.backlogManager.makeBacklogEmpty();
  }
  // 清空sceneData，并重新获取
  if (resetSceneAndVar) {
    WebGAL.sceneManager.resetScene();
  }

  // 清空所有演出和timeOut
  WebGAL.gameplay.pixiStage?.removeAllAnimations();
  WebGAL.gameplay.performController.removeAllPerform();
  WebGAL.gameplay.resetGamePlay();

  // 清空舞台状态表
  const initSceneDataCopy = cloneDeep(initState);
  const currentVars = webgalStore.getState().stage.GameVar;
  webgalStore.dispatch(resetStageState(initSceneDataCopy));
  if (!resetSceneAndVar) {
    webgalStore.dispatch(setStage({ key: 'GameVar', value: currentVars }));
  }
};



================================================
FILE: webgal/src/Core/controller/stage/setVolume.ts
================================================
import { logger } from '../../util/logger';
import { webgalStore } from '@/store/store';

/**
 * 设置音量
 */
export const setVolume = () => {
  const userDataState = webgalStore.getState().userData;
  const mainVol = userDataState.optionData.volumeMain;
  const vocalVol = mainVol * 0.01 * userDataState.optionData.vocalVolume * 0.01;
  const bgmVol = mainVol * 0.01 * userDataState.optionData.bgmVolume * 0.01;
  logger.debug(`设置背景音量：${bgmVol},语音音量：${vocalVol}`);
  // const bgmElement: any = document.getElementById('currentBgm');
  // if (bgmElement) {
  //   bgmElement.volume = bgmVol.toString();
  // }
  // const vocalElement: any = document.getElementById('currentVocal');
  // if (vocalElement) {
  //   vocalElement.volume = vocalVol.toString();
  // }
};



================================================
FILE: webgal/src/Core/controller/stage/pixi/PixiController.ts
================================================
import { webgalStore } from '@/store/store';
import { IEffect, IFigureAssociatedAnimation, IFigureMetadata, ITransform } from '@/store/stageInterface';
import { setStage, stageActions } from '@/store/stageReducer';
import { Live2D, WebGAL } from '@/Core/WebGAL';
import { baseBlinkParam, baseFocusParam, BlinkParam, FocusParam } from '@/Core/live2DCore';
import { isIOS } from '@/Core/initializeScript';
import { WebGALPixiContainer } from '@/Core/controller/stage/pixi/WebGALPixiContainer';
import { addSpineBgImpl, addSpineFigureImpl } from '@/Core/controller/stage/pixi/spine';
import { SCREEN_CONSTANTS } from '@/Core/util/constants';
import { logger } from '@/Core/util/logger';
import { v4 as uuid } from 'uuid';
import { cloneDeep, isEqual } from 'lodash';
import * as PIXI from 'pixi.js';

export interface IAnimationObject {
  setStartState: Function;
  setEndState: Function;
  tickerFunc: PIXI.TickerCallback<number>;
  getEndStateEffect?: Function;
  forceStopWithoutSetEndState?: Function;
}

interface IStageAnimationObject {
  // 唯一标识
  uuid: string;
  // 一般与作用目标有关
  key: string;
  targetKey?: string;
  type: 'common' | 'preset';
  animationObject: IAnimationObject;
}

export interface IStageObject {
  // 唯一标识
  uuid: string;
  // 一般与作用目标有关
  key: string;
  pixiContainer: WebGALPixiContainer | null;
  // 相关的源 url
  sourceUrl: string;
  sourceExt: string;
  sourceType: 'img' | 'live2d' | 'spine' | 'gif' | 'video' | 'stage';
  spineAnimation?: string;
  isExiting?: boolean;
}

export interface ILive2DRecord {
  target: string;
  motion: string;
  expression: string;
  blink: BlinkParam;
  focus: FocusParam;
}

// export interface IRegisterTickerOpr {
//   tickerGeneratorFn: (targetKey: string, duration: number) => PIXI.TickerCallback<number>;
//   key: string;
//   target: string;
//   duration: number;
// }

// @ts-ignore
window.PIXI = PIXI;

export default class PixiStage {
  public static assignTransform<T extends ITransform>(target: T, source?: ITransform) {
    if (!source) return;
    const targetScale = target.scale;
    const targetPosition = target.position;
    if (target.scale) Object.assign(targetScale, source.scale);
    if (target.position) Object.assign(targetPosition, source.position);
    Object.assign(target, source);
    target.scale = targetScale;
    target.position = targetPosition;
  }

  /**
   * 当前的 PIXI App
   */
  public currentApp: PIXI.Application | null = null;
  public readonly mainStageContainer: WebGALPixiContainer;
  public readonly foregroundEffectsContainer: PIXI.Container;
  public readonly backgroundEffectsContainer: PIXI.Container;
  public frameDuration = 16.67;
  public notUpdateBacklogEffects = false;
  public readonly figureContainer: PIXI.Container;
  public figureObjects: Array<IStageObject> = [];
  public stageWidth = SCREEN_CONSTANTS.width;
  public stageHeight = SCREEN_CONSTANTS.height;
  public assetLoader = new PIXI.Loader();
  public readonly backgroundContainer: PIXI.Container;
  public backgroundObjects: Array<IStageObject> = [];
  public mainStageObject: IStageObject;
  /**
   * 添加 Spine 立绘
   * @param key 立绘的标识，一般和立绘位置有关
   * @param url 立绘图片url
   * @param presetPosition
   */
  public addSpineFigure = addSpineFigureImpl.bind(this);
  public addSpineBg = addSpineBgImpl.bind(this);
  // 注册到 Ticker 上的函数
  private stageAnimations: Array<IStageAnimationObject> = [];
  private loadQueue: { url: string; callback: () => void; name?: string }[] = [];
  private live2dFigureRecorder: Array<ILive2DRecord> = [];
  // 锁定变换对象（对象可能正在执行动画，不能应用变换）
  private lockTransformTarget: Array<string> = [];

  /**
   * 暂时没用上，以后可能用
   * @private
   */
  private MAX_TEX_COUNT = 10;

  private figureCash: any;
  public constructor() {
    const app = new PIXI.Application({
      backgroundAlpha: 0,
      preserveDrawingBuffer: true,
    });
    // @ts-ignore

    window.PIXIapp = this; // @ts-ignore
    window.__PIXI_APP__ = app;
    // 清空原节点
    const pixiContainer = document.getElementById('pixiContianer');
    if (pixiContainer) {
      pixiContainer.innerHTML = '';
      pixiContainer.appendChild(app.view);
    }

    // 设置样式
    app.renderer.view.style.position = 'absolute';
    app.renderer.view.style.display = 'block';
    app.renderer.view.id = 'pixiCanvas';
    // @ts-ignore
    app.renderer.autoResize = true;
    const appRoot = document.getElementById('root');
    if (appRoot) {
      app.renderer.resize(appRoot.clientWidth, appRoot.clientHeight);
    }
    if (isIOS) {
      app.renderer.view.style.zIndex = '-5';
    }

    // 添加主舞台容器
    this.mainStageContainer = new WebGALPixiContainer();
    // 设置可排序
    this.mainStageContainer.sortableChildren = true;
    this.mainStageContainer.setBaseX(this.stageWidth / 2);
    this.mainStageContainer.setBaseY(this.stageHeight / 2);
    this.mainStageContainer.pivot.set(this.stageWidth / 2, this.stageHeight / 2);
    app.stage.addChild(this.mainStageContainer);

    this.mainStageObject = {
      uuid: uuid(),
      key: 'stage-main',
      pixiContainer: this.mainStageContainer,
      sourceUrl: '',
      sourceType: 'stage',
      sourceExt: '',
    };

    // 添加 4 个 Container 用于做渲染
    this.foregroundEffectsContainer = new PIXI.Container(); // 前景特效
    this.foregroundEffectsContainer.zIndex = 3;
    this.figureContainer = new PIXI.Container();
    this.figureContainer.sortableChildren = true; // 允许立绘启用 z-index
    this.figureContainer.zIndex = 2;
    this.backgroundEffectsContainer = new PIXI.Container(); // 背景特效
    this.backgroundEffectsContainer.zIndex = 1;
    this.backgroundContainer = new PIXI.Container();
    this.backgroundContainer.zIndex = 0;
    this.mainStageContainer.addChild(
      this.foregroundEffectsContainer,
      this.figureContainer,
      this.backgroundEffectsContainer,
      this.backgroundContainer,
    );
    this.currentApp = app;
    // 每 5s 获取帧率，并且防 loader 死
    const update = () => {
      this.updateFps();
      setTimeout(update, 10000);
    };
    update();
    // loader 防死
    const reload = () => {
      setTimeout(reload, 500);
      this.callLoader();
    };
    reload();
    this.initialize().then(() => {});
  }

  public getFigureObjects() {
    return this.figureObjects;
  }

  public getAllLockedObject() {
    return this.lockTransformTarget;
  }

  /**
   * 注册动画
   * @param animationObject
   * @param key
   * @param target
   */
  public registerAnimation(animationObject: IAnimationObject | null, key: string, target = 'default') {
    if (!animationObject) return;
    this.stageAnimations.push({ uuid: uuid(), animationObject, key: key, targetKey: target, type: 'common' });
    // 上锁
    this.lockStageObject(target);
    animationObject.setStartState();
    this.currentApp?.ticker.add(animationObject.tickerFunc);
  }

  /**
   * 注册预设动画
   * @param animationObject
   * @param key
   * @param target
   * @param currentEffects
   */
  // eslint-disable-next-line max-params
  public registerPresetAnimation(
    animationObject: IAnimationObject | null,
    key: string,
    target = 'default',
    currentEffects: IEffect[],
  ) {
    if (!animationObject) return;
    const effect = currentEffects.find((effect) => effect.target === target);
    if (effect) {
      const targetPixiContainer = this.getStageObjByKey(target);
      if (targetPixiContainer) {
        const container = targetPixiContainer.pixiContainer;
        if (container) PixiStage.assignTransform(container, effect.transform);
      }
      return;
    }
    this.stageAnimations.push({ uuid: uuid(), animationObject, key: key, targetKey: target, type: 'preset' });
    // 上锁
    this.lockStageObject(target);
    animationObject.setStartState();
    this.currentApp?.ticker.add(animationObject.tickerFunc);
  }

  public stopPresetAnimationOnTarget(target: string) {
    const targetPresetAnimations = this.stageAnimations.find((e) => e.targetKey === target && e.type === 'preset');
    if (targetPresetAnimations) {
      this.removeAnimation(targetPresetAnimations.key);
    }
  }

  /**
   * 移除动画
   * @param key
   */
  public removeAnimationByIndex(index: number) {
    if (index >= 0) {
      const thisTickerFunc = this.stageAnimations[index];
      this.currentApp?.ticker.remove(thisTickerFunc.animationObject.tickerFunc);
      thisTickerFunc.animationObject.setEndState();
      this.unlockStageObject(thisTickerFunc.targetKey ?? 'default');
      this.stageAnimations.splice(index, 1);
    }
  }

  public removeAnimationWithoutSetEndState(key: string) {
    const index = this.stageAnimations.findIndex((e) => e.key === key);
    if (index >= 0) {
      const thisTickerFunc = this.stageAnimations[index];
      this.currentApp?.ticker.remove(thisTickerFunc.animationObject.tickerFunc);
      if (thisTickerFunc.animationObject.forceStopWithoutSetEndState) {
        thisTickerFunc.animationObject.forceStopWithoutSetEndState();
      }
      this.unlockStageObject(thisTickerFunc.targetKey ?? 'default');
      this.stageAnimations.splice(index, 1);
    }
  }

  public removeAllAnimations() {
    while (this.stageAnimations.length > 0) {
      this.removeAnimationByIndex(0);
    }
  }

  public removeAnimation(key: string) {
    const index = this.stageAnimations.findIndex((e) => e.key === key);
    this.removeAnimationByIndex(index);
  }

  public removeAnimationWithSetEffects(key: string) {
    const index = this.stageAnimations.findIndex((e) => e.key === key);
    if (index >= 0) {
      const thisTickerFunc = this.stageAnimations[index];
      this.currentApp?.ticker.remove(thisTickerFunc.animationObject.tickerFunc);
      thisTickerFunc.animationObject.setEndState();
      const endStateEffect = thisTickerFunc.animationObject.getEndStateEffect?.() ?? {};
      this.unlockStageObject(thisTickerFunc.targetKey ?? 'default');
      if (thisTickerFunc.targetKey) {
        const target = this.getStageObjByKey(thisTickerFunc.targetKey);
        if (target) {
          let effect: IEffect = {
            target: thisTickerFunc.targetKey,
            transform: endStateEffect,
          };
          webgalStore.dispatch(stageActions.updateEffect(effect));
          // if (!this.notUpdateBacklogEffects) updateCurrentBacklogEffects(webgalStore.getState().stage.effects);
        }
      }
      this.stageAnimations.splice(index, 1);
    }
  }

  // eslint-disable-next-line max-params
  public performMouthSyncAnimation(
    key: string,
    targetAnimation: IFigureAssociatedAnimation,
    mouthState: string,
    presetPosition: string,
  ) {
    const currentFigure = this.getStageObjByKey(key)?.pixiContainer as WebGALPixiContainer;

    if (!currentFigure) {
      return;
    }

    const mouthTextureUrls: any = {
      open: targetAnimation.mouthAnimation.open,
      half_open: targetAnimation.mouthAnimation.halfOpen,
      closed: targetAnimation.mouthAnimation.close,
    };

    // Load mouth texture (reuse if already loaded)
    this.loadAsset(mouthTextureUrls[mouthState], () => {
      const texture = this.assetLoader.resources[mouthTextureUrls[mouthState]].texture;
      const sprite = currentFigure?.children?.[0] as PIXI.Sprite;
      if (!texture || !sprite) {
        return;
      }
      sprite.texture = texture;
    });
  }

  // eslint-disable-next-line max-params
  public performBlinkAnimation(
    key: string,
    targetAnimation: IFigureAssociatedAnimation,
    blinkState: string,
    presetPosition: string,
  ) {
    const currentFigure = this.getStageObjByKey(key)?.pixiContainer as WebGALPixiContainer;

    if (!currentFigure) {
      return;
    }
    const blinkTextureUrls: any = {
      open: targetAnimation.blinkAnimation.open,
      closed: targetAnimation.blinkAnimation.close,
    };

    // Load eye texture (reuse if already loaded)
    this.loadAsset(blinkTextureUrls[blinkState], () => {
      const texture = this.assetLoader.resources[blinkTextureUrls[blinkState]].texture;
      const sprite = currentFigure?.children?.[0] as PIXI.Sprite;
      if (!texture || !sprite) {
        return;
      }
      sprite.texture = texture;
    });
  }

  /**
   * 添加背景
   * @param key 背景的标识，一般和背景类型有关
   * @param url 背景图片url
   */
  public addBg(key: string, url: string) {
    // const loader = this.assetLoader;
    const loader = this.assetLoader;
    // 准备用于存放这个背景的 Container
    const thisBgContainer = new WebGALPixiContainer();

    // 是否有相同 key 的背景
    const setBgIndex = this.backgroundObjects.findIndex((e) => e.key === key);
    const isBgSet = setBgIndex >= 0;

    // 已经有一个这个 key 的背景存在了
    if (isBgSet) {
      // 挤占
      this.removeStageObjectByKey(key);
    }

    // 挂载
    this.backgroundContainer.addChild(thisBgContainer);
    const bgUuid = uuid();
    this.backgroundObjects.push({
      uuid: bgUuid,
      key: key,
      pixiContainer: thisBgContainer,
      sourceUrl: url,
      sourceType: 'img',
      sourceExt: this.getExtName(url),
    });

    // 完成图片加载后执行的函数
    const setup = () => {
      // TODO：找一个更好的解法，现在的解法是无论是否复用原来的资源，都设置一个延时以让动画工作正常！

      setTimeout(() => {
        const texture = loader.resources?.[url]?.texture;
        if (texture && this.getStageObjByUuid(bgUuid)) {
          /**
           * 重设大小
           */
          const originalWidth = texture.width;
          const originalHeight = texture.height;
          const scaleX = this.stageWidth / originalWidth;
          const scaleY = this.stageHeight / originalHeight;
          const targetScale = Math.max(scaleX, scaleY);
          const bgSprite = new PIXI.Sprite(texture);
          bgSprite.scale.x = targetScale;
          bgSprite.scale.y = targetScale;
          bgSprite.anchor.set(0.5);
          bgSprite.position.y = this.stageHeight / 2;
          thisBgContainer.setBaseX(this.stageWidth / 2);
          thisBgContainer.setBaseY(this.stageHeight / 2);
          thisBgContainer.pivot.set(0, this.stageHeight / 2);

          // 挂载
          thisBgContainer.addChild(bgSprite);
        }
      }, 0);
    };

    /**
     * 加载器部分
     */
    this.cacheGC();
    if (!loader.resources?.[url]?.texture) {
      this.loadAsset(url, setup);
    } else {
      // 复用
      setup();
    }
  }

  /**
   * 添加视频背景
   * @param key 背景的标识，一般和背景类型有关
   * @param url 背景图片url
   */
  public addVideoBg(key: string, url: string) {
    const loader = this.assetLoader;
    // 准备用于存放这个背景的 Container
    const thisBgContainer = new WebGALPixiContainer();

    // 是否有相同 key 的背景
    const setBgIndex = this.backgroundObjects.findIndex((e) => e.key === key);
    const isBgSet = setBgIndex >= 0;

    // 已经有一个这个 key 的背景存在了
    if (isBgSet) {
      // 挤占
      this.removeStageObjectByKey(key);
    }

    // 挂载
    this.backgroundContainer.addChild(thisBgContainer);
    const bgUuid = uuid();
    this.backgroundObjects.push({
      uuid: bgUuid,
      key: key,
      pixiContainer: thisBgContainer,
      sourceUrl: url,
      sourceType: 'video',
      sourceExt: this.getExtName(url),
    });

    // 完成加载后执行的函数
    const setup = () => {
      // TODO：找一个更好的解法，现在的解法是无论是否复用原来的资源，都设置一个延时以让动画工作正常！

      setTimeout(() => {
        console.debug('start loaded video: ' + url);
        const video = document.createElement('video');
        const videoResource = new PIXI.VideoResource(video);
        videoResource.src = url;
        videoResource.source.preload = 'auto';
        videoResource.source.muted = true;
        videoResource.source.loop = true;
        videoResource.source.autoplay = true;
        videoResource.source.src = url;
        // @ts-ignore
        const texture = PIXI.Texture.from(videoResource);
        if (texture && this.getStageObjByUuid(bgUuid)) {
          /**
           * 重设大小
           */
          texture.baseTexture.resource.load().then(() => {
            const originalWidth = videoResource.source.videoWidth;
            const originalHeight = videoResource.source.videoHeight;
            const scaleX = this.stageWidth / originalWidth;
            const scaleY = this.stageHeight / originalHeight;
            const targetScale = Math.max(scaleX, scaleY);
            const bgSprite = new PIXI.Sprite(texture);
            bgSprite.scale.x = targetScale;
            bgSprite.scale.y = targetScale;
            bgSprite.anchor.set(0.5);
            bgSprite.position.y = this.stageHeight / 2;
            thisBgContainer.setBaseX(this.stageWidth / 2);
            thisBgContainer.setBaseY(this.stageHeight / 2);
            thisBgContainer.pivot.set(0, this.stageHeight / 2);
            thisBgContainer.addChild(bgSprite);
          });
        }
      }, 0);
    };

    /**
     * 加载器部分
     */
    this.cacheGC();
    if (!loader.resources?.[url]?.texture) {
      this.loadAsset(url, setup);
    } else {
      // 复用
      setup();
    }
  }

  /**
   * 添加立绘
   * @param key 立绘的标识，一般和立绘位置有关
   * @param url 立绘图片url
   * @param presetPosition
   */
  public addFigure(key: string, url: string, presetPosition: 'left' | 'center' | 'right' = 'center') {
    const loader = this.assetLoader;
    // 准备用于存放这个立绘的 Container
    const thisFigureContainer = new WebGALPixiContainer();

    // 是否有相同 key 的立绘
    const setFigIndex = this.figureObjects.findIndex((e) => e.key === key);
    const isFigSet = setFigIndex >= 0;

    // 已经有一个这个 key 的立绘存在了
    if (isFigSet) {
      this.removeStageObjectByKey(key);
    }

    const metadata = this.getFigureMetadataByKey(key);
    if (metadata) {
      if (metadata.zIndex) {
        thisFigureContainer.zIndex = metadata.zIndex;
      }
    }
    // 挂载
    this.figureContainer.addChild(thisFigureContainer);
    const figureUuid = uuid();
    this.figureObjects.push({
      uuid: figureUuid,
      key: key,
      pixiContainer: thisFigureContainer,
      sourceUrl: url,
      sourceType: 'img',
      sourceExt: this.getExtName(url),
    });

    // 完成图片加载后执行的函数
    const setup = () => {
      // TODO：找一个更好的解法，现在的解法是无论是否复用原来的资源，都设置一个延时以让动画工作正常！
      setTimeout(() => {
        const texture = loader.resources?.[url]?.texture;
        if (texture && this.getStageObjByUuid(figureUuid)) {
          /**
           * 重设大小
           */
          const originalWidth = texture.width;
          const originalHeight = texture.height;
          const scaleX = this.stageWidth / originalWidth;
          const scaleY = this.stageHeight / originalHeight;
          const targetScale = Math.min(scaleX, scaleY);
          const figureSprite = new PIXI.Sprite(texture);
          figureSprite.scale.x = targetScale;
          figureSprite.scale.y = targetScale;
          figureSprite.anchor.set(0.5);
          figureSprite.position.y = this.stageHeight / 2;
          const targetWidth = originalWidth * targetScale;
          const targetHeight = originalHeight * targetScale;
          thisFigureContainer.setBaseY(this.stageHeight / 2);
          if (targetHeight < this.stageHeight) {
            thisFigureContainer.setBaseY(this.stageHeight / 2 + (this.stageHeight - targetHeight) / 2);
          }
          if (presetPosition === 'center') {
            thisFigureContainer.setBaseX(this.stageWidth / 2);
          }
          if (presetPosition === 'left') {
            thisFigureContainer.setBaseX(targetWidth / 2);
          }
          if (presetPosition === 'right') {
            thisFigureContainer.setBaseX(this.stageWidth - targetWidth / 2);
          }
          thisFigureContainer.pivot.set(0, this.stageHeight / 2);
          thisFigureContainer.addChild(figureSprite);
        }
      }, 0);
    };

    /**
     * 加载器部分
     */
    this.cacheGC();
    if (!loader.resources?.[url]?.texture) {
      this.loadAsset(url, setup);
    } else {
      // 复用
      setup();
    }
  }

  /**
   * Live2d立绘，如果要使用 Live2D，取消这里的注释
   * @param jsonPath
   */
  // eslint-disable-next-line max-params
  public addLive2dFigure(key: string, jsonPath: string, pos: string) {
    if (Live2D.isAvailable !== true) return;
    try {
      let stageWidth = this.stageWidth;
      let stageHeight = this.stageHeight;

      this.figureCash.push(jsonPath);

      const loader = this.assetLoader;
      // 准备用于存放这个立绘的 Container
      const thisFigureContainer = new WebGALPixiContainer();

      // 是否有相同 key 的立绘
      const setFigIndex = this.figureObjects.findIndex((e) => e.key === key);
      const isFigSet = setFigIndex >= 0;

      // 已经有一个这个 key 的立绘存在了
      if (isFigSet) {
        this.removeStageObjectByKey(key);
      }

      const metadata = this.getFigureMetadataByKey(key);
      if (metadata) {
        if (metadata.zIndex) {
          thisFigureContainer.zIndex = metadata.zIndex;
        }
      }
      // 挂载
      this.figureContainer.addChild(thisFigureContainer);
      const figureUuid = uuid();
      this.figureObjects.push({
        uuid: figureUuid,
        key: key,
        pixiContainer: thisFigureContainer,
        sourceUrl: jsonPath,
        sourceType: 'live2d',
        sourceExt: 'json',
      });
      // eslint-disable-next-line @typescript-eslint/no-this-alias
      const instance = this;

      const setup = () => {
        if (thisFigureContainer && this.getStageObjByUuid(figureUuid)) {
          (async function () {
            let overrideBounds: [number, number, number, number] = [0, 0, 0, 0];
            const mot = webgalStore.getState().stage.live2dMotion.find((e) => e.target === key);
            if (mot?.overrideBounds) {
              overrideBounds = mot.overrideBounds;
            }
            console.log(overrideBounds);
            const models = await Promise.all([
              Live2D.Live2DModel.from(jsonPath, {
                autoInteract: false,
                overWriteBounds: {
                  x0: overrideBounds[0],
                  y0: overrideBounds[1],
                  x1: overrideBounds[2],
                  y1: overrideBounds[3],
                },
              }),
            ]);

            models.forEach((model) => {
              const scaleX = stageWidth / model.width;
              const scaleY = stageHeight / model.height;
              const targetScale = Math.min(scaleX, scaleY);
              const targetWidth = model.width * targetScale;
              const targetHeight = model.height * targetScale;
              model.scale.x = targetScale;
              model.scale.y = targetScale;
              model.anchor.set(0.5);
              model.pivot.x += (overrideBounds[0] + overrideBounds[2]) * 0.5;
              model.pivot.y += (overrideBounds[1] + overrideBounds[3]) * 0.5;
              model.position.x = 0;
              model.position.y = stageHeight / 2;

              let baseY = stageHeight / 2;
              if (targetHeight < stageHeight) {
                baseY = stageHeight / 2 + (stageHeight - targetHeight) / 2;
              }
              thisFigureContainer.setBaseY(baseY);
              if (pos === 'center') {
                thisFigureContainer.setBaseX(stageWidth / 2);
              } else if (pos === 'left') {
                thisFigureContainer.setBaseX(targetWidth / 2);
              } else if (pos === 'right') {
                thisFigureContainer.setBaseX(stageWidth - targetWidth / 2);
              }

              thisFigureContainer.pivot.set(0, stageHeight / 2);

              let animation_index = 0;
              let priority_number = 3;

              // motion
              let motionToSet = '';
              const motionFromState = webgalStore.getState().stage.live2dMotion.find((e) => e.target === key);
              if (motionFromState) {
                motionToSet = motionFromState.motion;
              }
              instance.updateL2dMotionByKey(key, motionToSet);
              model.motion(motionToSet, animation_index, priority_number);

              // expression
              let expressionToSet = '';
              const expressionFromState = webgalStore.getState().stage.live2dExpression.find((e) => e.target === key);
              if (expressionFromState) {
                expressionToSet = expressionFromState.expression;
              }
              instance.updateL2dExpressionByKey(key, expressionToSet);
              model.expression(expressionToSet);

              // blink
              let blinkToSet: BlinkParam = baseBlinkParam;
              const blinkFromState = webgalStore.getState().stage.live2dBlink.find((e) => e.target === key);
              if (blinkFromState) {
                blinkToSet = { ...blinkToSet, ...blinkFromState.blink };
              }
              instance.updateL2dBlinkByKey(key, blinkToSet);
              model.internalModel?.setBlinkParam(blinkToSet);

              // focus
              let focusToSet: FocusParam = baseFocusParam;
              const focusFromState = webgalStore.getState().stage.live2dFocus.find((e) => e.target === key);
              if (focusFromState) {
                focusToSet = { ...focusToSet, ...focusFromState.focus };
              }
              instance.updateL2dFocusByKey(key, focusToSet);
              model.internalModel?.focusController?.focus(focusToSet.x, focusToSet.y, focusToSet.instant);

              // lip-sync is still a problem and you can not.
              Live2D.SoundManager.volume = 0; // @ts-ignore

              thisFigureContainer.addChild(model);
            });
          })();
        }
      };

      /**
       * 加载器部分
       */
      const resourses = Object.keys(loader.resources);
      this.cacheGC();
      if (!resourses.includes(jsonPath)) {
        this.loadAsset(jsonPath, () => setup());
      } else {
        // 复用
        setup();
      }
    } catch (error) {
      console.error('Live2d Module err: ' + error);
      Live2D.isAvailable = false;
    }
  }

  public changeModelMotionByKey(key: string, motion: string) {
    // logger.debug(`Applying motion ${motion} to ${key}`);
    const target = this.figureObjects.find((e) => e.key === key && !e.isExiting);
    if (target?.sourceType === 'live2d') {
      const figureRecordTarget = this.live2dFigureRecorder.find((e) => e.target === key);
      if (target && figureRecordTarget?.motion !== motion) {
        const container = target.pixiContainer;
        if (!container) return;
        const children = container.children;
        for (const model of children) {
          let category_name = motion;
          let animation_index = 0;
          let priority_number = 3; // @ts-ignore
          const internalModel = model?.internalModel ?? undefined; // 安全访问
          internalModel?.motionManager?.stopAllMotions?.();
          // @ts-ignore
          model.motion(category_name, animation_index, priority_number);
        }
        this.updateL2dMotionByKey(key, motion);
      }
    } else if (target?.sourceType === 'spine') {
      // 处理 Spine 动画切换
      this.changeSpineAnimationByKey(key, motion);
    }
  }

  public changeSpineAnimationByKey(key: string, animation: string) {
    const target = this.figureObjects.find((e) => e.key === key && !e.isExiting);
    if (target?.sourceType !== 'spine') return;

    const container = target.pixiContainer;
    if (!container) return;
    // Spine figure 结构: Container -> Sprite -> Spine
    const sprite = container.children[0] as PIXI.Container;
    if (sprite?.children?.[0]) {
      const spineObject = sprite.children[0];
      // @ts-ignore
      if (spineObject.state && spineObject.spineData) {
        // @ts-ignore
        const animationExists = spineObject.spineData.animations.find((anim: any) => anim.name === animation);
        let targetCurrentAnimation = target?.spineAnimation ?? '';
        if (animationExists && targetCurrentAnimation !== animation) {
          console.log(`setting animation ${animation}`);
          target!.spineAnimation = animation;
          // @ts-ignore
          spineObject.state.setAnimation(0, animation, false);
        }
      }
    }
  }

  public changeModelExpressionByKey(key: string, expression: string) {
    // logger.debug(`Applying expression ${expression} to ${key}`);
    const target = this.figureObjects.find((e) => e.key === key && !e.isExiting);
    if (target?.sourceType !== 'live2d') return;
    const figureRecordTarget = this.live2dFigureRecorder.find((e) => e.target === key);
    if (target && figureRecordTarget?.expression !== expression) {
      const container = target.pixiContainer;
      if (!container) return;
      const children = container.children;
      for (const model of children) {
        // @ts-ignore
        model.expression(expression);
      }
      this.updateL2dExpressionByKey(key, expression);
    }
  }

  public changeModelBlinkByKey(key: string, blinkParam: BlinkParam) {
    const target = this.figureObjects.find((e) => e.key === key && !e.isExiting);
    if (target?.sourceType !== 'live2d') return;
    const figureRecordTarget = this.live2dFigureRecorder.find((e) => e.target === key);
    if (target && !isEqual(figureRecordTarget?.blink, blinkParam)) {
      const container = target.pixiContainer;
      if (!container) return;
      const children = container.children;
      let newBlinkParam: BlinkParam = { ...baseBlinkParam, ...blinkParam };
      // 继承现有 BlinkParam
      if (figureRecordTarget?.blink) {
        newBlinkParam = { ...cloneDeep(figureRecordTarget.blink), ...blinkParam };
      }
      for (const model of children) {
        // @ts-ignore
        model?.internalModel?.setBlinkParam?.(newBlinkParam);
      }
      this.updateL2dBlinkByKey(key, newBlinkParam);
    }
  }

  public changeModelFocusByKey(key: string, focusParam: FocusParam) {
    const target = this.figureObjects.find((e) => e.key === key && !e.isExiting);
    if (target?.sourceType !== 'live2d') return;
    const figureRecordTarget = this.live2dFigureRecorder.find((e) => e.target === key);
    if (target && !isEqual(figureRecordTarget?.focus, focusParam)) {
      const container = target.pixiContainer;
      if (!container) return;
      const children = container.children;
      let newFocusParam: FocusParam = { ...baseFocusParam, ...focusParam };
      // 继承现有 FocusParam
      if (figureRecordTarget?.focus) {
        newFocusParam = { ...cloneDeep(figureRecordTarget.focus), ...focusParam };
      }
      for (const model of children) {
        // @ts-ignore
        model?.internalModel?.focusController.focus(newFocusParam.x, newFocusParam.y, newFocusParam.instant);
      }
      this.updateL2dFocusByKey(key, newFocusParam);
    }
  }

  public setModelMouthY(key: string, y: number) {
    function mapToZeroOne(value: number) {
      return value < 50 ? 0 : (value - 50) / 50;
    }

    const paramY = mapToZeroOne(y);
    const target = this.figureObjects.find((e) => e.key === key);
    if (target && target.sourceType === 'live2d') {
      const container = target.pixiContainer;
      if (!container) return;
      const children = container.children;
      for (const model of children) {
        // @ts-ignore
        if (model?.internalModel) {
          // @ts-ignore
          if (model?.internalModel?.coreModel?.setParamFloat)
            // @ts-ignore
            model?.internalModel?.coreModel?.setParamFloat?.('PARAM_MOUTH_OPEN_Y', paramY);
          // @ts-ignore
          if (model?.internalModel?.coreModel?.setParameterValueById)
            // @ts-ignore
            model?.internalModel?.coreModel?.setParameterValueById('ParamMouthOpenY', paramY);
        }
      }
    }
  }

  /**
   * 根据 key 获取舞台上的对象
   * @param key
   */
  public getStageObjByKey(key: string) {
    return [...this.figureObjects, ...this.backgroundObjects, this.mainStageObject].find((e) => e.key === key);
  }

  public getStageObjByUuid(objUuid: string) {
    return [...this.figureObjects, ...this.backgroundObjects, this.mainStageObject].find((e) => e.uuid === objUuid);
  }

  public getAllStageObj() {
    return [...this.figureObjects, ...this.backgroundObjects, this.mainStageObject];
  }

  /**
   * 根据 key 删除舞台上的对象
   * @param key
   */
  public removeStageObjectByKey(key: string) {
    const indexFig = this.figureObjects.findIndex((e) => e.key === key);
    const indexBg = this.backgroundObjects.findIndex((e) => e.key === key);
    if (indexFig >= 0) {
      const bgSprite = this.figureObjects[indexFig];
      if (bgSprite.pixiContainer)
        for (const element of bgSprite.pixiContainer.children) {
          element.destroy();
        }
      if (bgSprite.pixiContainer) {
        bgSprite.pixiContainer.destroy();
        this.figureContainer.removeChild(bgSprite.pixiContainer);
      }
      bgSprite.pixiContainer = null;
      this.figureObjects.splice(indexFig, 1);
    }
    if (indexBg >= 0) {
      const bgSprite = this.backgroundObjects[indexBg];
      if (bgSprite.pixiContainer)
        for (const element of bgSprite.pixiContainer.children) {
          element.destroy();
        }
      if (bgSprite.pixiContainer) {
        bgSprite.pixiContainer.destroy();
        this.backgroundContainer.removeChild(bgSprite.pixiContainer);
      }
      bgSprite.pixiContainer = null;
      this.backgroundObjects.splice(indexBg, 1);
    }
    // /**
    //  * 删掉相关 Effects，因为已经移除了
    //  */
    // const prevEffects = webgalStore.getState().stage.effects;
    // const newEffects = __.cloneDeep(prevEffects);
    // const index = newEffects.findIndex((e) => e.target === key);
    // if (index >= 0) {
    //   newEffects.splice(index, 1);
    // }
    // updateCurrentEffects(newEffects);
  }

  public cacheGC() {
    PIXI.utils.clearTextureCache();
  }

  public getExtName(url: string) {
    return url.split('.').pop() ?? 'png';
  }

  public getFigureMetadataByKey(key: string): IFigureMetadata | undefined {
    console.log(key, webgalStore.getState().stage.figureMetaData);
    return webgalStore.getState().stage.figureMetaData[key];
  }

  public loadAsset(url: string, callback: () => void, name?: string) {
    /**
     * Loader 复用疑似有问题，转而采用先前的单独方式
     */
    this.loadQueue.unshift({ url, callback, name });
    /**
     * 尝试启动加载
     */
    this.callLoader();
  }

  private updateL2dMotionByKey(target: string, motion: string) {
    const figureTargetIndex = this.live2dFigureRecorder.findIndex((e) => e.target === target);
    if (figureTargetIndex >= 0) {
      this.live2dFigureRecorder[figureTargetIndex].motion = motion;
    } else {
      this.live2dFigureRecorder.push({ target, motion, expression: '', blink: baseBlinkParam, focus: baseFocusParam });
    }
  }

  private updateL2dExpressionByKey(target: string, expression: string) {
    const figureTargetIndex = this.live2dFigureRecorder.findIndex((e) => e.target === target);
    if (figureTargetIndex >= 0) {
      this.live2dFigureRecorder[figureTargetIndex].expression = expression;
    } else {
      this.live2dFigureRecorder.push({ target, motion: '', expression, blink: baseBlinkParam, focus: baseFocusParam });
    }
  }

  private updateL2dBlinkByKey(target: string, blink: BlinkParam) {
    const figureTargetIndex = this.live2dFigureRecorder.findIndex((e) => e.target === target);
    if (figureTargetIndex >= 0) {
      this.live2dFigureRecorder[figureTargetIndex].blink = blink;
    } else {
      this.live2dFigureRecorder.push({ target, motion: '', expression: '', blink, focus: baseFocusParam });
    }
  }

  private updateL2dFocusByKey(target: string, focus: FocusParam) {
    const figureTargetIndex = this.live2dFigureRecorder.findIndex((e) => e.target === target);
    if (figureTargetIndex >= 0) {
      this.live2dFigureRecorder[figureTargetIndex].focus = focus;
    } else {
      this.live2dFigureRecorder.push({ target, motion: '', expression: '', blink: baseBlinkParam, focus });
    }
  }

  private callLoader() {
    if (!this.assetLoader.loading) {
      const front = this.loadQueue.shift();
      if (front) {
        try {
          if (this.assetLoader.resources[front.url]) {
            front.callback();
            this.callLoader();
          } else {
            if (front.name) {
              this.assetLoader.add(front.name, front.url).load(() => {
                front.callback();
                this.callLoader();
              });
            } else {
              this.assetLoader.add(front.url).load(() => {
                front.callback();
                this.callLoader();
              });
            }
          }
        } catch (error) {
          logger.fatal('PIXI Loader 故障', error);
          front.callback();
          // this.assetLoader.reset(); // 暂时先不用重置
          this.callLoader();
        }
      }
    }
  }

  private updateFps() {
    getScreenFps?.(120).then((fps) => {
      this.frameDuration = 1000 / (fps as number);
      // logger.info('当前帧率', fps);
    });
  }

  private lockStageObject(targetName: string) {
    this.lockTransformTarget.push(targetName);
  }

  private unlockStageObject(targetName: string) {
    const index = this.lockTransformTarget.findIndex((name) => name === targetName);
    if (index >= 0) this.lockTransformTarget.splice(index, 1);
  }

  private async initialize() {
    // 动态加载 figureCash
    try {
      const { figureCash } = await import('@/Core/gameScripts/vocal/conentsCash');
      this.figureCash = figureCash;
    } catch (error) {
      console.error('Failed to load figureCash:', error);
    }
  }
}

function updateCurrentBacklogEffects(newEffects: IEffect[]) {
  /**
   * 更新当前 backlog 条目的 effects 记录
   */
  setTimeout(() => {
    WebGAL.backlogManager.editLastBacklogItemEffect(cloneDeep(newEffects));
  }, 50);

  webgalStore.dispatch(setStage({ key: 'effects', value: newEffects }));
}

/**
 * @param {number} targetCount 不小于1的整数，表示经过targetCount帧之后返回结果
 * @return {Promise<number>}
 */
const getScreenFps = (() => {
  // 先做一下兼容性处理
  const nextFrame = [
    window.requestAnimationFrame,
    // @ts-ignore
    window.webkitRequestAnimationFrame,
    // @ts-ignore
    window.mozRequestAnimationFrame,
  ].find((fn) => fn);
  if (!nextFrame) {
    console.error('requestAnimationFrame is not supported!');
    return;
  }
  return (targetCount = 60) => {
    // 判断参数是否合规
    if (targetCount < 1) throw new Error('targetCount cannot be less than 1.');
    const beginDate = Date.now();
    let count = 0;
    return new Promise((resolve) => {
      (function log() {
        nextFrame(() => {
          if (++count >= targetCount) {
            const diffDate = Date.now() - beginDate;
            const fps = (count / diffDate) * 1000;
            return resolve(fps);
          }
          log();
        });
      })();
    });
  };
})();



================================================
FILE: webgal/src/Core/controller/stage/pixi/spine.ts
================================================
// spineHandlers.ts
import { WebGALPixiContainer } from '@/Core/controller/stage/pixi/WebGALPixiContainer';
import { v4 as uuid } from 'uuid';
import * as PIXI from 'pixi.js';
import PixiStage from '@/Core/controller/stage/pixi/PixiController';
import { logger } from '@/Core/util/logger';
import { webgalStore } from '@/store/store';
// utils/loadPixiSpine.ts
// @ts-ignore
let pixiSpineModule: typeof import('pixi-spine') | null = null;
// @ts-ignore
let pixiSpineLoading: Promise<typeof import('pixi-spine') | null> | null = null;

let spineLoader: undefined | PIXI.Loader;

/**
 * 动态加载 'pixi-spine' 模块，并缓存结果
 * @returns {Promise<typeof import('pixi-spine') | null>}
 */
// @ts-ignore
export async function loadPixiSpine(): Promise<typeof import('pixi-spine') | null> {
  if (pixiSpineModule) {
    return pixiSpineModule;
  }

  if (pixiSpineLoading) {
    return pixiSpineLoading;
  }

  // @ts-ignore
  // pixiSpineLoading = import('pixi-spine')
  //   .then((module) => {
  //     spineLoader = new PIXI.Loader();
  //     pixiSpineModule = module;
  //     return module;
  //   })
  //   .catch((error) => {
  //     console.error('Failed to load pixi-spine. Spine features will be disabled.', error);
  //     return null;
  //   })
  //   .finally(() => {
  //     pixiSpineLoading = null;
  //   });

  return pixiSpineLoading;
}

/**
 * 添加 Spine 立绘的实现函数
 * @param key 立绘的标识
 * @param url Spine 数据的 URL
 * @param presetPosition 预设位置
 */
// eslint-disable-next-line max-params
export async function addSpineFigureImpl(
  this: PixiStage,
  key: string,
  url: string,
  presetPosition: 'left' | 'center' | 'right' = 'center',
) {
  const spineId = `spine-${url}`;
  // 准备用于存放这个立绘的 Container
  const thisFigureContainer = new WebGALPixiContainer();

  // 是否有相同 key 的立绘
  const setFigIndex = this.figureObjects.findIndex((e) => e.key === key);
  const isFigSet = setFigIndex >= 0;

  // 已经有一个这个 key 的立绘存在了
  if (isFigSet) {
    this.removeStageObjectByKey(key);
  }

  const metadata = this.getFigureMetadataByKey(key);
  if (metadata) {
    if (metadata.zIndex) {
      thisFigureContainer.zIndex = metadata.zIndex;
    }
  }
  // 挂载
  this.figureContainer.addChild(thisFigureContainer);
  const figureUuid = uuid();
  this.figureObjects.push({
    uuid: figureUuid,
    key: key,
    pixiContainer: thisFigureContainer,
    sourceUrl: url,
    sourceType: 'spine', // 修改为 'spine'
    sourceExt: this.getExtName(url),
    spineAnimation: '_initial',
  });
  const pixiSpine = await loadPixiSpine();

  // 完成图片加载后执行的函数
  const setup = async () => {
    setTimeout(() => {
      console.log('Setting up Spine' + key + url);
      if (!pixiSpine) {
        // 无法加载 'pixi-spine'，跳过 Spine 相关逻辑
        logger.warn(`Spine module not loaded. Skipping Spine figure: ${key}`);
        return;
      }

      const { Spine } = pixiSpine;
      const spineResource: any = spineLoader!.resources?.[spineId];
      if (spineResource && this.getStageObjByUuid(figureUuid)) {
        const figureSpine = new Spine(spineResource.spineData);
        const spineBounds = figureSpine.getLocalBounds();
        const spineCenterX = spineBounds.x + spineBounds.width / 2;
        const spineCenterY = spineBounds.y + spineBounds.height / 2;
        figureSpine.pivot.set(spineCenterX, spineCenterY);
        figureSpine.interactive = false;

        // 检查状态中是否有指定的动画
        const motionFromState = webgalStore.getState().stage.live2dMotion.find((e) => e.target === key);
        let animationToPlay = '';

        if (
          motionFromState &&
          figureSpine.spineData.animations.find((anim: any) => anim.name === motionFromState.motion)
        ) {
          // 使用状态中指定的动画
          animationToPlay = motionFromState.motion;
        } else if (figureSpine.spineData.animations.length > 0) {
          // 播放默认动画（第一个动画）
          animationToPlay = figureSpine.spineData.animations[0].name;
        }

        if (animationToPlay) {
          figureSpine.state.setAnimation(0, animationToPlay, false);
          figureSpine.autoUpdate = true;
          const stageObj = this.getStageObjByUuid(figureUuid);
          if (stageObj) {
            if (stageObj.spineAnimation) {
              stageObj.spineAnimation = animationToPlay;
            }
          }
        }

        /**
         * 重设大小
         */
        const originalWidth = figureSpine.width;
        const originalHeight = figureSpine.height;
        const scaleX = this.stageWidth / originalWidth;
        const scaleY = this.stageHeight / originalHeight;
        const targetScale = Math.min(scaleX, scaleY);
        const figureSprite = new PIXI.Sprite();
        figureSprite.addChild(figureSpine);
        figureSprite.scale.x = targetScale;
        figureSprite.scale.y = targetScale;
        figureSprite.anchor.set(0.5);
        figureSprite.position.y = this.stageHeight / 2;
        const targetWidth = originalWidth * targetScale;
        const targetHeight = originalHeight * targetScale;
        thisFigureContainer.setBaseY(this.stageHeight / 2);
        if (targetHeight < this.stageHeight) {
          thisFigureContainer.setBaseY(this.stageHeight / 2 + (this.stageHeight - targetHeight) / 2);
        }
        if (presetPosition === 'center') {
          thisFigureContainer.setBaseX(this.stageWidth / 2);
        }
        if (presetPosition === 'left') {
          thisFigureContainer.setBaseX(targetWidth / 2);
        }
        if (presetPosition === 'right') {
          thisFigureContainer.setBaseX(this.stageWidth - targetWidth / 2);
        }
        thisFigureContainer.pivot.set(0, this.stageHeight / 2);
        thisFigureContainer.addChild(figureSprite);
      }
    }, 0);
  };

  /**
   * 加载器部分
   * 这里不再使用 this.loadAsset，因为我们可能需要单独管理 Spine 资源
   * 但为了避免性能问题，我们继续使用现有的 loader，并确保资源只加载一次
   */
  this.cacheGC();
  if (!spineLoader!.resources?.[spineId]) {
    spineLoader!.add(spineId, url).load(setup);
  } else {
    // 复用
    await setup();
  }
}

/**
 * 添加 Spine 背景的实现函数
 * @param key 背景的标识
 * @param url Spine 数据的 URL
 */
export async function addSpineBgImpl(this: PixiStage, key: string, url: string) {
  const spineId = `spine-${url}`;
  // 准备用于存放这个背景的 Container
  const thisBgContainer = new WebGALPixiContainer();

  // 是否有相同 key 的背景
  const setBgIndex = this.backgroundObjects.findIndex((e) => e.key === key);
  const isBgSet = setBgIndex >= 0;

  // 已经有一个这个 key 的背景存在了
  if (isBgSet) {
    // 挤占
    this.removeStageObjectByKey(key);
  }

  // 挂载
  this.backgroundContainer.addChild(thisBgContainer);
  const bgUuid = uuid();
  this.backgroundObjects.push({
    uuid: bgUuid,
    key: key,
    pixiContainer: thisBgContainer,
    sourceUrl: url,
    sourceType: 'spine', // 修改为 'spine'
    sourceExt: this.getExtName(url),
  });

  // 完成图片加载后执行的函数
  const setup = async () => {
    const pixiSpine = await loadPixiSpine();
    if (!pixiSpine) {
      // 无法加载 'pixi-spine'，跳过 Spine 相关逻辑
      logger.warn(`Spine module not loaded. Skipping Spine background: ${key}`);
      return;
    }

    const { Spine } = pixiSpine;
    const spineResource: any = spineLoader!.resources?.[spineId];
    // TODO：找一个更好的解法，现在的解法是无论是否复用原来的资源，都设置一个延时以让动画工作正常！
    setTimeout(() => {
      if (spineResource && this.getStageObjByUuid(bgUuid)) {
        const bgSpine = new Spine(spineResource.spineData);
        const transY = spineResource?.spineData?.y ?? 0;
        /**
         * 重设大小
         */
        const originalWidth = bgSpine.width; // TODO: 视图大小可能小于画布大小，应提供参数指定视图大小
        const originalHeight = bgSpine.height; // TODO: 视图大小可能小于画布大小，应提供参数指定视图大小
        const scaleX = this.stageWidth / originalWidth;
        const scaleY = this.stageHeight / originalHeight;
        logger.debug('bgSpine state', bgSpine.state);
        // TODO: 也许应该使用 setAnimation 播放初始动画
        if (bgSpine.spineData.animations.length > 0) {
          // 播放首个动画
          bgSpine.state.setAnimation(0, bgSpine.spineData.animations[0].name, true);
        }
        const targetScale = Math.max(scaleX, scaleY);
        const bgSprite = new PIXI.Sprite();
        bgSprite.addChild(bgSpine);
        bgSprite.scale.x = targetScale;
        bgSprite.scale.y = targetScale;
        bgSprite.anchor.set(0.5);
        bgSprite.position.y = this.stageHeight / 2;
        thisBgContainer.setBaseX(this.stageWidth / 2);
        thisBgContainer.setBaseY(this.stageHeight / 2);
        thisBgContainer.pivot.set(0, this.stageHeight / 2);

        // 挂载
        thisBgContainer.addChild(bgSprite);
      }
    }, 0);
  };

  /**
   * 加载器部分
   * 这里不再使用 this.loadAsset，因为我们可能需要单独管理 Spine 资源
   * 但为了避免性能问题，我们继续使用现有的 loader，并确保资源只加载一次
   */
  this.cacheGC();
  if (!spineLoader!.resources?.[spineId]) {
    spineLoader!.add(spineId, url).load(setup);
  } else {
    // 复用
    await setup();
  }
}



================================================
FILE: webgal/src/Core/controller/stage/pixi/WebGALPixiContainer.ts
================================================
import { OldFilmFilter } from '@pixi/filter-old-film';
import { DotFilter } from '@pixi/filter-dot';
import { ReflectionFilter } from '@pixi/filter-reflection';
import { GlitchFilter } from '@pixi/filter-glitch';
import { RGBSplitFilter } from '@pixi/filter-rgb-split';
import { GodrayFilter } from '@pixi/filter-godray';
import { AdjustmentFilter, AdvancedBloomFilter, ShockwaveFilter } from 'pixi-filters';
import { BevelFilter } from '@/Core/controller/stage/pixi/shaders/BevelFilter';
import * as PIXI from 'pixi.js';
import { BlurFilter } from '@pixi/filter-blur';
import { INIT_RAD, RadiusAlphaFilter } from '@/Core/controller/stage/pixi/shaders/RadiusAlphaFilter';

/**
 * Filter configuration for creation and default state detection.
 */
interface FilterConfig {
  priority: number;
  create: () => PIXI.Filter;
  isDefault?: (f: PIXI.Filter) => boolean;
}

/**
 * Property configuration for mapping class properties to filter effects.
 */
interface PropertyConfig {
  filterName: string;
  filterProperty?: string;
  defaultValue: number;
  isBoolean?: boolean;
  overrideSet?: (value: number, filter: PIXI.Filter, container: WebGALPixiContainer) => void;
  overrideGet?: (filter: PIXI.Filter | undefined, defaultValue: number, container: WebGALPixiContainer) => number;
}

// 滤镜顺序，靠上滤镜的排滤镜数组后面(在上层)
const enum FilterPriority {
  ReflectionFilm,
  RadiusAlpha,
  ShockWave,
  Blur,
  RgbFilm,
  DotFilm,
  GlitchFilm,
  OldFilm,
  Bloom,
  GodrayFilm,
  Bevel,
  Adjustment,
}

const FILTER_CONFIGS: Record<string, FilterConfig> = {
  blur: {
    priority: FilterPriority.Blur,
    create: () => {
      const f = new PIXI.filters.BlurFilter();
      f.blur = 0;
      return f;
    },
    isDefault: (f) => (f as BlurFilter).blur === 0,
  },
  oldFilm: {
    priority: FilterPriority.OldFilm,
    create: () => new OldFilmFilter(),
  },
  dotFilm: {
    priority: FilterPriority.DotFilm,
    create: () => new DotFilter(),
  },
  reflectionFilm: {
    priority: FilterPriority.ReflectionFilm,
    create: () => new ReflectionFilter(),
  },
  glitchFilm: {
    priority: FilterPriority.GlitchFilm,
    create: () => new GlitchFilter(),
  },
  rgbFilm: {
    priority: FilterPriority.RgbFilm,
    create: () => new RGBSplitFilter(),
  },
  godrayFilm: {
    priority: FilterPriority.GodrayFilm,
    create: () => new GodrayFilter(),
  },
  shockwave: {
    // Renamed from shockwaveFilter for consistency
    priority: FilterPriority.ShockWave, // Example priority
    create: () => {
      // The [1280, 720] seems to be the intended center in pixel coordinates.
      // This might need to be dynamic based on the container's actual size/stage size.
      // For now, using the value from the provided snippet.
      const f = new ShockwaveFilter([1280, 720]); // Center of the shockwave
      f.time = 0; // Initial time
      return f;
    },
    isDefault: (f) => (f as ShockwaveFilter).time === 0,
  },
  adjustment: {
    priority: FilterPriority.Adjustment,
    create: () => new AdjustmentFilter(),
    isDefault: (f) => {
      const a = f as AdjustmentFilter;
      return (
        a.brightness === 1 &&
        a.contrast === 1 &&
        a.saturation === 1 &&
        a.gamma === 1 &&
        a.red === 1 &&
        a.green === 1 &&
        a.blue === 1
      );
    },
  },
  radiusAlpha: {
    // Renamed from radiusAlphaFilter for consistency
    priority: FilterPriority.RadiusAlpha, // Example priority
    create: () => {
      // Center (0.5, 0.5) for normalized center of the texture
      const f = new RadiusAlphaFilter(new PIXI.Point(0.5, 0.5), INIT_RAD);
      return f;
    },
    isDefault: (f) => (f as RadiusAlphaFilter).radius === INIT_RAD,
  },
  bevel: {
    priority: FilterPriority.Bevel, // 示例优先级，请根据需要调整
    create: () => {
      const f = new BevelFilter();
      // BevelFilter 默认值
      f.lightAlpha = 0; // bevel
      f.thickness = 0; // bevelThickness
      f.rotation = 0; // bevelRotation
      f.softness = 0; // bevelSoftness
      // 默认 lightColor (255, 255, 255) -> 0xFFFFFF
      f.lightColor = 0xffffff;
      f.shadowAlpha = 0; // 通常边缘光不需要阴影
      return f;
    },
    isDefault: (f) => {
      const b = f as BevelFilter;
      return (
        b.lightAlpha === 0 &&
        b.thickness === 0 &&
        b.rotation === 0 &&
        b.softness === 0 &&
        b.lightColor === 0xffffff && // 假设默认白色
        b.shadowAlpha === 0
      );
    },
  },
  bloom: {
    // 使用 'bloom' 作为 filterName
    priority: FilterPriority.Bloom, // 示例优先级
    create: () => {
      const f = new AdvancedBloomFilter();
      // AdvancedBloomFilter 默认值
      f.bloomScale = 0; // bloom
      f.brightness = 1; // bloomBrightness
      f.blur = 0; // bloomBlur
      f.threshold = 0; // bloomThreshold
      // AdvancedBloomFilter 还有其他属性如 quality, blendMode，如果需要控制也应在此处设置初始值
      return f;
    },
    isDefault: (f) => {
      const ab = f as AdvancedBloomFilter;
      return ab.bloomScale === 0 && ab.brightness === 1 && ab.blur === 0 && ab.threshold === 0;
    },
  },
};

const PROPERTY_CONFIGS: Record<string, PropertyConfig> = {
  blur: {
    filterName: 'blur',
    filterProperty: 'blur',
    defaultValue: 0,
  },
  brightness: {
    filterName: 'adjustment',
    filterProperty: 'brightness',
    defaultValue: 1,
  },
  contrast: {
    filterName: 'adjustment',
    filterProperty: 'contrast',
    defaultValue: 1,
  },
  saturation: {
    filterName: 'adjustment',
    filterProperty: 'saturation',
    defaultValue: 1,
  },
  gamma: {
    filterName: 'adjustment',
    filterProperty: 'gamma',
    defaultValue: 1,
  },
  colorRed: {
    filterName: 'adjustment',
    defaultValue: 255,
    overrideSet: (value, filter) => {
      (filter as AdjustmentFilter).red = value / 255;
    },
    overrideGet: (filter, defaultValue) => (filter ? (filter as AdjustmentFilter).red * 255 : defaultValue),
  },
  colorGreen: {
    filterName: 'adjustment',
    defaultValue: 255,
    overrideSet: (value, filter) => {
      (filter as AdjustmentFilter).green = value / 255;
    },
    overrideGet: (filter, defaultValue) => (filter ? (filter as AdjustmentFilter).green * 255 : defaultValue),
  },
  colorBlue: {
    filterName: 'adjustment',
    defaultValue: 255,
    overrideSet: (value, filter) => {
      (filter as AdjustmentFilter).blue = value / 255;
    },
    overrideGet: (filter, defaultValue) => (filter ? (filter as AdjustmentFilter).blue * 255 : defaultValue),
  },
  oldFilm: { filterName: 'oldFilm', defaultValue: 0, isBoolean: true },
  dotFilm: { filterName: 'dotFilm', defaultValue: 0, isBoolean: true },
  reflectionFilm: { filterName: 'reflectionFilm', defaultValue: 0, isBoolean: true },
  glitchFilm: { filterName: 'glitchFilm', defaultValue: 0, isBoolean: true },
  rgbFilm: { filterName: 'rgbFilm', defaultValue: 0, isBoolean: true },
  godrayFilm: { filterName: 'godrayFilm', defaultValue: 0, isBoolean: true },
  shockwaveFilter: {
    // Public property name
    filterName: 'shockwave', // Key in FILTER_CONFIGS
    filterProperty: 'time', // Property on ShockwaveFilter instance
    defaultValue: 0,
  },
  radiusAlphaFilter: {
    // Public property name
    filterName: 'radiusAlpha', // Key in FILTER_CONFIGS
    filterProperty: 'radius', // Property on RadiusAlphaFilter instance
    defaultValue: INIT_RAD,
  },
  // Bevel Filter Properties
  bevel: {
    filterName: 'bevel',
    filterProperty: 'lightAlpha', // 'bevel' 公开属性映射到 lightAlpha
    defaultValue: 0,
  },
  bevelThickness: {
    filterName: 'bevel',
    filterProperty: 'thickness',
    defaultValue: 0,
  },
  bevelRotation: {
    filterName: 'bevel',
    filterProperty: 'rotation',
    defaultValue: 0,
  },
  bevelSoftness: {
    filterName: 'bevel',
    filterProperty: 'softness',
    defaultValue: 0,
  },
  bevelRed: {
    filterName: 'bevel',
    defaultValue: 255,
    overrideSet: (value, filter) => {
      const bFilter = filter as BevelFilter;
      const g = (bFilter.lightColor >> 8) & 0xff;
      const bl = bFilter.lightColor & 0xff;
      bFilter.lightColor = (value << 16) | (g << 8) | bl;
    },
    overrideGet: (filter, defaultValue) => {
      if (filter) {
        return ((filter as BevelFilter).lightColor >> 16) & 0xff;
      }
      return defaultValue;
    },
  },
  bevelGreen: {
    filterName: 'bevel',
    defaultValue: 255,
    overrideSet: (value, filter) => {
      const bFilter = filter as BevelFilter;
      const r = (bFilter.lightColor >> 16) & 0xff;
      const bl = bFilter.lightColor & 0xff;
      bFilter.lightColor = (r << 16) | (value << 8) | bl;
    },
    overrideGet: (filter, defaultValue) => {
      if (filter) {
        return ((filter as BevelFilter).lightColor >> 8) & 0xff;
      }
      return defaultValue;
    },
  },
  bevelBlue: {
    filterName: 'bevel',
    defaultValue: 255,
    overrideSet: (value, filter) => {
      const bFilter = filter as BevelFilter;
      const r = (bFilter.lightColor >> 16) & 0xff;
      const g = (bFilter.lightColor >> 8) & 0xff;
      bFilter.lightColor = (r << 16) | (g << 8) | value;
    },
    overrideGet: (filter, defaultValue) => {
      if (filter) {
        return (filter as BevelFilter).lightColor & 0xff;
      }
      return defaultValue;
    },
  },

  // Advanced Bloom Filter Properties
  bloom: {
    filterName: 'bloom',
    filterProperty: 'bloomScale', // 'bloom' 公开属性映射到 bloomScale
    defaultValue: 0,
  },
  bloomBrightness: {
    filterName: 'bloom',
    filterProperty: 'brightness',
    defaultValue: 1,
  },
  bloomBlur: {
    filterName: 'bloom',
    filterProperty: 'blur',
    defaultValue: 0,
  },
  bloomThreshold: {
    filterName: 'bloom',
    filterProperty: 'threshold',
    defaultValue: 0,
  },
};

export class WebGALPixiContainer extends PIXI.Container {
  public containerFilters = new Map<string, PIXI.Filter>();
  private filterToName = new Map<PIXI.Filter, string>();

  private baseX = 0;
  private baseY = 0;

  public constructor() {
    super();
  }

  public removeFilterByName(filterName: string) {
    const filter = this.containerFilters.get(filterName);
    if (!filter || !this.filters) return;
    const idx = this.filters.indexOf(filter);
    if (idx !== -1) this.filters.splice(idx, 1);
    this.containerFilters.delete(filterName);
    this.filterToName.delete(filter);
  }

  // --- Position ---
  public override get x(): number {
    return (super.position?.x ?? 0) - this.baseX;
  }
  public override set x(v: number) {
    if (super.position) super.position.x = v + this.baseX;
  }
  public override get y(): number {
    return (super.position?.y ?? 0) - this.baseY;
  }
  public override set y(v: number) {
    if (super.position) super.position.y = v + this.baseY;
  }
  public setBaseX(x: number) {
    const old = this.x;
    this.baseX = x;
    this.x = old;
  }
  public setBaseY(y: number) {
    const old = this.y;
    this.baseY = y;
    this.y = old;
  }

  // --- Standard Filters ---
  public get blur(): number {
    return this._getPropertyValue('blur');
  }
  public set blur(v: number) {
    this._setPropertyValue('blur', v);
  }

  public get brightness(): number {
    return this._getPropertyValue('brightness');
  }
  public set brightness(v: number) {
    this._setPropertyValue('brightness', v);
  }
  public get contrast(): number {
    return this._getPropertyValue('contrast');
  }
  public set contrast(v: number) {
    this._setPropertyValue('contrast', v);
  }
  public get saturation(): number {
    return this._getPropertyValue('saturation');
  }
  public set saturation(v: number) {
    this._setPropertyValue('saturation', v);
  }
  public get gamma(): number {
    return this._getPropertyValue('gamma');
  }
  public set gamma(v: number) {
    this._setPropertyValue('gamma', v);
  }
  public get colorRed(): number {
    return this._getPropertyValue('colorRed');
  }
  public set colorRed(v: number) {
    this._setPropertyValue('colorRed', v);
  }
  public get colorGreen(): number {
    return this._getPropertyValue('colorGreen');
  }
  public set colorGreen(v: number) {
    this._setPropertyValue('colorGreen', v);
  }
  public get colorBlue(): number {
    return this._getPropertyValue('colorBlue');
  }
  public set colorBlue(v: number) {
    this._setPropertyValue('colorBlue', v);
  }

  // --- Boolean Filters ---
  public get oldFilm(): number {
    return this._getPropertyValue('oldFilm');
  }
  public set oldFilm(v: number) {
    this._setPropertyValue('oldFilm', v);
  }
  public get dotFilm(): number {
    return this._getPropertyValue('dotFilm');
  }
  public set dotFilm(v: number) {
    this._setPropertyValue('dotFilm', v);
  }
  public get reflectionFilm(): number {
    return this._getPropertyValue('reflectionFilm');
  }
  public set reflectionFilm(v: number) {
    this._setPropertyValue('reflectionFilm', v);
  }
  public get glitchFilm(): number {
    return this._getPropertyValue('glitchFilm');
  }
  public set glitchFilm(v: number) {
    this._setPropertyValue('glitchFilm', v);
  }
  public get rgbFilm(): number {
    return this._getPropertyValue('rgbFilm');
  }
  public set rgbFilm(v: number) {
    this._setPropertyValue('rgbFilm', v);
  }
  public get godrayFilm(): number {
    return this._getPropertyValue('godrayFilm');
  }
  public set godrayFilm(v: number) {
    this._setPropertyValue('godrayFilm', v);
  }

  // --- Newly Integrated Filters ---
  public get shockwaveFilter(): number {
    return this._getPropertyValue('shockwaveFilter');
  }
  public set shockwaveFilter(v: number) {
    this._setPropertyValue('shockwaveFilter', v);
  }

  public get radiusAlphaFilter(): number {
    return this._getPropertyValue('radiusAlphaFilter');
  }
  public set radiusAlphaFilter(v: number) {
    this._setPropertyValue('radiusAlphaFilter', v);
  }

  // --- Bevel Filter ---
  public get bevel(): number {
    return this._getPropertyValue('bevel');
  }
  public set bevel(v: number) {
    this._setPropertyValue('bevel', v);
  }

  public get bevelThickness(): number {
    return this._getPropertyValue('bevelThickness');
  }
  public set bevelThickness(v: number) {
    this._setPropertyValue('bevelThickness', v);
  }

  public get bevelRotation(): number {
    return this._getPropertyValue('bevelRotation');
  }
  public set bevelRotation(v: number) {
    this._setPropertyValue('bevelRotation', v);
  }

  public get bevelSoftness(): number {
    return this._getPropertyValue('bevelSoftness');
  }
  public set bevelSoftness(v: number) {
    this._setPropertyValue('bevelSoftness', v);
  }

  public get bevelRed(): number {
    return this._getPropertyValue('bevelRed');
  }
  public set bevelRed(v: number) {
    this._setPropertyValue('bevelRed', v);
  }

  public get bevelGreen(): number {
    return this._getPropertyValue('bevelGreen');
  }
  public set bevelGreen(v: number) {
    this._setPropertyValue('bevelGreen', v);
  }

  public get bevelBlue(): number {
    return this._getPropertyValue('bevelBlue');
  }
  public set bevelBlue(v: number) {
    this._setPropertyValue('bevelBlue', v);
  }

  // --- Advanced Bloom Filter ---
  public get bloom(): number {
    return this._getPropertyValue('bloom');
  }
  public set bloom(v: number) {
    this._setPropertyValue('bloom', v);
  }

  public get bloomBrightness(): number {
    return this._getPropertyValue('bloomBrightness');
  }
  public set bloomBrightness(v: number) {
    this._setPropertyValue('bloomBrightness', v);
  }

  public get bloomBlur(): number {
    return this._getPropertyValue('bloomBlur');
  }
  public set bloomBlur(v: number) {
    this._setPropertyValue('bloomBlur', v);
  }

  public get bloomThreshold(): number {
    return this._getPropertyValue('bloomThreshold');
  }
  public set bloomThreshold(v: number) {
    this._setPropertyValue('bloomThreshold', v);
  }

  private removeIfDefault(filterName: string) {
    const inst = this.containerFilters.get(filterName);
    const cfg = FILTER_CONFIGS[filterName];
    if (inst && cfg?.isDefault && cfg.isDefault(inst)) {
      this.removeFilterByName(filterName);
    }
  }

  private _getPropertyValue(propertyName: string): number {
    const propConfig = PROPERTY_CONFIGS[propertyName];
    if (!propConfig) {
      console.warn(`WebGALPixiContainer: Unknown property configuration for getter: ${propertyName}`);
      return 0;
    }
    if (propConfig.isBoolean) {
      return this.containerFilters.has(propConfig.filterName) ? 1 : 0;
    }
    const filterInstance = this.containerFilters.get(propConfig.filterName);
    if (propConfig.overrideGet) {
      return propConfig.overrideGet(filterInstance, propConfig.defaultValue, this);
    }
    if (filterInstance && propConfig.filterProperty) {
      return (filterInstance as any)[propConfig.filterProperty];
    }
    return propConfig.defaultValue;
  }

  private _setPropertyValue(propertyName: string, value: number): void {
    const propConfig = PROPERTY_CONFIGS[propertyName];
    if (!propConfig) {
      console.warn(`WebGALPixiContainer: Unknown property configuration for setter: ${propertyName}`);
      return;
    }
    if (propConfig.isBoolean) {
      if (value === 0 || value === undefined || value === null) {
        this.removeFilterByName(propConfig.filterName);
      } else {
        if (!this.containerFilters.has(propConfig.filterName)) {
          this.ensureFilterByName(propConfig.filterName);
        }
      }
      return;
    }
    if (value === propConfig.defaultValue && !this.containerFilters.has(propConfig.filterName)) {
      return;
    }
    const filterInstance = this.ensureFilterByName<any>(propConfig.filterName);
    if (propConfig.overrideSet) {
      propConfig.overrideSet(value, filterInstance, this);
    } else if (propConfig.filterProperty) {
      (filterInstance as any)[propConfig.filterProperty] = value;
    } else {
      console.warn(
        `WebGALPixiContainer: Property '${propertyName}' has neither overrideSet nor filterProperty defined for value setting.`,
      );
    }
    this.removeIfDefault(propConfig.filterName);
  }

  private insertFilterWithPriority(name: string, filter: PIXI.Filter) {
    const priority = FILTER_CONFIGS[name]?.priority ?? 0;

    if (!this.filters || this.filters.length === 0) {
      this.filters = [filter];
    } else {
      let insertIndex = this.filters.length;
      for (let i = 0; i < this.filters.length; i++) {
        const currentFilter = this.filters[i]!;
        const currentName = this.filterToName.get(currentFilter);
        if (currentName) {
          const currentPriority = FILTER_CONFIGS[currentName]?.priority ?? 0;
          if (priority > currentPriority) {
            insertIndex = i;
            break;
          }
        } else {
          if (priority > 0) {
            insertIndex = i;
            break;
          }
        }
      }
      this.filters.splice(insertIndex, 0, filter);
    }
    this.containerFilters.set(name, filter);
    this.filterToName.set(filter, name);
  }

  private ensureFilterByName<T extends PIXI.Filter>(filterName: string): T {
    let inst = this.containerFilters.get(filterName) as T | undefined;
    if (inst) return inst;
    const cfg = FILTER_CONFIGS[filterName];
    if (!cfg) throw new Error(`Unknown filter configuration: ${filterName}`);
    inst = cfg.create() as T;
    this.insertFilterWithPriority(filterName, inst);
    return inst;
  }
}



================================================
FILE: webgal/src/Core/controller/stage/pixi/animations/generateTransformAnimationObj.ts
================================================
import { AnimationFrame } from '@/Core/Modules/animations';
import { webgalStore } from '@/store/store';
import isNull from 'lodash/isNull';

type AnimationObj = Array<AnimationFrame>;

// eslint-disable-next-line max-params
export function generateTransformAnimationObj(
  target: string,
  applyFrame: AnimationFrame,
  duration: number | string | boolean | null,
  ease: string,
): AnimationObj {
  let animationObj;
  // 获取那个 target 的当前变换
  const transformState = webgalStore.getState().stage.effects;
  const targetEffect = transformState.find((effect) => effect.target === target);

  applyFrame.duration = 500;
  if (!isNull(duration) && typeof duration === 'number') {
    applyFrame.duration = duration;
  }
  applyFrame.ease = ease;
  animationObj = [applyFrame];

  // 找到 effect
  if (targetEffect) {
    const effectWithDuration = { ...targetEffect!.transform!, duration: 0, ease };
    animationObj.unshift(effectWithDuration);
  } else {
    // 应用默认effect，也就是最终的 effect 的 alpha = 0 版本
    const effectWithDuration = { ...applyFrame, alpha: 0, duration: 0, ease };
    animationObj.unshift(effectWithDuration);
  }
  return animationObj;
}



================================================
FILE: webgal/src/Core/controller/stage/pixi/animations/index.ts
================================================
import { generateUniversalSoftInAnimationObj } from '@/Core/controller/stage/pixi/animations/universalSoftIn';
import { generateUniversalSoftOffAnimationObj } from '@/Core/controller/stage/pixi/animations/universalSoftOff';
import { generateTestblurAnimationObj } from '@/Core/controller/stage/pixi/animations/testblur';

export const webgalAnimations: Array<{ name: string; animationGenerateFunc: Function }> = [
  { name: 'universalSoftIn', animationGenerateFunc: generateUniversalSoftInAnimationObj },
  { name: 'universalSoftOff', animationGenerateFunc: generateUniversalSoftOffAnimationObj },
  { name: 'testblur', animationGenerateFunc: generateTestblurAnimationObj },
];



================================================
FILE: webgal/src/Core/controller/stage/pixi/animations/template.ts
================================================
import { WebGAL } from '@/Core/WebGAL';

/**
 * 动画创建模板
 * @param targetKey 作用目标
 * @param duration 持续时间
 */
export function generateTemplateAnimationObj(targetKey: string, duration: number) {
  const target = WebGAL.gameplay.pixiStage!.getStageObjByKey(targetKey);

  // 先设置一个通用的初态

  // TODO：通用初态设置
  /**
   * 在此书写为动画设置初态的操作
   */
  function setStartState() {}

  // TODO：通用终态设置
  /**
   * 在此书写为动画设置终态的操作
   */
  function setEndState() {}

  /**
   * 在此书写动画每一帧执行的函数
   * @param delta
   */
  function tickerFunc(delta: number) {
    if (target) {
      // 要操控的精灵
      const sprite = target.pixiContainer;
      // 每一帧的时间
      const baseDuration = WebGAL.gameplay.pixiStage!.frameDuration;

      /**
       * 在下面书写具体的动画
       */

      // 具体的操作......
    }
  }

  return {
    setStartState,
    setEndState,
    tickerFunc,
  };
}



================================================
FILE: webgal/src/Core/controller/stage/pixi/animations/testblur.ts
================================================
import { WebGAL } from '@/Core/WebGAL';

export function generateTestblurAnimationObj(targetKey: string, duration: number) {
  const target = WebGAL.gameplay.pixiStage!.getStageObjByKey(targetKey);

  // 先设置一个通用的初态

  // TODO：通用初态设置
  /**
   * 在此书写为动画设置初态的操作
   */
  function setStartState() {
    if (target?.pixiContainer) {
      target.pixiContainer.alpha = 0;
      // @ts-ignore
      target.pixiContainer.blur = 0;
    }
  }

  // TODO：通用终态设置
  /**
   * 在此书写为动画设置终态的操作
   */
  function setEndState() {
    if (target?.pixiContainer) {
      target.pixiContainer.alpha = 1;
      // @ts-ignore
      target.pixiContainer.blur = 5;
    }
  }

  /**
   * 在此书写动画每一帧执行的函数
   * @param delta
   */
  function tickerFunc(delta: number) {
    if (target) {
      const container = target.pixiContainer;
      const baseDuration = WebGAL.gameplay.pixiStage!.frameDuration;
      const currentAddOplityDelta = (duration / baseDuration) * delta;
      const increasement = 1 / currentAddOplityDelta;
      const decreasement = 5 / currentAddOplityDelta;
      if (container)
        if (container.alpha < 1) {
          container.alpha += increasement;
        }
      // @ts-ignore
      if (container.blur < 5) {
        // @ts-ignore
        container.blur += decreasement;
      }
    }
  }

  return {
    setStartState,
    setEndState,
    tickerFunc,
  };
}



================================================
FILE: webgal/src/Core/controller/stage/pixi/animations/timeline.ts
================================================
import { ITransform } from '@/store/stageInterface';
import * as popmotion from 'popmotion';
import { WebGAL } from '@/Core/WebGAL';
import { webgalStore } from '@/store/store';
import { stageActions } from '@/store/stageReducer';
import omitBy from 'lodash/omitBy';
import isUndefined from 'lodash/isUndefined';
import PixiStage, { IAnimationObject } from '@/Core/controller/stage/pixi/PixiController';
import { AnimationFrame } from '@/Core/Modules/animations';

/**
 * 动画创建模板
 * @param timeline
 * @param targetKey 作用目标
 * @param duration 持续时间
 */
export function generateTimelineObj(
  timeline: Array<AnimationFrame>,
  targetKey: string,
  duration: number,
): IAnimationObject {
  for (const segment of timeline) {
    // Alpha 现在直接使用原生属性，无需转换为 alphaFilterVal
  }
  const target = WebGAL.gameplay.pixiStage!.getStageObjByKey(targetKey);
  let currentDelay = 0;
  const values = [];
  const easeArray: Array<popmotion.Easing> = [];
  const times: number[] = [];
  for (let i = 0; i < timeline.length; i++) {
    const segment = timeline[i];
    const segmentDuration = segment.duration;
    currentDelay += segmentDuration;
    const { position, scale, ...segmentValues } = segment;
    // 不能用 scale，因为 popmotion 不能用嵌套
    values.push({ x: position.x, y: position.y, scaleX: scale.x, scaleY: scale.y, ...segmentValues });
    // Easing 需要比 values 的长度少一个
    if (i > 0) {
      easeArray.push(stringToEasing(segment.ease));
    }
    if (duration !== 0) {
      times.push(currentDelay / duration);
    } else times.push(0);
  }
  const container = target?.pixiContainer;
  let animateInstance: ReturnType<typeof popmotion.animate> | null = null;
  // 只有有 duration 的时候才有动画
  if (duration > 0) {
    animateInstance = popmotion.animate({
      to: values,
      offset: times,
      duration,
      ease: easeArray,
      onUpdate: (updateValue) => {
        if (container) {
          const { scaleX, scaleY, ...val } = updateValue;
          // @ts-ignore
          PixiStage.assignTransform(container, omitBy(val, isUndefined));
          // 因为 popmotion 不能用嵌套，scale 要手动设置
          if (!isUndefined(scaleX)) container.scale.x = scaleX;
          if (!isUndefined(scaleY)) container.scale.y = scaleY;
        }
      },
    });
  }

  const { duration: sliceDuration, ...endState } = getEndStateEffect();
  webgalStore.dispatch(stageActions.updateEffect({ target: targetKey, transform: endState }));

  /**
   * 在此书写为动画设置初态的操作
   */
  function setStartState() {
    if (target?.pixiContainer) {
      // 不能赋值到 position，因为 x 和 y 被 WebGALPixiContainer 代理，而 position 属性没有代理
      const { position, scale, ...state } = getStartStateEffect();
      const assignValue = omitBy({ x: position.x, y: position.y, ...state }, isUndefined);
      // @ts-ignore
      PixiStage.assignTransform(target?.pixiContainer, assignValue);
      if (target?.pixiContainer) {
        if (!isUndefined(scale.x)) {
          target.pixiContainer.scale.x = scale.x;
        }
        if (!isUndefined(scale?.y)) {
          target.pixiContainer.scale.y = scale.y;
        }
      }
    }
  }

  /**
   * 在此书写为动画设置终态的操作
   */
  function setEndState() {
    if (!container) {
      return;
    }
    if (animateInstance) animateInstance.stop();
    animateInstance = null;
    if (target?.pixiContainer) {
      // 不能赋值到 position，因为 x 和 y 被 WebGALPixiContainer 代理，而 position 属性没有代理
      // 不能赋值到 position，因为 x 和 y 被 WebGALPixiContainer 代理，而 position 属性没有代理
      const { position, scale, ...state } = getEndStateEffect();
      const assignValue = omitBy({ x: position.x, y: position.y, ...state }, isUndefined);
      // @ts-ignore
      PixiStage.assignTransform(target?.pixiContainer, assignValue);
      if (target?.pixiContainer) {
        if (!isUndefined(scale.x)) {
          target.pixiContainer.scale.x = scale.x;
        }
        if (!isUndefined(scale?.y)) {
          target.pixiContainer.scale.y = scale.y;
        }
      }
    }
  }

  /**
   * 在此书写动画每一帧执行的函数
   * @param delta
   */
  function tickerFunc(delta: number) {}

  function getStartStateEffect() {
    return timeline[0];
  }

  function getEndStateEffect() {
    return timeline[timeline.length - 1];
  }

  function forceStopWithoutSetEndState() {
    if (animateInstance) animateInstance.stop();
    animateInstance = null;
  }

  return {
    setStartState,
    setEndState,
    tickerFunc,
    getEndStateEffect,
    forceStopWithoutSetEndState,
  };
}

const stringToEasing = (ease: string): popmotion.Easing => {
  let easeType = popmotion.easeInOut;
  switch (ease) {
    case 'easeInOut': {
      easeType = popmotion.easeInOut;
      break;
    }
    case 'easeIn': {
      easeType = popmotion.easeIn;
      break;
    }
    case 'easeOut': {
      easeType = popmotion.easeOut;
      break;
    }
    case 'circInOut': {
      easeType = popmotion.circInOut;
      break;
    }
    case 'circIn': {
      easeType = popmotion.circIn;
      break;
    }
    case 'circOut': {
      easeType = popmotion.circOut;
      break;
    }
    case 'backInOut': {
      easeType = popmotion.backInOut;
      break;
    }
    case 'backIn': {
      easeType = popmotion.backIn;
      break;
    }
    case 'backOut': {
      easeType = popmotion.backOut;
      break;
    }
    case 'bounceInOut': {
      easeType = popmotion.bounceInOut;
      break;
    }
    case 'bounceIn': {
      easeType = popmotion.bounceIn;
      break;
    }
    case 'bounceOut': {
      easeType = popmotion.bounceOut;
      break;
    }
    case 'linear': {
      easeType = popmotion.linear;
      break;
    }
    case 'anticipate': {
      easeType = popmotion.anticipate;
      break;
    }
  }
  return easeType;
};



================================================
FILE: webgal/src/Core/controller/stage/pixi/animations/universalSoftIn.ts
================================================
import { WebGAL } from '@/Core/WebGAL';

export function generateUniversalSoftInAnimationObj(targetKey: string, duration: number) {
  const target = WebGAL.gameplay.pixiStage!.getStageObjByKey(targetKey);
  let elapsedTime = 0;

  // 新增变量，用于存储动画开始时的初始透明度
  let startAlpha = 0;

  /**
   * 在此书写为动画设置初态的操作
   */
  function setStartState() {
    elapsedTime = 0; // Reset timer when animation starts
    if (target?.pixiContainer) {
      // 修正：不再强制设为 0，而是记录当前的透明度
      startAlpha = target.pixiContainer.alpha;
    }
  }

  /**
   * 在此书写为动画设置终态的操作
   */
  function setEndState() {
    if (target?.pixiContainer) {
      // 终态是完全不透明，这保持不变
      target.pixiContainer.alpha = 1;
    }
  }

  /**
   * 在此书写动画每一帧执行的函数
   * @param delta
   */
  function tickerFunc(delta: number) {
    if (target) {
      const sprite = target.pixiContainer;
      const baseDuration = WebGAL.gameplay.pixiStage!.frameDuration;

      elapsedTime += baseDuration;

      const realElapsedTime = Math.min(elapsedTime, duration);
      const progress = realElapsedTime / duration;

      // 使用 Cubic Ease-Out 函数，这对于“进入”动画感觉更自然
      const easedProgress = 1 - Math.pow(1 - progress, 3);

      // 修正：使用线性插值公式 (lerp)
      // 公式：最终值 = 初始值 + (目标值 - 初始值) * 进度
      // 在这里，目标值是 1，所以公式为：
      // alpha = startAlpha + (1 - startAlpha) * easedProgress
      if (sprite) sprite.alpha = startAlpha + (1 - startAlpha) * easedProgress;
    }
  }

  return {
    setStartState,
    setEndState,
    tickerFunc,
  };
}



================================================
FILE: webgal/src/Core/controller/stage/pixi/animations/universalSoftOff.ts
================================================
import { WebGAL } from '@/Core/WebGAL';

export function generateUniversalSoftOffAnimationObj(targetKey: string, duration: number) {
  const target = WebGAL.gameplay.pixiStage!.getStageObjByKey(targetKey);
  let elapsedTime = 0;

  // 新增变量，用于存储动画开始时的初始透明度
  let startAlpha = 1;

  /**
   * 在此书写为动画设置初态的操作
   */
  function setStartState() {
    elapsedTime = 0; // 重置计时器
    if (target?.pixiContainer) {
      // 修正：不再强制设为1，而是记录当前的透明度
      startAlpha = target.pixiContainer.alpha;
    }
  }

  /**
   * 在此书写为动画设置终态的操作
   */
  function setEndState() {
    if (target?.pixiContainer) {
      // 终态是完全透明，这保持不变
      target.pixiContainer.alpha = 0;
    }
  }

  /**
   * 在此书写动画每一帧执行的函数
   * @param delta
   */
  function tickerFunc(delta: number) {
    if (target) {
      const targetContainer = target.pixiContainer;
      const baseDuration = WebGAL.gameplay.pixiStage!.frameDuration;

      elapsedTime += baseDuration;

      const realElapsedTime = Math.min(elapsedTime, duration);
      const progress = realElapsedTime / duration;

      // 使用 Cubic Ease-In 函数
      const easedProgress = Math.pow(progress, 3);

      // 修正：基于初始透明度 startAlpha 进行计算
      // 公式：最终值 = 初始值 + (目标值 - 初始值) * 进度
      // 在这里，目标值是 0，所以公式简化为：
      // alpha = startAlpha + (0 - startAlpha) * easedProgress
      // alpha = startAlpha * (1 - easedProgress)
      if (targetContainer) targetContainer.alpha = startAlpha * (1 - easedProgress);
    }
  }

  return {
    setStartState,
    setEndState,
    tickerFunc,
  };
}



================================================
FILE: webgal/src/Core/controller/stage/pixi/shaders/BevelFilter.ts
================================================
import { Filter, FilterState, FilterSystem, RenderTexture } from '@pixi/core';
import { DEG_TO_RAD } from '@pixi/math';
import { rgb2hex, hex2rgb } from '@pixi/utils';
import { MotionBlurFilter } from 'pixi-filters';
import { CLEAR_MODES } from 'pixi.js';

interface BevelFilterOptions {
  rotation: number;
  thickness: number;
  lightColor: number;
  lightAlpha: number;
  shadowColor: number;
  shadowAlpha: number;
}

/**
 * Bevel Filter.<br>
 *
 * @class
 * @extends PIXI.Filter
 * @memberof PIXI.filters
 * @see {@link https://www.npmjs.com/package/@pixi/filter-bevel|@pixi/filter-bevel}
 * @see {@link https://www.npmjs.com/package/pixi-filters|pixi-filters}
 */
class BevelFilter extends Filter {
  private _thickness = 2;
  private _angle = 0;
  private _softness = 0;

  private _blurFilter = new MotionBlurFilter();

  /**
   * @param {object} [options] - The optional parameters of the filter.
   * @param {number} [options.rotation = 45] - The angle of the light in degrees.
   * @param {number} [options.thickness = 2] - The tickness of the bevel.
   * @param {number} [options.lightColor = 0xffffff] - Color of the light.
   * @param {number} [options.lightAlpha = 0.7] - Alpha of the light.
   * @param {number} [options.shadowColor = 0x000000] - Color of the shadow.
   * @param {number} [options.shadowAlpha = 0.7] - Alpha of the shadow.
   */
  public constructor(options?: Partial<BevelFilterOptions>) {
    const fragment = `precision mediump float;

varying vec2 vTextureCoord;
uniform sampler2D uSampler;
uniform sampler2D mask;
uniform vec4 filterArea;

uniform float transformX;
uniform float transformY;
uniform vec3 lightColor;
uniform float lightAlpha;
uniform vec3 shadowColor;
uniform float shadowAlpha;

void main(void) {
    vec2 transform = vec2(1.0 / filterArea) * vec2(transformX, transformY);
    vec4 color = texture2D(uSampler, vTextureCoord);
    float light = texture2D(mask, vTextureCoord - transform).a;
    float shadow = texture2D(mask, vTextureCoord + transform).a;

    // color.rgb = mix(color.rgb, lightColor, clamp((color.a - light) * lightAlpha, 0.0, 1.0));
    // color.rgb = mix(color.rgb, shadowColor, clamp((color.a - shadow) * shadowAlpha, 0.0, 1.0));

    // 滤色
    color.rgb = mix(color.rgb, vec3(1.0) - (vec3(1.0) - color.rgb) * (vec3(1.0) - lightColor), clamp((color.a - light) * lightAlpha, 0.0, 1.0));
    // 正片叠底(相乘)
    color.rgb = mix(color.rgb, color.rgb * shadowColor, clamp((color.a - shadow) * shadowAlpha, 0.0, 1.0));

    gl_FragColor = vec4(color.rgb, color.a);
}`;
    super(null as any, fragment);

    this.uniforms.lightColor = new Float32Array(3);
    this.uniforms.shadowColor = new Float32Array(3);

    Object.assign(
      this,
      {
        rotation: 45,
        thickness: 2,
        lightColor: 0xffffff,
        lightAlpha: 0.7,
        shadowColor: 0x000000,
        shadowAlpha: 0.7,
      },
      options,
    );

    // Workaround: https://github.com/pixijs/filters/issues/230
    // applies correctly only if there is at least a single-pixel padding with alpha=0 around an image
    // To solve this problem, a padding of 1 put on the filter should suffice
    this.padding = 1;

    this._blurFilter.kernelSize = 11;
  }

  // eslint-disable-next-line max-params
  public apply(
    filterManager: FilterSystem,
    input: RenderTexture,
    output: RenderTexture,
    clearMode?: CLEAR_MODES,
    _currentState?: FilterState,
  ): void {
    if (this.softness > 0) {
      const blurTexture = filterManager.getFilterTexture();
      this._blurFilter.apply(filterManager, input, blurTexture, CLEAR_MODES.YES);

      this.uniforms.mask = blurTexture;
      filterManager.applyFilter(this, input, output, clearMode);

      filterManager.returnFilterTexture(blurTexture);
    } else {
      this.uniforms.mask = input;
      filterManager.applyFilter(this, input, output, clearMode);
    }
  }

  /**
   * Update the transform matrix of offset angle.
   * @private
   */
  private _updateTransform() {
    this.uniforms.transformX = this._thickness * Math.cos(this._angle);
    this.uniforms.transformY = this._thickness * Math.sin(this._angle);
  }

  private _updateBlur() {
    this._blurFilter.velocity.set(
      Math.cos(this._angle) * this.thickness * this.softness * -1,
      Math.sin(this._angle) * this.thickness * this.softness * -1,
    );
  }

  /**
   * The angle of the light in degrees.
   * @default 45
   */
  public get rotation(): number {
    return this._angle / DEG_TO_RAD;
  }
  public set rotation(value: number) {
    this._angle = value * DEG_TO_RAD;
    this._updateTransform();
    this._updateBlur();
  }

  /**
   * The tickness of the bevel.
   * @default 2
   */
  public get thickness(): number {
    return this._thickness;
  }
  public set thickness(value: number) {
    this._thickness = value;
    this._updateTransform();
    this._updateBlur();
  }

  /**
   * The tickness of the bevel. Range [0, 1]
   * @default 0
   */
  public get softness(): number {
    return this._softness;
  }
  public set softness(value: number) {
    this._softness = Math.min(Math.max(value, 0), 1);
    this._updateBlur();
  }

  /**
   * Color of the light.
   * @default 0xffffff
   */
  public get lightColor(): number {
    return rgb2hex(this.uniforms.lightColor);
  }
  public set lightColor(value: number) {
    hex2rgb(value, this.uniforms.lightColor);
  }

  /**
   * Alpha of the light.
   * @default 0.7
   */
  public get lightAlpha(): number {
    return this.uniforms.lightAlpha;
  }
  public set lightAlpha(value: number) {
    this.uniforms.lightAlpha = value;
  }

  /**
   * Color of the shadow.
   * @default 0x000000
   */
  public get shadowColor(): number {
    return rgb2hex(this.uniforms.shadowColor);
  }
  public set shadowColor(value: number) {
    hex2rgb(value, this.uniforms.shadowColor);
  }

  /**
   * Alpha of the shadow.
   * @default 0.7
   */
  public get shadowAlpha(): number {
    return this.uniforms.shadowAlpha;
  }
  public set shadowAlpha(value: number) {
    this.uniforms.shadowAlpha = value;
  }
}

export { BevelFilter };
export type { BevelFilterOptions };



================================================
FILE: webgal/src/Core/controller/stage/pixi/shaders/RadiusAlphaFilter.ts
================================================
import * as PIXI from 'pixi.js';
import { WebGALPixiContainer } from '@/Core/controller/stage/pixi/WebGALPixiContainer';

export const INIT_RAD = 0;
const FILTER_NAME = 'radiusAlphaFilter';

export class RadiusAlphaFilter extends PIXI.Filter {
  public constructor(center: PIXI.Point, radius: number) {
    const fragmentShader = `
// 半径透明度的fragment shader
precision mediump float;

uniform sampler2D uSampler;  // 输入纹理
varying vec2 vTextureCoord;  // 当前片元的纹理坐标
uniform vec2 center;         // 圆心坐标
uniform float radius;        // 圆的半径

void main(void) {
    vec4 color = texture2D(uSampler, vTextureCoord);

    // 计算屏幕宽高比
    float aspect = 16.0 / 9.0;

    // 根据宽高比校正纹理坐标
    vec2 aspectCorrectCoord = vTextureCoord;
    aspectCorrectCoord.x *= aspect;

    // 计算片元到圆心的距离
    float dist = distance(aspectCorrectCoord, center * vec2(aspect, 1.0));

    // 使用smoothstep函数计算alpha值,实现边缘羽化效果
    float alpha = smoothstep(radius, radius + 0.05, dist);

    // 输出最终颜色
    gl_FragColor = color * (1.0 - alpha);
}
    `; // 填入上面的fragment shader代码
    super(null as any, fragmentShader);
    this.uniforms.center = [center.x, center.y];
    this.uniforms.radius = radius;
  }

  public set center(value: PIXI.Point) {
    this.uniforms.center = [value.x, value.y];
  }

  public get center(): PIXI.Point {
    return new PIXI.Point(this.uniforms.center[0], this.uniforms.center[1]);
  }

  public set radius(value: number) {
    this.uniforms.radius = value;
  }

  public get radius(): number {
    return this.uniforms.radius;
  }
}



================================================
FILE: webgal/src/Core/controller/storage/fastSaveLoad.ts
================================================
import { webgalStore } from '@/store/store';
import { getStorageAsync, setStorageAsync } from '@/Core/controller/storage/storageController';
import { ISaveData } from '@/store/userDataInterface';
import { loadGameFromStageData } from '@/Core/controller/storage/loadGame';
import { generateCurrentStageData } from '@/Core/controller/storage/saveGame';
import cloneDeep from 'lodash/cloneDeep';
import { WebGAL } from '@/Core/WebGAL';
import { saveActions } from '@/store/savesReducer';
import { dumpFastSaveToStorage, getFastSaveFromStorage } from '@/Core/controller/storage/savesController';

export let fastSaveGameKey = '';
export let isFastSaveKey = '';
let lock = true;

export function initKey() {
  lock = false;
  fastSaveGameKey = `FastSaveKey-${WebGAL.gameName}-${WebGAL.gameKey}`;
  isFastSaveKey = `FastSaveActive-${WebGAL.gameName}-${WebGAL.gameKey}`;
}

/**
 * 用于紧急回避时的数据存储 & 快速保存
 */
export async function fastSaveGame() {
  const saveData: ISaveData = generateCurrentStageData(-1, false);
  const newSaveData = cloneDeep(saveData);
  webgalStore.dispatch(saveActions.setFastSave(newSaveData));
  await dumpFastSaveToStorage();
}

/**
 * 判断是否有无存储紧急回避时的数据
 */
export async function hasFastSaveRecord() {
  // return await localforage.getItem(isFastSaveKey);
  await getStorageAsync();
  return webgalStore.getState().saveData.quickSaveData !== null;
}

/**
 * 加载紧急回避时的数据
 */
export async function loadFastSaveGame() {
  // 获得存档文件
  // const loadFile: ISaveData | null = await localforage.getItem(fastSaveGameKey);
  await getFastSaveFromStorage();
  const loadFile: ISaveData | null = webgalStore.getState().saveData.quickSaveData;
  if (!loadFile) {
    return;
  }
  loadGameFromStageData(loadFile);
}

/**
 * 移除紧急回避的数据
 */
export async function removeFastSaveGameRecord() {
  webgalStore.dispatch(saveActions.resetFastSave());
  await setStorageAsync();
  // await localforage.setItem(isFastSaveKey, false);
  // await localforage.setItem(fastSaveGameKey, null);
}



================================================
FILE: webgal/src/Core/controller/storage/jumpFromBacklog.ts
================================================
import { logger } from '../../util/logger';
import { sceneFetcher } from '../scene/sceneFetcher';
import { sceneParser } from '../../parser/sceneParser';
import { IStageState } from '@/store/stageInterface';
import { webgalStore } from '@/store/store';
import { resetStageState, stageActions } from '@/store/stageReducer';
import { setVisibility } from '@/store/GUIReducer';
import { runScript } from '@/Core/controller/gamePlay/runScript';
import { stopAllPerform } from '@/Core/controller/gamePlay/stopAllPerform';
import cloneDeep from 'lodash/cloneDeep';
import uniqWith from 'lodash/uniqWith';
import { scenePrefetcher } from '@/Core/util/prefetcher/scenePrefetcher';

import { WebGAL } from '@/Core/WebGAL';

/**
 * 恢复演出
 */
export const restorePerform = () => {
  const stageState = webgalStore.getState().stage;
  const performToRestore = cloneDeep(stageState.PerformList);
  // 清除状态表中演出序列
  webgalStore.dispatch(stageActions.removeAllPerform());
  performToRestore.forEach((e) => {
    runScript(e.script);
  });
};

/**
 * 从 backlog 跳转至一个先前的状态
 * @param index
 * @param refetchScene
 */
export const jumpFromBacklog = (index: number, refetchScene = true) => {
  const dispatch = webgalStore.dispatch;
  // 获得存档文件
  const backlogFile = WebGAL.backlogManager.getBacklog()[index];
  logger.debug('读取的backlog数据', backlogFile);
  // 重新获取并同步场景状态
  if (refetchScene)
    sceneFetcher(backlogFile.saveScene.sceneUrl).then((rawScene) => {
      WebGAL.sceneManager.sceneData.currentScene = sceneParser(
        rawScene,
        backlogFile.saveScene.sceneName,
        backlogFile.saveScene.sceneUrl,
      );
      // 开始场景的预加载
      const subSceneList = WebGAL.sceneManager.sceneData.currentScene.subSceneList;
      WebGAL.sceneManager.settledScenes.push(WebGAL.sceneManager.sceneData.currentScene.sceneUrl); // 放入已加载场景列表，避免递归加载相同场景
      const subSceneListUniq = uniqWith(subSceneList); // 去重
      scenePrefetcher(subSceneListUniq);
    });
  WebGAL.sceneManager.sceneData.currentSentenceId = backlogFile.saveScene.currentSentenceId;
  WebGAL.sceneManager.sceneData.sceneStack = cloneDeep(backlogFile.saveScene.sceneStack);

  // 强制停止所有演出
  stopAllPerform();

  // 弹出backlog项目到指定状态
  for (let i = WebGAL.backlogManager.getBacklog().length - 1; i > index; i--) {
    WebGAL.backlogManager.getBacklog().pop();
  }

  // 要记录本句 Backlog
  WebGAL.backlogManager.isSaveBacklogNext = true;

  // 恢复舞台状态
  const newStageState: IStageState = cloneDeep(backlogFile.currentStageState);

  dispatch(resetStageState(newStageState));

  // 恢复演出
  setTimeout(restorePerform, 0);

  // 关闭backlog界面
  dispatch(setVisibility({ component: 'showBacklog', visibility: false }));

  // 重新显示 TextBox
  dispatch(setVisibility({ component: 'showTextBox', visibility: true }));
};



================================================
FILE: webgal/src/Core/controller/storage/loadGame.ts
================================================
import { ISaveData } from '@/store/userDataInterface';
import { logger } from '../../util/logger';
import { sceneFetcher } from '../scene/sceneFetcher';
import { sceneParser } from '../../parser/sceneParser';
import { webgalStore } from '@/store/store';
import { resetStageState } from '@/store/stageReducer';
import { setVisibility } from '@/store/GUIReducer';
import { restorePerform } from './jumpFromBacklog';
import { stopAllPerform } from '@/Core/controller/gamePlay/stopAllPerform';
import cloneDeep from 'lodash/cloneDeep';
import uniqWith from 'lodash/uniqWith';
import { scenePrefetcher } from '@/Core/util/prefetcher/scenePrefetcher';
import { setEbg } from '@/Core/gameScripts/changeBg/setEbg';

import { WebGAL } from '@/Core/WebGAL';

/**
 * 读取游戏存档
 * @param index 要读取的存档的档位
 */
export const loadGame = (index: number) => {
  const userDataState = webgalStore.getState().saveData;
  // 获得存档文件
  const loadFile: ISaveData = userDataState.saveData[index];
  logger.debug('读取的存档数据', loadFile);
  // 加载存档
  loadGameFromStageData(loadFile);
};

export function loadGameFromStageData(stageData: ISaveData) {
  if (!stageData) {
    logger.info('暂无存档');
    return;
  }
  const loadFile = stageData;
  // 重新获取并同步场景状态
  sceneFetcher(loadFile.sceneData.sceneUrl).then((rawScene) => {
    WebGAL.sceneManager.sceneData.currentScene = sceneParser(
      rawScene,
      loadFile.sceneData.sceneName,
      loadFile.sceneData.sceneUrl,
    );
    // 开始场景的预加载
    const subSceneList = WebGAL.sceneManager.sceneData.currentScene.subSceneList;
    WebGAL.sceneManager.settledScenes.push(WebGAL.sceneManager.sceneData.currentScene.sceneUrl); // 放入已加载场景列表，避免递归加载相同场景
    const subSceneListUniq = uniqWith(subSceneList); // 去重
    scenePrefetcher(subSceneListUniq);
  });
  WebGAL.sceneManager.sceneData.currentSentenceId = loadFile.sceneData.currentSentenceId;
  WebGAL.sceneManager.sceneData.sceneStack = cloneDeep(loadFile.sceneData.sceneStack);

  // 强制停止所有演出
  stopAllPerform();

  // 恢复backlog
  const newBacklog = loadFile.backlog;
  WebGAL.backlogManager.getBacklog().splice(0, WebGAL.backlogManager.getBacklog().length); // 清空原backlog
  for (const e of newBacklog) {
    WebGAL.backlogManager.getBacklog().push(e);
  }

  // 恢复舞台状态
  const newStageState = cloneDeep(loadFile.nowStageState);
  const dispatch = webgalStore.dispatch;
  dispatch(resetStageState(newStageState));

  // 恢复演出
  setTimeout(restorePerform, 0);
  // restorePerform();

  dispatch(setVisibility({ component: 'showTitle', visibility: false }));
  dispatch(setVisibility({ component: 'showMenuPanel', visibility: false }));
  /**
   * 恢复模糊背景
   */
  setEbg(webgalStore.getState().stage.bgName);
}



================================================
FILE: webgal/src/Core/controller/storage/saveGame.ts
================================================
import { logger } from '../../util/logger';
import { ISaveData } from '@/store/userDataInterface';
import { dumpToStorageFast } from './storageController';
import { webgalStore } from '@/store/store';
import { setUserData } from '@/store/userDataReducer';
import cloneDeep from 'lodash/cloneDeep';

import { WebGAL } from '@/Core/WebGAL';
import { saveActions } from '@/store/savesReducer';
import { dumpSavesToStorage } from '@/Core/controller/storage/savesController';

/**
 * 保存游戏
 * @param index 游戏的档位
 */
export const saveGame = (index: number) => {
  const saveData: ISaveData = generateCurrentStageData(index);
  webgalStore.dispatch(saveActions.saveGame({ index, saveData }));
  dumpSavesToStorage(index, index);
};

/**
 * 生成现在游戏的数据快照
 * @param index 游戏的档位
 */
export function generateCurrentStageData(index: number, isSavePreviewImage = true) {
  const stageState = webgalStore.getState().stage;
  const saveBacklog = cloneDeep(WebGAL.backlogManager.getBacklog());

  /**
   * 生成缩略图
   */

  let urlToSave = '';
  if (isSavePreviewImage) {
    const canvas: HTMLCanvasElement = document.getElementById('pixiCanvas')! as HTMLCanvasElement;
    const canvas2 = document.createElement('canvas');
    const context = canvas2.getContext('2d');
    canvas2.width = 480;
    canvas2.height = 270;
    context!.drawImage(canvas, 0, 0, 480, 270);
    urlToSave = canvas2.toDataURL('image/webp', 0.5);
    canvas2.remove();
  }
  const saveData: ISaveData = {
    nowStageState: cloneDeep(stageState),
    backlog: saveBacklog, // 舞台数据
    index: index, // 存档的序号
    saveTime: new Date().toLocaleDateString() + ' ' + new Date().toLocaleTimeString('chinese', { hour12: false }), // 保存时间
    // 场景数据
    sceneData: {
      currentSentenceId: WebGAL.sceneManager.sceneData.currentSentenceId, // 当前语句ID
      sceneStack: cloneDeep(WebGAL.sceneManager.sceneData.sceneStack), // 场景栈
      sceneName: WebGAL.sceneManager.sceneData.currentScene.sceneName, // 场景名称
      sceneUrl: WebGAL.sceneManager.sceneData.currentScene.sceneUrl, // 场景url
    },
    previewImage: urlToSave,
  };
  return saveData;
}



================================================
FILE: webgal/src/Core/controller/storage/savesController.ts
================================================
import localforage from 'localforage';
import { WebGAL } from '@/Core/WebGAL';
import { logger } from '@/Core/util/logger';
import { webgalStore } from '@/store/store';
import { saveActions } from '@/store/savesReducer';
import { ISaveData } from '@/store/userDataInterface';

export function dumpSavesToStorage(startIndex: number, endIndex: number) {
  for (let i = startIndex; i <= endIndex; i++) {
    const save = webgalStore.getState().saveData.saveData[i];
    localforage.setItem(`${WebGAL.gameKey}-saves${i}`, save).then(() => {
      logger.info(`存档${i}写入本地存储`);
    });
  }
}

export function getSavesFromStorage(startIndex: number, endIndex: number) {
  for (let i = startIndex; i <= endIndex; i++) {
    localforage.getItem(`${WebGAL.gameKey}-saves${i}`).then((save) => {
      webgalStore.dispatch(saveActions.saveGame({ index: i, saveData: save as ISaveData }));
      logger.info(`存档${i}读取自本地存储`);
    });
  }
}

export async function dumpFastSaveToStorage() {
  const save = webgalStore.getState().saveData.quickSaveData;
  await localforage.setItem(`${WebGAL.gameKey}-saves-fast`, save);
  logger.info(`快速存档写入本地存储`);
}

export async function getFastSaveFromStorage() {
  const save = await localforage.getItem(`${WebGAL.gameKey}-saves-fast`);
  webgalStore.dispatch(saveActions.setFastSave(save as ISaveData));
  logger.info(`快速存档读取自本地存储`);
}



================================================
FILE: webgal/src/Core/controller/storage/storageController.ts
================================================
import * as localforage from 'localforage';
import { IUserData } from '@/store/userDataInterface';
import { logger } from '../../util/logger';
import { webgalStore } from '@/store/store';
import { initState, resetUserData } from '@/store/userDataReducer';

import { WebGAL } from '@/Core/WebGAL';

/**
 * 写入本地存储
 */
export const setStorage = debounce(() => {
  const userDataState = webgalStore.getState().userData;
  localforage.setItem(WebGAL.gameKey, userDataState).then(() => {
    logger.info('写入本地存储');
  });
}, 100);

/**
 * 从本地存储获取数据
 */
export const getStorage = debounce(() => {
  localforage.getItem(WebGAL.gameKey).then((newUserData) => {
    // 如果没有数据或者属性不完全，重新初始化
    if (!newUserData || !checkUserDataProperty(newUserData)) {
      logger.warn('现在重置数据');
      setStorage();
      return;
    }
    webgalStore.dispatch(resetUserData(newUserData as IUserData));
  });
}, 100);

/**
 * 防抖函数
 * @param func 要执行的函数
 * @param wait 防抖等待时间
 */
function debounce<T, K>(func: (...args: T[]) => K, wait: number) {
  let timeout: ReturnType<typeof setTimeout>;

  function context(...args: T[]): K {
    clearTimeout(timeout);
    let ret!: K;
    timeout = setTimeout(() => {
      ret = func.apply(context, args);
    }, wait);
    return ret;
  }

  return context;
}

export const dumpToStorageFast = () => {
  const userDataState = webgalStore.getState().userData;
  localforage.setItem(WebGAL.gameKey, userDataState).then(() => {
    localforage.getItem(WebGAL.gameKey).then((newUserData) => {
      // 如果没有数据，初始化
      if (!newUserData) {
        setStorage();
        return;
      }
      webgalStore.dispatch(resetUserData(newUserData as IUserData));
    });
    logger.info('同步本地存储');
  });
};

/**
 * 检查用户数据属性是否齐全
 * @param userData 需要检查的数据
 */
function checkUserDataProperty(userData: any) {
  let result = true;
  for (const key in initState) {
    if (!userData.hasOwnProperty(key)) {
      result = false;
    }
  }
  return result;
}

export async function setStorageAsync() {
  const userDataState = webgalStore.getState().userData;
  return await localforage.setItem(WebGAL.gameKey, userDataState);
}

export async function getStorageAsync() {
  const newUserData = await localforage.getItem(WebGAL.gameKey);
  if (!newUserData || !checkUserDataProperty(newUserData)) {
    const userDataState = webgalStore.getState().userData;
    logger.warn('现在重置数据');
    return await localforage.setItem(WebGAL.gameKey, userDataState);
  } else webgalStore.dispatch(resetUserData(newUserData as IUserData));
  return;
}



================================================
FILE: webgal/src/Core/gameScripts/applyStyle.ts
================================================
import { ISentence } from '@/Core/controller/scene/sceneInterface';
import { IPerform } from '@/Core/Modules/perform/performInterface';
import { webgalStore } from '@/store/store';
import { stageActions } from '@/store/stageReducer';

/**
 * 语句执行的模板代码
 * @param sentence
 */
export const applyStyle = (sentence: ISentence): IPerform => {
  const { content } = sentence;
  const applyStyleSegments = content.split(',');
  for (const applyStyleSegment of applyStyleSegments) {
    const splitSegment = applyStyleSegment.split('->');
    if (splitSegment.length >= 2) {
      const classNameToBeChange = splitSegment[0];
      const classNameChangeTo = splitSegment[1];
      webgalStore.dispatch(stageActions.replaceUIlable([classNameToBeChange, classNameChangeTo]));
    }
  }
  return {
    performName: 'none',
    duration: 0,
    isHoldOn: false,
    stopFunction: () => {},
    blockingNext: () => false,
    blockingAuto: () => true,
    stopTimeout: undefined, // 暂时不用，后面会交给自动清除
  };
};



================================================
FILE: webgal/src/Core/gameScripts/bgm.ts
================================================
import { ISentence } from '@/Core/controller/scene/sceneInterface';
import { IPerform } from '@/Core/Modules/perform/performInterface';
import { playBgm } from '@/Core/controller/stage/playBgm';
import { getNumberArgByKey, getStringArgByKey } from '@/Core/util/getSentenceArg';
import { webgalStore } from '@/store/store';
import { unlockBgmInUserData } from '@/store/userDataReducer';

/**
 * 播放一段bgm
 * @param sentence
 */
export const bgm = (sentence: ISentence): IPerform => {
  let url: string = sentence.content; // 获取bgm的url
  const name = getStringArgByKey(sentence, 'unlockname') ?? '';
  const series = getStringArgByKey(sentence, 'series') ?? 'default';
  let enter = getNumberArgByKey(sentence, 'enter') ?? 0; // 获取bgm的淡入时间
  enter = Math.max(0, enter); // 限制淡入时间在 0 以上
  let volume = getNumberArgByKey(sentence, 'volume') ?? 100; // 获取bgm的音量比
  volume = Math.max(0, Math.min(volume, 100)); // 限制音量在 0-100 之间

  if (name !== '') {
    webgalStore.dispatch(unlockBgmInUserData({ name, url, series }));
  }

  playBgm(url, enter, volume);

  return {
    performName: 'none',
    duration: 0,
    isHoldOn: true,
    stopFunction: () => {},
    blockingNext: () => false,
    blockingAuto: () => true,
    stopTimeout: undefined, // 暂时不用，后面会交给自动清除
  };
};



================================================
FILE: webgal/src/Core/gameScripts/callSceneScript.ts
================================================
import { ISentence } from '@/Core/controller/scene/sceneInterface';
import { IPerform } from '@/Core/Modules/perform/performInterface';
import { callScene } from '../controller/scene/callScene';

/**
 * 调用一个场景，在场景结束后回到调用这个场景的父场景。
 * @param sentence
 */
export const callSceneScript = (sentence: ISentence): IPerform => {
  const sceneNameArray: Array<string> = sentence.content.split('/');
  const sceneName = sceneNameArray[sceneNameArray.length - 1];
  callScene(sentence.content, sceneName);
  return {
    performName: 'none',
    duration: 0,
    isHoldOn: true,
    stopFunction: () => {},
    blockingNext: () => false,
    blockingAuto: () => true,
    stopTimeout: undefined, // 暂时不用，后面会交给自动清除
  };
};



================================================
FILE: webgal/src/Core/gameScripts/changeFigure.ts
================================================
import { ISentence } from '@/Core/controller/scene/sceneInterface';
import { IPerform } from '@/Core/Modules/perform/performInterface';
import { webgalStore } from '@/store/store';
import { setStage, stageActions } from '@/store/stageReducer';
import cloneDeep from 'lodash/cloneDeep';
import { getBooleanArgByKey, getNumberArgByKey, getStringArgByKey } from '@/Core/util/getSentenceArg';
import { IFreeFigure, IStageState, ITransform } from '@/store/stageInterface';
import { AnimationFrame, IUserAnimation } from '@/Core/Modules/animations';
import { generateTransformAnimationObj } from '@/Core/controller/stage/pixi/animations/generateTransformAnimationObj';
import { assetSetter, fileType } from '@/Core/util/gameAssetsAccess/assetSetter';
import { logger } from '@/Core/util/logger';
import { getAnimateDuration } from '@/Core/Modules/animationFunctions';
import { WebGAL } from '@/Core/WebGAL';
import { baseBlinkParam, baseFocusParam, BlinkParam, FocusParam } from '@/Core/live2DCore';
import { DEFALUT_FIG_IN_DURATION, WEBGAL_NONE } from '../constants';
/**
 * 更改立绘
 * @param sentence 语句
 */
// eslint-disable-next-line complexity
export function changeFigure(sentence: ISentence): IPerform {
  // 语句内容
  let content = sentence.content;
  if (content === WEBGAL_NONE) {
    content = '';
  }
  if (getBooleanArgByKey(sentence, 'clear')) {
    content = '';
  }

  // 根据参数设置指定位置
  let pos: 'center' | 'left' | 'right' = 'center';
  let mouthAnimationKey = 'mouthAnimation';
  let eyesAnimationKey = 'blinkAnimation';
  const leftFromArgs = getBooleanArgByKey(sentence, 'left') ?? false;
  const rightFromArgs = getBooleanArgByKey(sentence, 'right') ?? false;
  if (leftFromArgs) {
    pos = 'left';
    mouthAnimationKey = 'mouthAnimationLeft';
    eyesAnimationKey = 'blinkAnimationLeft';
  }
  if (rightFromArgs) {
    pos = 'right';
    mouthAnimationKey = 'mouthAnimationRight';
    eyesAnimationKey = 'blinkAnimationRight';
  }

  // id 与 自由立绘
  let key = getStringArgByKey(sentence, 'id') ?? '';
  const isFreeFigure = key ? true : false;
  const id = key ? key : `fig-${pos}`;

  // live2d 或 spine 相关
  let motion = getStringArgByKey(sentence, 'motion') ?? '';
  let expression = getStringArgByKey(sentence, 'expression') ?? '';
  const boundsFromArgs = getStringArgByKey(sentence, 'bounds') ?? '';
  let bounds = getOverrideBoundsArr(boundsFromArgs);

  let blink: BlinkParam | null = null;
  const blinkFromArgs = getStringArgByKey(sentence, 'blink');
  if (blinkFromArgs) {
    try {
      blink = JSON.parse(blinkFromArgs) as BlinkParam;
    } catch (error) {
      logger.error('Failed to parse blink parameter:', error);
    }
  }

  let focus: FocusParam | null = null;
  const focusFromArgs = getStringArgByKey(sentence, 'focus');
  if (focusFromArgs) {
    try {
      focus = JSON.parse(focusFromArgs) as FocusParam;
    } catch (error) {
      logger.error('Failed to parse focus parameter:', error);
    }
  }

  // 图片立绘差分
  const mouthOpen = assetSetter(getStringArgByKey(sentence, 'mouthOpen') ?? '', fileType.figure);
  const mouthClose = assetSetter(getStringArgByKey(sentence, 'mouthClose') ?? '', fileType.figure);
  const mouthHalfOpen = assetSetter(getStringArgByKey(sentence, 'mouthHalfOpen') ?? '', fileType.figure);
  const eyesOpen = assetSetter(getStringArgByKey(sentence, 'eyesOpen') ?? '', fileType.figure);
  const eyesClose = assetSetter(getStringArgByKey(sentence, 'eyesClose') ?? '', fileType.figure);
  const animationFlag = getStringArgByKey(sentence, 'animationFlag') ?? '';

  // 其他参数
  const transformString = getStringArgByKey(sentence, 'transform');
  const ease = getStringArgByKey(sentence, 'ease') ?? '';
  let duration = getNumberArgByKey(sentence, 'duration') ?? DEFALUT_FIG_IN_DURATION;
  const enterAnimation = getStringArgByKey(sentence, 'enter');
  const exitAnimation = getStringArgByKey(sentence, 'exit');
  let zIndex = getNumberArgByKey(sentence, 'zIndex') ?? -1;

  const dispatch = webgalStore.dispatch;

  const currentFigureAssociatedAnimation = webgalStore.getState().stage.figureAssociatedAnimation;
  const filteredFigureAssociatedAnimation = currentFigureAssociatedAnimation.filter((item) => item.targetId !== id);
  const newFigureAssociatedAnimationItem = {
    targetId: id,
    animationFlag: animationFlag,
    mouthAnimation: {
      open: mouthOpen,
      close: mouthClose,
      halfOpen: mouthHalfOpen,
    },
    blinkAnimation: {
      open: eyesOpen,
      close: eyesClose,
    },
  };
  filteredFigureAssociatedAnimation.push(newFigureAssociatedAnimationItem);
  dispatch(setStage({ key: 'figureAssociatedAnimation', value: filteredFigureAssociatedAnimation }));

  /**
   * 如果 url 没变，不移除
   */
  let isUrlChanged = true;
  if (key !== '') {
    const figWithKey = webgalStore.getState().stage.freeFigure.find((e) => e.key === key);
    if (figWithKey) {
      if (figWithKey.name === sentence.content) {
        isUrlChanged = false;
      }
    }
  } else {
    if (pos === 'center') {
      if (webgalStore.getState().stage.figName === sentence.content) {
        isUrlChanged = false;
      }
    }
    if (pos === 'left') {
      if (webgalStore.getState().stage.figNameLeft === sentence.content) {
        isUrlChanged = false;
      }
    }
    if (pos === 'right') {
      if (webgalStore.getState().stage.figNameRight === sentence.content) {
        isUrlChanged = false;
      }
    }
  }
  /**
   * 处理 Effects
   */
  if (isUrlChanged) {
    webgalStore.dispatch(stageActions.removeEffectByTargetId(id));
    const oldStageObject = WebGAL.gameplay.pixiStage?.getStageObjByKey(id);
    if (oldStageObject) {
      oldStageObject.isExiting = true;
    }
  }
  const setAnimationNames = (key: string, sentence: ISentence) => {
    // 处理 transform 和 默认 transform
    let animationObj: AnimationFrame[];
    if (transformString) {
      console.log(transformString);
      try {
        const frame = JSON.parse(transformString) as AnimationFrame;
        animationObj = generateTransformAnimationObj(key, frame, duration, ease);
        // 因为是切换，必须把一开始的 alpha 改为 0
        animationObj[0].alpha = 0;
        const animationName = (Math.random() * 10).toString(16);
        const newAnimation: IUserAnimation = { name: animationName, effects: animationObj };
        WebGAL.animationManager.addAnimation(newAnimation);
        duration = getAnimateDuration(animationName);
        WebGAL.animationManager.nextEnterAnimationName.set(key, animationName);
      } catch (e) {
        // 解析都错误了，歇逼吧
        applyDefaultTransform();
      }
    } else {
      applyDefaultTransform();
    }

    function applyDefaultTransform() {
      // 应用默认的
      const frame = {};
      animationObj = generateTransformAnimationObj(key, frame as AnimationFrame, duration, ease);
      // 因为是切换，必须把一开始的 alpha 改为 0
      animationObj[0].alpha = 0;
      const animationName = (Math.random() * 10).toString(16);
      const newAnimation: IUserAnimation = { name: animationName, effects: animationObj };
      WebGAL.animationManager.addAnimation(newAnimation);
      duration = getAnimateDuration(animationName);
      WebGAL.animationManager.nextEnterAnimationName.set(key, animationName);
    }

    if (enterAnimation) {
      WebGAL.animationManager.nextEnterAnimationName.set(key, enterAnimation);
      duration = getAnimateDuration(enterAnimation);
    }
    if (exitAnimation) {
      WebGAL.animationManager.nextExitAnimationName.set(key + '-off', exitAnimation);
      duration = getAnimateDuration(exitAnimation);
    }
  };

  function postFigureStateSet() {
    if (isUrlChanged) {
      // 当 url 发生变化时，即发生新立绘替换
      // 应当赋予一些参数以默认值，防止从旧立绘的状态获取数据
      // 并且关闭一些 hold 动画
      WebGAL.gameplay.performController.unmountPerform(`animation-${key}`, true);
      bounds = bounds ?? [0, 0, 0, 0];
      blink = blink ?? cloneDeep(baseBlinkParam);
      focus = focus ?? cloneDeep(baseFocusParam);
      zIndex = Math.max(zIndex, 0);
      dispatch(stageActions.setLive2dMotion({ target: key, motion, overrideBounds: bounds }));
      dispatch(stageActions.setLive2dExpression({ target: key, expression }));
      dispatch(stageActions.setLive2dBlink({ target: key, blink }));
      dispatch(stageActions.setLive2dFocus({ target: key, focus }));
      dispatch(stageActions.setFigureMetaData([key, 'zIndex', zIndex, false]));
    } else {
      // 当 url 没有发生变化时，即没有新立绘替换
      // 应当保留旧立绘的状态，仅在需要时更新
      if (motion || bounds) {
        dispatch(stageActions.setLive2dMotion({ target: key, motion, overrideBounds: bounds }));
      }
      if (expression) {
        dispatch(stageActions.setLive2dExpression({ target: key, expression }));
      }
      if (blink) {
        dispatch(stageActions.setLive2dBlink({ target: key, blink }));
      }
      if (focus) {
        dispatch(stageActions.setLive2dFocus({ target: key, focus }));
      }
      if (zIndex >= 0) {
        dispatch(stageActions.setFigureMetaData([key, 'zIndex', zIndex, false]));
      }
    }
  }

  if (isFreeFigure) {
    /**
     * 下面的代码是设置自由立绘的
     */
    const freeFigureItem: IFreeFigure = { key, name: content, basePosition: pos };
    setAnimationNames(key, sentence);
    postFigureStateSet();
    dispatch(stageActions.setFreeFigureByKey(freeFigureItem));
  } else {
    /**
     * 下面的代码是设置与位置关联的立绘的
     */
    const positionMap = {
      center: 'fig-center',
      left: 'fig-left',
      right: 'fig-right',
    };
    const dispatchMap: Record<string, keyof IStageState> = {
      center: 'figName',
      left: 'figNameLeft',
      right: 'figNameRight',
    };

    key = positionMap[pos];
    setAnimationNames(key, sentence);
    postFigureStateSet();
    dispatch(setStage({ key: dispatchMap[pos], value: content }));
  }

  return {
    performName: `enter-${key}`,
    duration,
    isHoldOn: false,
    stopFunction: () => {
      WebGAL.gameplay.pixiStage?.stopPresetAnimationOnTarget(key);
    },
    blockingNext: () => false,
    blockingAuto: () => true,
    stopTimeout: undefined, // 暂时不用，后面会交给自动清除
  };
}

function getOverrideBoundsArr(raw: string): undefined | [number, number, number, number] {
  const parseOverrideBoundsResult = raw.split(',').map((e) => Number(e));
  let isPass = true;
  parseOverrideBoundsResult.forEach((e) => {
    if (isNaN(e)) {
      isPass = false;
    }
  });
  isPass = isPass && parseOverrideBoundsResult.length === 4;
  if (isPass) return parseOverrideBoundsResult as [number, number, number, number];
  else return undefined;
}



================================================
FILE: webgal/src/Core/gameScripts/changeSceneScript.ts
================================================
import { ISentence } from '@/Core/controller/scene/sceneInterface';
import { IPerform } from '@/Core/Modules/perform/performInterface';
import { changeScene } from '../controller/scene/changeScene';

/**
 * 切换场景。在场景结束后不会回到父场景。
 * @param sentence
 */
export const changeSceneScript = (sentence: ISentence): IPerform => {
  const sceneNameArray: Array<string> = sentence.content.split('/');
  const sceneName = sceneNameArray[sceneNameArray.length - 1];
  changeScene(sentence.content, sceneName);
  return {
    performName: 'none',
    duration: 0,
    isHoldOn: true,
    stopFunction: () => {},
    blockingNext: () => false,
    blockingAuto: () => true,
    stopTimeout: undefined, // 暂时不用，后面会交给自动清除
  };
};



================================================
FILE: webgal/src/Core/gameScripts/comment.ts
================================================
import { ISentence } from '@/Core/controller/scene/sceneInterface';
import { IPerform } from '@/Core/Modules/perform/performInterface';
import { logger } from '@/Core/util/logger';

/**
 * 注释，打LOG
 * @param sentence
 */
export const comment = (sentence: ISentence): IPerform => {
  logger.debug(`脚本内注释${sentence.content}`);
  return {
    performName: 'none',
    duration: 0,
    isHoldOn: false,
    stopFunction: () => {},
    blockingNext: () => false,
    blockingAuto: () => true,
    stopTimeout: undefined, // 暂时不用，后面会交给自动清除
  };
};



================================================
FILE: webgal/src/Core/gameScripts/end.ts
================================================
import { ISentence } from '@/Core/controller/scene/sceneInterface';
import { IPerform } from '@/Core/Modules/perform/performInterface';
import { assetSetter, fileType } from '@/Core/util/gameAssetsAccess/assetSetter';
import { sceneFetcher } from '@/Core/controller/scene/sceneFetcher';
import { sceneParser } from '@/Core/parser/sceneParser';
import { resetStage } from '@/Core/controller/stage/resetStage';
import { webgalStore } from '@/store/store';
import { setVisibility } from '@/store/GUIReducer';
import { playBgm } from '@/Core/controller/stage/playBgm';
import { WebGAL } from '@/Core/WebGAL';
import { dumpToStorageFast } from '@/Core/controller/storage/storageController';
import { saveActions } from '@/store/savesReducer';

/**
 * 结束游戏
 * @param sentence
 */
export const end = (sentence: ISentence): IPerform => {
  resetStage(true);
  const dispatch = webgalStore.dispatch;
  // 重新获取初始场景
  const sceneUrl: string = assetSetter('start.txt', fileType.scene);
  // 为了在 scriptExecutor 自增 sentenceId 后再重置场景
  setTimeout(() => {
    WebGAL.sceneManager.resetScene();
  }, 5);
  dispatch(saveActions.resetFastSave());
  dumpToStorageFast();
  sceneFetcher(sceneUrl).then((rawScene) => {
    // 场景写入到运行时
    WebGAL.sceneManager.sceneData.currentScene = sceneParser(rawScene, 'start.txt', sceneUrl);
  });
  dispatch(setVisibility({ component: 'showTitle', visibility: true }));
  playBgm(webgalStore.getState().GUI.titleBgm);
  return {
    performName: 'none',
    duration: 0,
    isHoldOn: false,
    stopFunction: () => {},
    blockingNext: () => false,
    blockingAuto: () => true,
    stopTimeout: undefined, // 暂时不用，后面会交给自动清除
  };
};



================================================
FILE: webgal/src/Core/gameScripts/filmMode.ts
================================================
import { ISentence } from '@/Core/controller/scene/sceneInterface';
import { IPerform } from '@/Core/Modules/perform/performInterface';
import { webgalStore } from '@/store/store';
import { setStage } from '@/store/stageReducer';

/**
 * 语句执行的模板代码
 * @param sentence
 */
export const filmMode = (sentence: ISentence): IPerform => {
  if (sentence.content !== '' && sentence.content !== 'none') {
    webgalStore.dispatch(setStage({ key: 'enableFilm', value: sentence.content }));
  } else {
    webgalStore.dispatch(setStage({ key: 'enableFilm', value: '' }));
  }
  return {
    performName: 'none',
    duration: 0,
    isHoldOn: false,
    stopFunction: () => {},
    blockingNext: () => false,
    blockingAuto: () => true,
    stopTimeout: undefined, // 暂时不用，后面会交给自动清除
  };
};



================================================
FILE: webgal/src/Core/gameScripts/intro.tsx
================================================
import { ISentence } from '@/Core/controller/scene/sceneInterface';
import { IPerform } from '@/Core/Modules/perform/performInterface';
import React from 'react';
import ReactDOM from 'react-dom';
import styles from '@/Stage/FullScreenPerform/fullScreenPerform.module.scss';
import { nextSentence } from '@/Core/controller/gamePlay/nextSentence';
import { PerformController } from '@/Core/Modules/perform/performController';
import { logger } from '@/Core/util/logger';
import { WebGAL } from '@/Core/WebGAL';
import { get, replace } from 'lodash';
import useEscape from '@/hooks/useEscape';
import { getBooleanArgByKey, getNumberArgByKey, getStringArgByKey } from '../util/getSentenceArg';
import { getGameAssetPath } from '@/Core/gameState';
/**
 * 显示一小段黑屏演示
 * @param sentence
 */
export const intro = (sentence: ISentence): IPerform => {
  /**
   * intro 内部控制
   */

  const performName = `introPerform${Math.random().toString()}`;

  const fontSizeFromArgs = getStringArgByKey(sentence, 'fontSize') ?? 'medium';
  let fontSize = '350%';
  switch (fontSizeFromArgs) {
    case 'small':
      fontSize = '280%';
      break;
    case 'medium':
      fontSize = '350%';
      break;
    case 'large':
      fontSize = '420%';
      break;
  }
  const backgroundImageFromArgs = getStringArgByKey(sentence, 'backgroundImage') ?? '';
  const backgroundUrl = getGameAssetPath(`background/${backgroundImageFromArgs}`);
  const backgroundImage = `url("${backgroundUrl}") center/cover no-repeat`;
  const backgroundColor = getStringArgByKey(sentence, 'backgroundColor') ?? 'rgba(0, 0, 0, 1)';
  const color = getStringArgByKey(sentence, 'fontColor') ?? 'rgba(255, 255, 255, 1)';
  const animationFromArgs = getStringArgByKey(sentence, 'animation') ?? '';
  let animationClass: any = (type: string, length = 0) => {
    switch (type) {
      case 'fadeIn':
        return styles.fadeIn;
      case 'slideIn':
        return styles.slideIn;
      case 'typingEffect':
        return `${styles.typingEffect} ${length}`;
      case 'pixelateEffect':
        return styles.pixelateEffect;
      case 'revealAnimation':
        return styles.revealAnimation;
      default:
        return styles.fadeIn;
    }
  };
  let chosenAnimationClass = animationClass(animationFromArgs);
  let delayTime = getNumberArgByKey(sentence, 'delayTime') ?? 1500;
  let isHold = getBooleanArgByKey(sentence, 'hold') ?? false;
  let isUserForward = getBooleanArgByKey(sentence, 'userForward') ?? false;
  // 设置一个很大的延迟，这样自然就看起来不自动继续了
  delayTime = isUserForward ? 99999999 : delayTime;
  // 用户手动控制向前步进，所以必须是 hold
  isHold = isUserForward ? true : isHold;

  const introContainerStyle = {
    background: backgroundImage,
    backgroundColor: backgroundColor,
    color: color,
    fontSize: fontSize || '350%',
    width: '100%',
    height: '100%',
  };
  const introArray: Array<string> = sentence.content.split(/(?<!\\)\|/).map((val: string) => useEscape(val));

  let endWait = 1000;
  let baseDuration = endWait + delayTime * introArray.length;
  const duration = isHold ? 1000 * 60 * 60 * 24 : 1000 + delayTime * introArray.length;
  let isBlocking = true;
  let setBlockingStateTimeout = setTimeout(() => {
    isBlocking = false;
  }, baseDuration);

  let timeout = setTimeout(() => {});
  const toNextIntroElement = () => {
    const introContainer = document.getElementById('introContainer');
    // 由于用户操作，相当于时间向前推进，这时候更新这个演出的预计完成时间
    baseDuration -= delayTime;
    clearTimeout(setBlockingStateTimeout);
    setBlockingStateTimeout = setTimeout(() => {
      isBlocking = false;
    }, baseDuration);
    if (introContainer) {
      const children = introContainer.childNodes[0].childNodes[0].childNodes as any;
      const len = children.length;
      if (isUserForward) {
        let isEnd = true;
        for (const node of children) {
          // 当前语句的延迟显示时间
          const currentDelay = Number(node.style.animationDelay.split('ms')[0]);
          // 当前语句还没有显示，降低显示延迟，因为现在时间因为用户操作，相当于向前推进了
          if (currentDelay > 0) {
            isEnd = false;
            // 用 Animation API 操作，浏览器版本太低就无办法了
            const nodeAnimations = node.getAnimations();
            node.style.animationDelay = '0ms ';
            for (const ani of nodeAnimations) {
              ani.currentTime = 0;
              ani.play();
            }
          }
        }
        if (isEnd) {
          clearTimeout(timeout);
          clearTimeout(setBlockingStateTimeout);
          WebGAL.gameplay.performController.unmountPerform(performName);
        }
        return;
      }
      children.forEach((node: HTMLDivElement, index: number) => {
        // 当前语句的延迟显示时间
        const currentDelay = Number(node.style.animationDelay.split('ms')[0]);
        // 当前语句还没有显示，降低显示延迟，因为现在时间因为用户操作，相当于向前推进了
        if (currentDelay > 0) {
          node.style.animationDelay = `${currentDelay - delayTime}ms`;
        }
        // 最后一个元素了
        if (index === len - 1) {
          // 并且已经完全显示了，这时候进行下一步
          if (currentDelay === 0) {
            clearTimeout(timeout);
            WebGAL.gameplay.performController.unmountPerform(performName);
            // 卸载函数发生在 nextSentence 生效前，所以不需要做下一行的操作。
            // setTimeout(nextSentence, 0);
          } else {
            // 还没有完全显示，但是因为时间的推进，要提前完成演出，更新用于结束演出的计时器
            clearTimeout(timeout);
            // 如果 Hold 了，自然不要自动结束
            if (!isHold) {
              timeout = setTimeout(() => {
                WebGAL.gameplay.performController.unmountPerform(performName);
              }, baseDuration);
            }
          }
        }
      });
    }
  };

  /**
   * 接受 next 事件
   */
  WebGAL.events.userInteractNext.on(toNextIntroElement);

  const showIntro = introArray.map((e, i) => (
    <div
      key={'introtext' + i + Math.random().toString()}
      style={{ animationDelay: `${delayTime * i}ms` }}
      className={chosenAnimationClass}
    >
      {e}
      {e === '' ? '\u00a0' : ''}
    </div>
  ));
  const intro = (
    <div style={introContainerStyle}>
      <div style={{ padding: '3em 4em 3em 4em' }}>{showIntro}</div>
    </div>
  );
  // eslint-disable-next-line react/no-deprecated
  ReactDOM.render(intro, document.getElementById('introContainer'));
  const introContainer = document.getElementById('introContainer');

  if (introContainer) {
    introContainer.style.display = 'block';
  }

  return {
    performName,
    duration,
    isHoldOn: false,
    stopFunction: () => {
      const introContainer = document.getElementById('introContainer');
      if (introContainer) {
        introContainer.style.display = 'none';
      }
      WebGAL.events.userInteractNext.off(toNextIntroElement);
    },
    blockingNext: () => isBlocking,
    blockingAuto: () => isBlocking,
    stopTimeout: undefined, // 暂时不用，后面会交给自动清除
    goNextWhenOver: true,
  };
};



================================================
FILE: webgal/src/Core/gameScripts/jumpLabel.ts
================================================
import { ISentence } from '@/Core/controller/scene/sceneInterface';
import { IPerform } from '@/Core/Modules/perform/performInterface';
import { jmp } from '@/Core/gameScripts/label/jmp';

/**
 * 跳转到指定标签
 * @param sentence
 */
export const jumpLabel = (sentence: ISentence): IPerform => {
  jmp(sentence.content);
  return {
    performName: 'none',
    duration: 0,
    isHoldOn: false,
    stopFunction: () => {},
    blockingNext: () => false,
    blockingAuto: () => true,
    stopTimeout: undefined, // 暂时不用，后面会交给自动清除
  };
};



================================================
FILE: webgal/src/Core/gameScripts/miniAvatar.ts
================================================
import { ISentence } from '@/Core/controller/scene/sceneInterface';
import { IPerform } from '@/Core/Modules/perform/performInterface';
import { webgalStore } from '@/store/store';
import { setStage } from '@/store/stageReducer';

/**
 * 显示小头像
 * @param sentence
 */
export const miniAvatar = (sentence: ISentence): IPerform => {
  let content = sentence.content;
  if (sentence.content === 'none' || sentence.content === '') {
    content = '';
  }
  webgalStore.dispatch(setStage({ key: 'miniAvatar', value: content }));
  return {
    performName: 'none',
    duration: 0,
    isHoldOn: true,
    stopFunction: () => {},
    blockingNext: () => false,
    blockingAuto: () => true,
    stopTimeout: undefined, // 暂时不用，后面会交给自动清除
  };
};



================================================
FILE: webgal/src/Core/gameScripts/playEffect.ts
================================================
import { ISentence } from '@/Core/controller/scene/sceneInterface';
import { logger } from '@/Core/util/logger';
import { RootState, webgalStore } from '@/store/store';
import { getNumberArgByKey, getStringArgByKey } from '@/Core/util/getSentenceArg';
import { IPerform } from '@/Core/Modules/perform/performInterface';
import { useSelector } from 'react-redux';
import { WebGAL } from '@/Core/WebGAL';
import { WEBGAL_NONE } from '@/Core/constants';

/**
 * 播放一段效果音
 * @param sentence 语句
 */
export const playEffect = (sentence: ISentence): IPerform => {
  logger.debug('play SE');
  // 如果有ID，这里被覆写，一般用于循环的情况
  // 有循环参数且有 ID，就循环
  let performInitName = 'effect-sound';
  // 清除先前的效果音
  WebGAL.gameplay.performController.unmountPerform(performInitName, true);
  let url = sentence.content;
  let isLoop = false;
  // 清除带 id 的效果音
  const id = getStringArgByKey(sentence, 'id') ?? '';
  if (id) {
    performInitName = `effect-sound-${id}`;
    WebGAL.gameplay.performController.unmountPerform(performInitName, true);
    isLoop = true;
  }
  let isOver = false;
  if (!url || url === WEBGAL_NONE) {
    return {
      performName: WEBGAL_NONE,
      duration: 0,
      isHoldOn: false,
      blockingAuto(): boolean {
        return false;
      },
      blockingNext(): boolean {
        return false;
      },
      stopFunction(): void {},
      stopTimeout: undefined,
    };
  }
  return {
    performName: 'none',
    blockingAuto(): boolean {
      return false;
    },
    blockingNext(): boolean {
      return false;
    },
    isHoldOn: false,
    stopFunction(): void {},
    stopTimeout: undefined,

    duration: 1000 * 60 * 60,
    arrangePerformPromise: new Promise((resolve) => {
      // 播放效果音
      setTimeout(() => {
        let volume = getNumberArgByKey(sentence, 'volume') ?? 100; // 获取音量比
        volume = Math.max(0, Math.min(volume, 100)); // 限制音量在 0-100 之间
        let seElement = document.createElement('audio');
        seElement.src = url;
        if (isLoop) {
          seElement.loop = true;
        }
        const userDataState = webgalStore.getState().userData;
        const mainVol = userDataState.optionData.volumeMain;
        const seVol = mainVol * 0.01 * (userDataState.optionData?.seVolume ?? 100) * 0.01 * volume * 0.01;
        seElement.volume = seVol;
        seElement.currentTime = 0;
        const perform: IPerform = {
          performName: performInitName,
          duration: 1000 * 60 * 60,
          isHoldOn: isLoop,
          skipNextCollect: true,
          stopFunction: () => {
            // 演出已经结束了，所以不用播放效果音了
            seElement.pause();
            seElement.remove();
          },
          blockingNext: () => false,
          blockingAuto: () => {
            // loop 的话就不 block auto
            if (isLoop) return false;
            return !isOver;
          },
          stopTimeout: undefined, // 暂时不用，后面会交给自动清除
        };
        resolve(perform);
        seElement?.play();
        seElement.onended = () => {
          for (const e of WebGAL.gameplay.performController.performList) {
            if (e.performName === performInitName) {
              isOver = true;
              e.stopFunction();
              WebGAL.gameplay.performController.unmountPerform(e.performName);
            }
          }
        };
      }, 1);
    }),
  };
};



================================================
FILE: webgal/src/Core/gameScripts/playVideo.tsx
================================================
import { ISentence } from '@/Core/controller/scene/sceneInterface';
import { IPerform } from '@/Core/Modules/perform/performInterface';
import React from 'react';
import ReactDOM from 'react-dom';
import styles from '@/Stage/FullScreenPerform/fullScreenPerform.module.scss';
import { webgalStore } from '@/store/store';
import { getRandomPerformName, PerformController } from '@/Core/Modules/perform/performController';
import { getBooleanArgByKey } from '@/Core/util/getSentenceArg';
import { WebGAL } from '@/Core/WebGAL';
/**
 * 播放一段视频 * @param sentence
 */
export const playVideo = (sentence: ISentence): IPerform => {
  const userDataState = webgalStore.getState().userData;
  const mainVol = userDataState.optionData.volumeMain;
  const vocalVol = mainVol * 0.01 * userDataState.optionData.vocalVolume * 0.01;
  const bgmVol = mainVol * 0.01 * userDataState.optionData.bgmVolume * 0.01;
  const performInitName: string = getRandomPerformName();

  let blockingNextFlag = getBooleanArgByKey(sentence, 'skipOff') ?? false;

  // eslint-disable-next-line react/no-deprecated
  ReactDOM.render(
    <div className={styles.videoContainer}>
      <video className={styles.fullScreen_video} id="playVideoElement" src={sentence.content} autoPlay={true} />
    </div>,
    document.getElementById('videoContainer'),
  );
  let isOver = false;
  return {
    performName: 'none',
    duration: 0,
    isHoldOn: false,
    stopFunction: () => {},
    blockingNext: () => blockingNextFlag,
    blockingAuto: () => true,
    stopTimeout: undefined, // 暂时不用，后面会交给自动清除
    arrangePerformPromise: new Promise<IPerform>((resolve) => {
      /**
       * 启动视频播放
       */
      setTimeout(() => {
        let VocalControl: any = document.getElementById('playVideoElement');
        if (VocalControl !== null) {
          VocalControl.currentTime = 0;
          VocalControl.volume = bgmVol;
          const endPerform = () => {
            for (const e of WebGAL.gameplay.performController.performList) {
              if (e.performName === performInitName) {
                isOver = true;
                e.stopFunction();
                WebGAL.gameplay.performController.unmountPerform(e.performName);
              }
            }
          };
          const skipVideo = () => {
            endPerform();
          };
          // 双击可跳过视频
          WebGAL.events.fullscreenDbClick.on(skipVideo);
          // 播放并作为一个特别演出加入
          const perform = {
            performName: performInitName,
            duration: 1000 * 60 * 60,
            isOver: false,
            isHoldOn: false,
            stopFunction: () => {
              WebGAL.events.fullscreenDbClick.off(skipVideo);
              /**
               * 恢复音量
               */
              const bgmElement: any = document.getElementById('currentBgm');
              if (bgmElement) {
                bgmElement.volume = bgmVol.toString();
              }
              const vocalElement: any = document.getElementById('currentVocal');
              if (bgmElement) {
                vocalElement.volume = vocalVol.toString();
              }
              // eslint-disable-next-line react/no-deprecated
              ReactDOM.render(<div />, document.getElementById('videoContainer'));
            },
            blockingNext: () => blockingNextFlag,
            blockingAuto: () => {
              return !isOver;
            },
            stopTimeout: undefined, // 暂时不用，后面会交给自动清除
            goNextWhenOver: true,
          };
          resolve(perform);
          /**
           * 把bgm和语音的音量设为0
           */
          const vocalVol2 = 0;
          const bgmVol2 = 0;
          const bgmElement: any = document.getElementById('currentBgm');
          if (bgmElement) {
            bgmElement.volume = bgmVol2.toString();
          }
          const vocalElement: any = document.getElementById('currentVocal');
          if (bgmElement) {
            vocalElement.volume = vocalVol2.toString();
          }

          VocalControl?.play();

          VocalControl.onended = () => {
            endPerform();
          };
        }
      }, 1);
    }),
  };
};



================================================
FILE: webgal/src/Core/gameScripts/say.ts
================================================
import { ISentence } from '@/Core/controller/scene/sceneInterface';
import { IPerform } from '@/Core/Modules/perform/performInterface';
import { playVocal } from './vocal';
import { webgalStore } from '@/store/store';
import { setStage } from '@/store/stageReducer';
import { useTextAnimationDuration, useTextDelay } from '@/hooks/useTextOptions';
import { getRandomPerformName, PerformController } from '@/Core/Modules/perform/performController';
import { getBooleanArgByKey, getStringArgByKey } from '@/Core/util/getSentenceArg';
import { textSize, voiceOption } from '@/store/userDataInterface';
import { WebGAL } from '@/Core/WebGAL';
import { compileSentence } from '@/Stage/TextBox/TextBox';
import { performMouthAnimation } from '@/Core/gameScripts/vocal/vocalAnimation';
import { match } from '@/Core/util/match';

/**
 * 进行普通对话的显示
 * @param sentence 语句
 * @return {IPerform} 执行的演出
 */
export const say = (sentence: ISentence): IPerform => {
  const stageState = webgalStore.getState().stage;
  const userDataState = webgalStore.getState().userData;
  const dispatch = webgalStore.dispatch;
  let dialogKey = Math.random().toString(); // 生成一个随机的key
  let dialogToShow = sentence.content; // 获取对话内容
  if (dialogToShow) {
    dialogToShow = String(dialogToShow).replace(/ {2,}/g, (match) => '\u00a0'.repeat(match.length)); // 替换连续两个或更多空格
  }
  const isConcat = getBooleanArgByKey(sentence, 'concat') ?? false; // 是否是继承语句
  const isNotend = getBooleanArgByKey(sentence, 'notend') ?? false; // 是否有 notend 参数
  const speaker = getStringArgByKey(sentence, 'speaker'); // 获取说话者
  const clear = getBooleanArgByKey(sentence, 'clear') ?? false; // 是否清除说话者
  const vocal = getStringArgByKey(sentence, 'vocal'); // 是否播放语音

  // 如果是concat，那么就继承上一句的key，并且继承上一句对话。
  if (isConcat) {
    dialogKey = stageState.currentDialogKey;
    dialogToShow = stageState.showText + dialogToShow;
    dispatch(setStage({ key: 'currentConcatDialogPrev', value: stageState.showText }));
  } else {
    dispatch(setStage({ key: 'currentConcatDialogPrev', value: '' }));
  }

  // 设置文本显示
  dispatch(setStage({ key: 'showText', value: dialogToShow }));
  dispatch(setStage({ key: 'vocal', value: '' }));

  // 清除语音
  if (!(userDataState.optionData.voiceInterruption === voiceOption.no && vocal === null)) {
    // 只有开关设置为不中断，并且没有语音的时候，才需要不中断
    dispatch(setStage({ key: 'playVocal', value: '' }));
    WebGAL.gameplay.performController.unmountPerform('vocal-play', true);
  }
  // 设置key
  dispatch(setStage({ key: 'currentDialogKey', value: dialogKey }));
  // 计算延迟
  const textDelay = useTextDelay(userDataState.optionData.textSpeed);
  // 本句延迟
  const textNodes = compileSentence(sentence.content, 3);
  const len = textNodes.reduce((prev, curr) => prev + curr.length, 0);
  const sentenceDelay = textDelay * len;

  const fontSizeFromArgs = getStringArgByKey(sentence, 'fontSize');
  switch (fontSizeFromArgs) {
    case 'small':
      dispatch(setStage({ key: 'showTextSize', value: textSize.small }));
      break;
    case 'medium':
      dispatch(setStage({ key: 'showTextSize', value: textSize.medium }));
      break;
    case 'large':
      dispatch(setStage({ key: 'showTextSize', value: textSize.large }));
      break;
    default:
      dispatch(setStage({ key: 'showTextSize', value: -1 }));
      break;
  }

  // 设置显示的角色名称
  let showName = stageState.showName; // 先默认继承
  if (speaker !== null) {
    showName = speaker;
  }
  if (clear) {
    showName = '';
  }
  dispatch(setStage({ key: 'showName', value: showName }));

  // 模拟说话
  let performSimulateVocalTimeout: ReturnType<typeof setTimeout> | null = null;
  let performSimulateVocalDelay = 0;

  let pos: '' | 'center' | 'left' | 'right' = '';
  const leftFromArgs = getBooleanArgByKey(sentence, 'left') ?? false;
  const rightFromArgs = getBooleanArgByKey(sentence, 'right') ?? false;
  const centerFromArgs = getBooleanArgByKey(sentence, 'center') ?? false;
  if (leftFromArgs) pos = 'left';
  if (rightFromArgs) pos = 'right';
  if (centerFromArgs) pos = 'center';

  let key = getStringArgByKey(sentence, 'figureId') ?? '';

  let audioLevel = 80;
  const performSimulateVocal = (end = false) => {
    let nextAudioLevel = audioLevel + (Math.random() * 60 - 30); // 在 -30 到 +30 之间波动
    // 确保波动幅度不小于 5
    if (Math.abs(nextAudioLevel - audioLevel) < 5) {
      nextAudioLevel = audioLevel + Math.sign(nextAudioLevel - audioLevel) * 5;
    }
    // 确保结果在 25 到 100 之间
    audioLevel = Math.max(15, Math.min(nextAudioLevel, 100));
    const currentStageState = webgalStore.getState().stage;
    const figureAssociatedAnimation = currentStageState.figureAssociatedAnimation;
    const animationItem = figureAssociatedAnimation.find((tid) => tid.targetId === key);
    const targetKey = key ? key : `fig-${pos}`;
    if (end) {
      audioLevel = 0;
    }
    performMouthAnimation({
      audioLevel,
      OPEN_THRESHOLD: 50,
      HALF_OPEN_THRESHOLD: 25,
      currentMouthValue: 0,
      lerpSpeed: 1,
      key: targetKey,
      animationItem,
      pos,
    });
    if (!end) performSimulateVocalTimeout = setTimeout(performSimulateVocal, 50);
  };
  // 播放一段语音
  if (vocal) {
    playVocal(sentence);
  } else if (key || pos) {
    performSimulateVocalDelay = len * 250;
    performSimulateVocal();
  }

  const performInitName: string = getRandomPerformName();
  let endDelay = useTextAnimationDuration(userDataState.optionData.textSpeed) / 2;
  // 如果有 notend 参数，那么就不需要等待
  if (isNotend) {
    endDelay = 0;
  }

  return {
    performName: performInitName,
    duration: sentenceDelay + endDelay + performSimulateVocalDelay,
    isHoldOn: false,
    stopFunction: () => {
      WebGAL.events.textSettle.emit();
      if (performSimulateVocalTimeout) {
        performSimulateVocal(true);
        clearTimeout(performSimulateVocalTimeout);
      }
    },
    blockingNext: () => false,
    blockingAuto: () => true,
    stopTimeout: undefined, // 暂时不用，后面会交给自动清除
    goNextWhenOver: isNotend,
  };
};



================================================
FILE: webgal/src/Core/gameScripts/setAnimation.ts
================================================
import { ISentence } from '@/Core/controller/scene/sceneInterface';
import { IPerform } from '@/Core/Modules/perform/performInterface';
import { getBooleanArgByKey, getStringArgByKey } from '@/Core/util/getSentenceArg';
import { IAnimationObject } from '@/Core/controller/stage/pixi/PixiController';
import { logger } from '@/Core/util/logger';
import { webgalStore } from '@/store/store';

import { getAnimateDuration, getAnimationObject } from '@/Core/Modules/animationFunctions';
import { WebGAL } from '@/Core/WebGAL';

/**
 * 设置背景动画
 * @param sentence
 */
export const setAnimation = (sentence: ISentence): IPerform => {
  const startDialogKey = webgalStore.getState().stage.currentDialogKey;
  const animationName = sentence.content;
  const animationDuration = getAnimateDuration(animationName);
  let target = getStringArgByKey(sentence, 'target') ?? '';
  target = target !== '' ? target : 'default_id';
  const writeDefault = getBooleanArgByKey(sentence, 'writeDefault') ?? false;
  const keep = getBooleanArgByKey(sentence, 'keep') ?? false;

  const key = `${target}-${animationName}-${animationDuration}`;
  const performInitName = `animation-${target}`;

  WebGAL.gameplay.performController.unmountPerform(performInitName, true);

  let stopFunction;
  setTimeout(() => {
    WebGAL.gameplay.pixiStage?.stopPresetAnimationOnTarget(target);
    const animationObj: IAnimationObject | null = getAnimationObject(
      animationName,
      target,
      animationDuration,
      writeDefault,
    );
    if (animationObj) {
      logger.debug(`动画${animationName}作用在${target}`, animationDuration);
      WebGAL.gameplay.pixiStage?.registerAnimation(animationObj, key, target);
    }
  }, 0);
  stopFunction = () => {
    setTimeout(() => {
      const endDialogKey = webgalStore.getState().stage.currentDialogKey;
      const isHasNext = startDialogKey !== endDialogKey;
      WebGAL.gameplay.pixiStage?.removeAnimationWithSetEffects(key);
    }, 0);
  };

  return {
    performName: performInitName,
    duration: animationDuration,
    isHoldOn: keep,
    stopFunction,
    blockingNext: () => false,
    blockingAuto: () => !keep,
    stopTimeout: undefined, // 暂时不用，后面会交给自动清除
  };
};



================================================
FILE: webgal/src/Core/gameScripts/setComplexAnimation.ts
================================================
import { ISentence } from '@/Core/controller/scene/sceneInterface';
import { IPerform } from '@/Core/Modules/perform/performInterface';
import { getNumberArgByKey, getStringArgByKey } from '@/Core/util/getSentenceArg';
import { webgalAnimations } from '@/Core/controller/stage/pixi/animations';
import { IAnimationObject } from '@/Core/controller/stage/pixi/PixiController';
import { logger } from '@/Core/util/logger';
import { webgalStore } from '@/store/store';

import { WebGAL } from '@/Core/WebGAL';

/**
 * 设置背景动画
 * @param sentence
 */
export const setComplexAnimation = (sentence: ISentence): IPerform => {
  const startDialogKey = webgalStore.getState().stage.currentDialogKey;
  const animationName = sentence.content;
  const animationDuration = getNumberArgByKey(sentence, 'duration') ?? 0;
  const target = getStringArgByKey(sentence, 'target') ?? '0';

  const key = `${target}-${animationName}-${animationDuration}`;
  const animationFunction: Function | null = getAnimationObject(animationName);
  let stopFunction: () => void = () => {};
  if (animationFunction) {
    logger.debug(`动画${animationName}作用在${target}`, animationDuration);
    const animationObj: IAnimationObject = animationFunction(target, animationDuration);
    WebGAL.gameplay.pixiStage?.stopPresetAnimationOnTarget(target);
    WebGAL.gameplay.pixiStage?.registerAnimation(animationObj, key, target);
    stopFunction = () => {
      const endDialogKey = webgalStore.getState().stage.currentDialogKey;
      const isHasNext = startDialogKey !== endDialogKey;
      WebGAL.gameplay.pixiStage?.removeAnimationWithSetEffects(key);
    };
  }
  return {
    performName: key,
    duration: animationDuration,
    isHoldOn: false,
    stopFunction,
    blockingNext: () => false,
    blockingAuto: () => true,
    stopTimeout: undefined, // 暂时不用，后面会交给自动清除
  };
};

function getAnimationObject(animationName: string): Function | null {
  const result = webgalAnimations.find((e) => e.name === animationName);
  logger.debug('装载动画', result);
  if (result) {
    return result.animationGenerateFunc;
  }
  return null;
}



================================================
FILE: webgal/src/Core/gameScripts/setFilter.ts
================================================
import { ISentence } from '@/Core/controller/scene/sceneInterface';
import { IPerform } from '@/Core/Modules/perform/performInterface';

/**
 * 设置背景效果
 * @param sentence
 */
export const setFilter = (sentence: ISentence): IPerform => {
  return {
    performName: 'none',
    duration: 0,
    isHoldOn: false,
    stopFunction: () => {},
    blockingNext: () => false,
    blockingAuto: () => true,
    stopTimeout: undefined, // 暂时不用，后面会交给自动清除
  };
};



================================================
FILE: webgal/src/Core/gameScripts/setTempAnimation.ts
================================================
import { ISentence } from '@/Core/controller/scene/sceneInterface';
import { IPerform } from '@/Core/Modules/perform/performInterface';
import { getBooleanArgByKey, getStringArgByKey } from '@/Core/util/getSentenceArg';
import { IAnimationObject } from '@/Core/controller/stage/pixi/PixiController';
import { logger } from '@/Core/util/logger';
import { webgalStore } from '@/store/store';
import { generateTimelineObj } from '@/Core/controller/stage/pixi/animations/timeline';
import cloneDeep from 'lodash/cloneDeep';
import { baseTransform } from '@/store/stageInterface';
import { IUserAnimation } from '../Modules/animations';
import { getAnimateDuration, getAnimationObject } from '@/Core/Modules/animationFunctions';
import { WebGAL } from '@/Core/WebGAL';

/**
 * 设置临时动画
 * @param sentence
 */
export const setTempAnimation = (sentence: ISentence): IPerform => {
  const startDialogKey = webgalStore.getState().stage.currentDialogKey;
  const animationName = (Math.random() * 10).toString(16);
  const animationString = sentence.content;
  let animationObj;
  try {
    animationObj = JSON.parse(animationString);
  } catch (e) {
    animationObj = [];
  }
  const newAnimation: IUserAnimation = { name: animationName, effects: animationObj };
  WebGAL.animationManager.addAnimation(newAnimation);
  const animationDuration = getAnimateDuration(animationName);
  const target = getStringArgByKey(sentence, 'target') ?? '0';
  const writeDefault = getBooleanArgByKey(sentence, 'writeDefault') ?? false;
  const keep = getBooleanArgByKey(sentence, 'keep') ?? false;

  const key = `${target}-${animationName}-${animationDuration}`;
  const performInitName = `animation-${target}`;

  WebGAL.gameplay.performController.unmountPerform(performInitName, true);

  let stopFunction = () => {};
  setTimeout(() => {
    WebGAL.gameplay.pixiStage?.stopPresetAnimationOnTarget(target);
    const animationObj: IAnimationObject | null = getAnimationObject(
      animationName,
      target,
      animationDuration,
      writeDefault,
    );
    if (animationObj) {
      logger.debug(`动画${animationName}作用在${target}`, animationDuration);
      WebGAL.gameplay.pixiStage?.registerAnimation(animationObj, key, target);
    }
  }, 0);
  stopFunction = () => {
    setTimeout(() => {
      const endDialogKey = webgalStore.getState().stage.currentDialogKey;
      const isHasNext = startDialogKey !== endDialogKey;
      WebGAL.gameplay.pixiStage?.removeAnimationWithSetEffects(key);
    }, 0);
  };

  return {
    performName: performInitName,
    duration: animationDuration,
    isHoldOn: keep,
    stopFunction,
    blockingNext: () => false,
    blockingAuto: () => !keep,
    stopTimeout: undefined, // 暂时不用，后面会交给自动清除
  };
};



================================================
FILE: webgal/src/Core/gameScripts/setTextbox.ts
================================================
import { ISentence } from '@/Core/controller/scene/sceneInterface';
import { IPerform } from '@/Core/Modules/perform/performInterface';
import { webgalStore } from '@/store/store';
import { setStage } from '@/store/stageReducer';

/**
 * 语句执行的模板代码
 * @param sentence
 */
export function setTextbox(sentence: ISentence): IPerform {
  if (sentence.content === 'hide') {
    webgalStore.dispatch(setStage({ key: 'isDisableTextbox', value: true }));
  } else {
    webgalStore.dispatch(setStage({ key: 'isDisableTextbox', value: false }));
  }
  return {
    performName: 'none',
    duration: 0,
    isHoldOn: false,
    stopFunction: () => {},
    blockingNext: () => false,
    blockingAuto: () => true,
    stopTimeout: undefined, // 暂时不用，后面会交给自动清除
  };
}



================================================
FILE: webgal/src/Core/gameScripts/setTransform.ts
================================================
import { ISentence } from '@/Core/controller/scene/sceneInterface';
import { IPerform } from '@/Core/Modules/perform/performInterface';
import { getBooleanArgByKey, getNumberArgByKey, getStringArgByKey } from '@/Core/util/getSentenceArg';
import PixiStage, { IAnimationObject } from '@/Core/controller/stage/pixi/PixiController';
import { logger } from '@/Core/util/logger';
import { webgalStore } from '@/store/store';
import { generateTimelineObj } from '@/Core/controller/stage/pixi/animations/timeline';
import cloneDeep from 'lodash/cloneDeep';
import { baseTransform, ITransform } from '@/store/stageInterface';
import { AnimationFrame, IUserAnimation } from '../Modules/animations';
import { generateTransformAnimationObj } from '@/Core/controller/stage/pixi/animations/generateTransformAnimationObj';
import { WebGAL } from '@/Core/WebGAL';
import { getAnimateDuration, getAnimationObject } from '../Modules/animationFunctions';

/**
 * 设置变换
 * @param sentence
 */
export const setTransform = (sentence: ISentence): IPerform => {
  const startDialogKey = webgalStore.getState().stage.currentDialogKey;
  const animationName = (Math.random() * 10).toString(16);
  const animationString = sentence.content;
  let animationObj: AnimationFrame[];

  const duration = getNumberArgByKey(sentence, 'duration') ?? 500;
  const ease = getStringArgByKey(sentence, 'ease') ?? '';
  const writeDefault = getBooleanArgByKey(sentence, 'writeDefault') ?? false;
  const target = getStringArgByKey(sentence, 'target') ?? '0';
  const keep = getBooleanArgByKey(sentence, 'keep') ?? false;

  const performInitName = `animation-${target}`;

  WebGAL.gameplay.performController.unmountPerform(performInitName, true);

  try {
    const frame = JSON.parse(animationString) as AnimationFrame;
    animationObj = generateTransformAnimationObj(target, frame, duration, ease);
    console.log('animationObj:', animationObj);
  } catch (e) {
    // 解析都错误了，歇逼吧
    animationObj = [];
  }

  const newAnimation: IUserAnimation = { name: animationName, effects: animationObj };
  WebGAL.animationManager.addAnimation(newAnimation);
  const animationDuration = getAnimateDuration(animationName);

  const key = `${target}-${animationName}-${animationDuration}`;
  let keepAnimationStopped = false;
  setTimeout(() => {
    if (keep && keepAnimationStopped) {
      return;
    }
    WebGAL.gameplay.pixiStage?.stopPresetAnimationOnTarget(target);
    const animationObj: IAnimationObject | null = getAnimationObject(
      animationName,
      target,
      animationDuration,
      writeDefault,
    );
    if (animationObj) {
      logger.debug(`动画${animationName}作用在${target}`, animationDuration);
      WebGAL.gameplay.pixiStage?.registerAnimation(animationObj, key, target);
    }
  }, 0);
  const stopFunction = () => {
    if (keep) {
      WebGAL.gameplay.pixiStage?.removeAnimationWithoutSetEndState(key);
      keepAnimationStopped = true;
      return;
    }
    setTimeout(() => {
      WebGAL.gameplay.pixiStage?.removeAnimationWithSetEffects(key);
    }, 0);
  };

  return {
    performName: performInitName,
    duration: animationDuration,
    isHoldOn: keep,
    stopFunction,
    blockingNext: () => false,
    blockingAuto: () => !keep,
    stopTimeout: undefined, // 暂时不用，后面会交给自动清除
  };
};



================================================
FILE: webgal/src/Core/gameScripts/setTransition.ts
================================================
import { ISentence } from '@/Core/controller/scene/sceneInterface';
import { IPerform } from '@/Core/Modules/perform/performInterface';
import { webgalStore } from '@/store/store';
import cloneDeep from 'lodash/cloneDeep';
import { getStringArgByKey } from '@/Core/util/getSentenceArg';
import { setStage } from '@/store/stageReducer';
import { WebGAL } from '@/Core/WebGAL';

/**
 * 设置转场效果
 * @param sentence
 */
export const setTransition = (sentence: ISentence): IPerform => {
  // 根据参数设置指定位置
  let key = getStringArgByKey(sentence, 'target') ?? '0';
  const enterAnimation = getStringArgByKey(sentence, 'enter');
  const exitAnimation = getStringArgByKey(sentence, 'exit');
  if (enterAnimation) {
    WebGAL.animationManager.nextEnterAnimationName.set(key, enterAnimation);
  }
  if (exitAnimation) {
    WebGAL.animationManager.nextExitAnimationName.set(key + '-off', exitAnimation);
  }
  return {
    performName: 'none',
    duration: 0,
    isHoldOn: false,
    stopFunction: () => {},
    blockingNext: () => false,
    blockingAuto: () => false,
    stopTimeout: undefined, // 暂时不用，后面会交给自动清除
  };
};



================================================
FILE: webgal/src/Core/gameScripts/setVar.ts
================================================
import { ISentence } from '@/Core/controller/scene/sceneInterface';
import { IPerform } from '@/Core/Modules/perform/performInterface';
import { webgalStore } from '@/store/store';
import { setStageVar } from '@/store/stageReducer';
import { logger } from '@/Core/util/logger';
import { compile } from 'angular-expressions';
import { setScriptManagedGlobalVar } from '@/store/userDataReducer';
import { ActionCreatorWithPayload } from '@reduxjs/toolkit';
import { ISetGameVar } from '@/store/stageInterface';
import { dumpToStorageFast } from '@/Core/controller/storage/storageController';
import expression from 'angular-expressions';
import get from 'lodash/get';
import random from 'lodash/random';
import { getBooleanArgByKey } from '../util/getSentenceArg';

/**
 * 设置变量
 * @param sentence
 */
export const setVar = (sentence: ISentence): IPerform => {
  let setGlobal = getBooleanArgByKey(sentence, 'global') ?? false;
  let targetReducerFunction: ActionCreatorWithPayload<ISetGameVar, string>;
  if (setGlobal) {
    targetReducerFunction = setScriptManagedGlobalVar;
  } else {
    targetReducerFunction = setStageVar;
  }
  // 先把表达式拆分为变量名和赋值语句
  if (sentence.content.match(/\s*=\s*/)) {
    const key = sentence.content.split(/\s*=\s*/)[0];
    const valExp = sentence.content.split(/\s*=\s*/)[1];
    if (/^\s*[a-zA-Z_$][\w$]*\s*\(.*\)\s*$/.test(valExp)) {
      webgalStore.dispatch(targetReducerFunction({ key, value: EvaluateExpression(valExp) }));
    } else if (valExp.match(/[+\-*\/()]/)) {
      // 如果包含加减乘除号，则运算
      // 先取出运算表达式中的变量
      const valExpArr = valExp.split(/([+\-*\/()])/g);
      // 将变量替换为变量的值，然后合成表达式字符串
      const valExp2 = valExpArr
        .map((e) => {
          if (!e.trim().match(/^[a-zA-Z_$][a-zA-Z0-9_.]*$/)) {
            // 检查是否是变量名，不是就返回本身
            return e;
          }
          const _r = getValueFromStateElseKey(e.trim(), true);
          return typeof _r === 'string' ? `'${_r}'` : _r;
        })
        .reduce((pre, curr) => pre + curr, '');
      let result = '';
      try {
        const exp = compile(valExp2);
        result = exp();
      } catch (e) {
        logger.error('expression compile error', e);
      }
      webgalStore.dispatch(targetReducerFunction({ key, value: result }));
    } else if (valExp.match(/true|false/)) {
      if (valExp.match(/true/)) {
        webgalStore.dispatch(targetReducerFunction({ key, value: true }));
      }
      if (valExp.match(/false/)) {
        webgalStore.dispatch(targetReducerFunction({ key, value: false }));
      }
    } else if (valExp.length === 0) {
      webgalStore.dispatch(targetReducerFunction({ key, value: '' }));
    } else {
      if (!isNaN(Number(valExp))) {
        webgalStore.dispatch(targetReducerFunction({ key, value: Number(valExp) }));
      } else {
        // 字符串
        webgalStore.dispatch(targetReducerFunction({ key, value: getValueFromStateElseKey(valExp, true) }));
      }
    }
    if (setGlobal) {
      logger.debug('设置全局变量：', { key, value: webgalStore.getState().userData.globalGameVar[key] });
      dumpToStorageFast();
    } else {
      logger.debug('设置变量：', { key, value: webgalStore.getState().stage.GameVar[key] });
    }
  }
  return {
    performName: 'none',
    duration: 0,
    isHoldOn: false,
    stopFunction: () => {},
    blockingNext: () => false,
    blockingAuto: () => true,
    stopTimeout: undefined, // 暂时不用，后面会交给自动清除
  };
};

type BaseVal = string | number | boolean | undefined;

/**
 * 执行函数
 */
function EvaluateExpression(val: string) {
  const instance = expression.compile(val);
  return instance({
    random: (...args: any[]) => {
      return args.length ? random(...args) : Math.random();
    },
  });
}

/**
 * 取不到时返回 undefined
 */
export function getValueFromState(key: string) {
  let ret: any;
  const stage = webgalStore.getState().stage;
  const userData = webgalStore.getState().userData;
  const _Merge = { stage, userData }; // 不要直接合并到一起，防止可能的键冲突
  if (stage.GameVar.hasOwnProperty(key)) {
    ret = stage.GameVar[key];
  } else if (userData.globalGameVar.hasOwnProperty(key)) {
    ret = userData.globalGameVar[key];
  } else if (key.startsWith('$')) {
    const propertyKey = key.replace('$', '');
    ret = get(_Merge, propertyKey, undefined) as BaseVal;
  }
  return ret;
}

/**
 * 取不到时返回 {key}
 */
export function getValueFromStateElseKey(key: string, useKeyNameAsReturn = false) {
  const valueFromState = getValueFromState(key);
  if (valueFromState === null || valueFromState === undefined) {
    logger.warn('valueFromState result null, key = ' + key);
    if (useKeyNameAsReturn) {
      return key;
    }
    return `{${key}}`;
  }
  return valueFromState;
}



================================================
FILE: webgal/src/Core/gameScripts/showVars.ts
================================================
import { ISentence } from '@/Core/controller/scene/sceneInterface';
import { IPerform } from '@/Core/Modules/perform/performInterface';
import { webgalStore } from '@/store/store';
import { setStage } from '@/store/stageReducer';
import { logger } from '@/Core/util/logger';
import { getRandomPerformName } from '@/Core/Modules/perform/performController';
import { PERFORM_CONFIG } from '@/config';
import { WebGAL } from '@/Core/WebGAL';

/**
 * 进行普通对话的显示
 * @param sentence 语句
 * @return {IPerform} 执行的演出
 */
export const showVars = (sentence: ISentence): IPerform => {
  const stageState = webgalStore.getState().stage;
  const userDataState = webgalStore.getState().userData;
  const dispatch = webgalStore.dispatch;
  // 设置文本显示
  const allVar = {
    stageGameVar: stageState.GameVar,
    globalGameVar: userDataState.globalGameVar,
  };
  dispatch(setStage({ key: 'showText', value: JSON.stringify(allVar) }));
  dispatch(setStage({ key: 'showName', value: '展示变量' }));
  logger.debug('展示变量：', allVar);
  setTimeout(() => {
    WebGAL.events.textSettle.emit();
  }, 0);
  const performInitName: string = getRandomPerformName();
  const endDelay = 750 - userDataState.optionData.textSpeed * 250;
  return {
    performName: performInitName,
    duration: endDelay,
    isHoldOn: false,
    stopFunction: () => {
      WebGAL.events.textSettle.emit();
    },
    blockingNext: () => false,
    blockingAuto: () => true,
    stopTimeout: undefined, // 暂时不用，后面会交给自动清除
  };
};



================================================
FILE: webgal/src/Core/gameScripts/template.ts
================================================
import { ISentence } from '@/Core/controller/scene/sceneInterface';
import { IPerform } from '@/Core/Modules/perform/performInterface';

/**
 * 语句执行的模板代码
 * @param sentence
 */
export const template = (sentence: ISentence): IPerform => {
  return {
    performName: 'none',
    duration: 0,
    isHoldOn: false,
    stopFunction: () => {},
    blockingNext: () => false,
    blockingAuto: () => true,
    stopTimeout: undefined, // 暂时不用，后面会交给自动清除
  };
};



================================================
FILE: webgal/src/Core/gameScripts/unlockBgm.ts
================================================
import { ISentence } from '@/Core/controller/scene/sceneInterface';
import { IPerform } from '@/Core/Modules/perform/performInterface';
import { webgalStore } from '@/store/store';
import { unlockBgmInUserData } from '@/store/userDataReducer';
import localforage from 'localforage';
import { logger } from '@/Core/util/logger';

import { WebGAL } from '@/Core/WebGAL';
import { getStringArgByKey } from '../util/getSentenceArg';

/**
 * 解锁bgm
 * @param sentence
 */
export const unlockBgm = (sentence: ISentence): IPerform => {
  const url = sentence.content;
  const name = getStringArgByKey(sentence, 'name') ?? sentence.content;
  const series = getStringArgByKey(sentence, 'series') ?? 'default';
  logger.info(`解锁BGM：${name}，路径：${url}，所属系列：${series}`);
  webgalStore.dispatch(unlockBgmInUserData({ name, url, series }));
  const userDataState = webgalStore.getState().userData;
  localforage.setItem(WebGAL.gameKey, userDataState).then(() => {});
  return {
    performName: 'none',
    duration: 0,
    isHoldOn: false,
    stopFunction: () => {},
    blockingNext: () => false,
    blockingAuto: () => true,
    stopTimeout: undefined, // 暂时不用，后面会交给自动清除
  };
};



================================================
FILE: webgal/src/Core/gameScripts/unlockCg.ts
================================================
import { ISentence } from '@/Core/controller/scene/sceneInterface';
import { IPerform } from '@/Core/Modules/perform/performInterface';
import { webgalStore } from '@/store/store';
import { unlockCgInUserData } from '@/store/userDataReducer';
import { logger } from '@/Core/util/logger';
import localforage from 'localforage';

import { WebGAL } from '@/Core/WebGAL';
import { getStringArgByKey } from '../util/getSentenceArg';

/**
 * 解锁cg
 * @param sentence
 */
export const unlockCg = (sentence: ISentence): IPerform => {
  const url = sentence.content;
  const name = getStringArgByKey(sentence, 'name') ?? sentence.content;
  const series = getStringArgByKey(sentence, 'series') ?? 'default';
  logger.info(`解锁CG：${name}，路径：${url}，所属系列：${series}`);
  webgalStore.dispatch(unlockCgInUserData({ name, url, series }));
  const userDataState = webgalStore.getState().userData;
  localforage.setItem(WebGAL.gameKey, userDataState).then(() => {});
  return {
    performName: 'none',
    duration: 0,
    isHoldOn: false,
    stopFunction: () => {},
    blockingNext: () => false,
    blockingAuto: () => true,
    stopTimeout: undefined, // 暂时不用，后面会交给自动清除
  };
};



================================================
FILE: webgal/src/Core/gameScripts/wait.ts
================================================
import { ISentence } from '@/Core/controller/scene/sceneInterface';
import { IPerform } from '@/Core/Modules/perform/performInterface';

/**
 * 等待 n 毫秒
 * @param sentence
 */
export const wait = (sentence: ISentence): IPerform => {
  const duration = Number(sentence.content);
  const performName = `wait${Math.random().toString()}`;
  return {
    performName,
    duration: duration,
    goNextWhenOver: true,
    isHoldOn: false,
    stopFunction: () => {},
    blockingNext: () => false,
    blockingAuto: () => true,
    stopTimeout: undefined, // 暂时不用，后面会交给自动清除
  };
};



================================================
FILE: webgal/src/Core/gameScripts/changeBg/index.ts
================================================
import { ISentence } from '@/Core/controller/scene/sceneInterface';
import { IPerform } from '@/Core/Modules/perform/performInterface';
// import {getRandomPerformName} from '../../../util/getRandomPerformName';
import styles from '@/Stage/stage.module.scss';
import { webgalStore } from '@/store/store';
import { setStage, stageActions } from '@/store/stageReducer';
import { getNumberArgByKey, getStringArgByKey } from '@/Core/util/getSentenceArg';
import { unlockCgInUserData } from '@/store/userDataReducer';
import { logger } from '@/Core/util/logger';
import { ITransform } from '@/store/stageInterface';
import { generateTransformAnimationObj } from '@/Core/controller/stage/pixi/animations/generateTransformAnimationObj';
import { AnimationFrame, IUserAnimation } from '@/Core/Modules/animations';
import cloneDeep from 'lodash/cloneDeep';
import { getAnimateDuration } from '@/Core/Modules/animationFunctions';
import { WebGAL } from '@/Core/WebGAL';

/**
 * 进行背景图片的切换
 * @param sentence 语句
 * @return {IPerform}
 */
export const changeBg = (sentence: ISentence): IPerform => {
  const url = sentence.content;
  const unlockName = getStringArgByKey(sentence, 'unlockname') ?? '';
  const series = getStringArgByKey(sentence, 'series') ?? 'default';
  const transformString = getStringArgByKey(sentence, 'transform');
  let duration = getNumberArgByKey(sentence, 'duration') ?? 1000;
  const ease = getStringArgByKey(sentence, 'ease') ?? '';

  const dispatch = webgalStore.dispatch;
  if (unlockName !== '') {
    dispatch(unlockCgInUserData({ name: unlockName, url, series }));
  }

  /**
   * 判断背景 URL 是否发生了变化
   */
  const isUrlChanged = webgalStore.getState().stage.bgName !== sentence.content;

  /**
   * 删掉相关 Effects，因为已经移除了
   */
  if (isUrlChanged) {
    dispatch(stageActions.removeEffectByTargetId(`bg-main`));
  }

  // 处理 transform 和 默认 transform
  let animationObj: AnimationFrame[];
  if (transformString) {
    try {
      const frame = JSON.parse(transformString.toString()) as AnimationFrame;
      animationObj = generateTransformAnimationObj('bg-main', frame, duration, ease);
      // 因为是切换，必须把一开始的 alpha 改为 0
      animationObj[0].alpha = 0;
      const animationName = (Math.random() * 10).toString(16);
      const newAnimation: IUserAnimation = { name: animationName, effects: animationObj };
      WebGAL.animationManager.addAnimation(newAnimation);
      duration = getAnimateDuration(animationName);
      WebGAL.animationManager.nextEnterAnimationName.set('bg-main', animationName);
    } catch (e) {
      // 解析都错误了，歇逼吧
      applyDefaultTransform();
    }
  } else {
    applyDefaultTransform();
  }

  function applyDefaultTransform() {
    // 应用默认的
    const frame = {};
    animationObj = generateTransformAnimationObj('bg-main', frame as AnimationFrame, duration, ease);
    // 因为是切换，必须把一开始的 alpha 改为 0
    animationObj[0].alpha = 0;
    const animationName = (Math.random() * 10).toString(16);
    const newAnimation: IUserAnimation = { name: animationName, effects: animationObj };
    WebGAL.animationManager.addAnimation(newAnimation);
    duration = getAnimateDuration(animationName);
    WebGAL.animationManager.nextEnterAnimationName.set('bg-main', animationName);
  }

  // 应用动画的优先级更高一点
  const enterAnimation = getStringArgByKey(sentence, 'enter');
  const exitAnimation = getStringArgByKey(sentence, 'exit');
  if (enterAnimation) {
    WebGAL.animationManager.nextEnterAnimationName.set('bg-main', enterAnimation);
    duration = getAnimateDuration(enterAnimation);
  }
  if (exitAnimation) {
    WebGAL.animationManager.nextExitAnimationName.set('bg-main-off', exitAnimation);
    duration = getAnimateDuration(exitAnimation);
  }

  /**
   * 背景状态后处理
   */
  function postBgStateSet() {
    if (isUrlChanged) {
      // 当 URL 发生变化时，清理旧的 hold 动画
      WebGAL.gameplay.performController.unmountPerform(`animation-bg-main`, true);
    }
  }

  postBgStateSet();
  dispatch(setStage({ key: 'bgName', value: sentence.content }));

  return {
    performName: `bg-main-${sentence.content}`,
    duration,
    isHoldOn: false,
    stopFunction: () => {
      WebGAL.gameplay.pixiStage?.stopPresetAnimationOnTarget('bg-main');
    },
    blockingNext: () => false,
    blockingAuto: () => true,
    stopTimeout: undefined, // 暂时不用，后面会交给自动清除
  };
};



================================================
FILE: webgal/src/Core/gameScripts/changeBg/setEbg.ts
================================================
export function setEbg(url: string) {
  const ebg = document.querySelector('.html-body__effect-background') as HTMLElement;
  if (ebg) {
    ebg.style.backgroundImage = `url("${url}")`;
  }
}



================================================
FILE: webgal/src/Core/gameScripts/choose/choose.module.scss
================================================
.Choose_Main {
  position: absolute;
  width: 100%;
  height: 100%;
  display: flex;
  flex-flow: column;
  justify-content: center;
  align-items: center;
  z-index: 13;
  background: rgba(0, 0, 0, 0.05);
}

.Choose_item {
  font-family: "WebgalUI", serif;
  cursor: pointer;
  min-width: 50%;
  padding: 0.25em 1em 0.25em 1em;
  font-size: 265%;
  color: #8E354A;
  text-align: center;
  border-radius: 4px;
  border: 3px solid rgba(0, 0, 0, 0);
  box-shadow: 0 0 25px rgba(0, 0, 0, 0.25);
  background: rgba(255, 255, 255, 0.65);
  margin: 0.25em 0 0.25em 0;
  transition: background-color 0.5s, border 0.5s, font-weight 0.5s, box-shadow 0.5s;

  &:hover {
    background: rgba(255, 255, 255, 0.9);
    box-shadow: 0 0 25px rgba(0, 0, 0, 0.35);
    border: 3px solid #8E354A;
  }
}

.Choose_item_disabled {
  font-family: "WebgalUI", serif;
  cursor: not-allowed;
  min-width: 50%;
  padding: 0.25em 1em 0.25em 1em;
  font-size: 265%;
  color: rgba(142, 53, 74, 0.5);
  text-align: center;
  border-radius: 4px;
  border: 3px solid rgba(0, 0, 0, 0);
  box-shadow: 0 0 25px rgba(0, 0, 0, 0.25);
  background: rgba(255, 255, 255, 0.5);
  margin: 0.25em 0 0.25em 0;
  transition: background-color 0.5s, border 0.5s, font-weight 0.5s, box-shadow 0.5s;
}

.Choose_item_outer {
  color: #000;
  min-width: 50%;
}



================================================
FILE: webgal/src/Core/gameScripts/choose/index.tsx
================================================
import { ISentence } from '@/Core/controller/scene/sceneInterface';
import { IPerform } from '@/Core/Modules/perform/performInterface';
import { changeScene } from '@/Core/controller/scene/changeScene';
import { jmp } from '@/Core/gameScripts/label/jmp';
import ReactDOM from 'react-dom';
import React from 'react';
import styles from './choose.module.scss';
import { webgalStore } from '@/store/store';
import { textFont } from '@/store/userDataInterface';
import { PerformController } from '@/Core/Modules/perform/performController';
import { useSEByWebgalStore } from '@/hooks/useSoundEffect';
import { WebGAL } from '@/Core/WebGAL';
import { whenChecker } from '@/Core/controller/gamePlay/scriptExecutor';
import useEscape from '@/hooks/useEscape';
import useApplyStyle from '@/hooks/useApplyStyle';
import { Provider } from 'react-redux';

class ChooseOption {
  /**
   * 格式：
   * (showConditionVar>1)[enableConditionVar>2]->text:jump
   */
  public static parse(script: string): ChooseOption {
    const parts = script.split('->');
    const conditonPart = parts.length > 1 ? parts[0] : null;
    const mainPart = parts.length > 1 ? parts[1] : parts[0];
    const mainPartNodes = mainPart.split(/(?<!\\):/g);
    const option = new ChooseOption(mainPartNodes[0], mainPartNodes[1]);
    if (conditonPart !== null) {
      const showConditionPart = conditonPart.match(/\((.*)\)/);
      if (showConditionPart) {
        option.showCondition = showConditionPart[1];
      }
      const enableConditionPart = conditonPart.match(/\[(.*)\]/);
      if (enableConditionPart) {
        option.enableCondition = enableConditionPart[1];
      }
    }
    return option;
  }
  public text: string;
  public jump: string;
  public jumpToScene: boolean;
  public showCondition?: string;
  public enableCondition?: string;

  public constructor(text: string, jump: string) {
    this.text = useEscape(text);
    this.jump = jump;
    this.jumpToScene = jump.match(/(?<!\\)\./) !== null;
  }
}

/**
 * 显示选择枝
 * @param sentence
 */
export const choose = (sentence: ISentence): IPerform => {
  const chooseOptionScripts = sentence.content.split(/(?<!\\)\|/);
  const chooseOptions = chooseOptionScripts.map((e) => ChooseOption.parse(e.trim()));

  // eslint-disable-next-line react/no-deprecated
  ReactDOM.render(
    <Provider store={webgalStore}>
      <Choose chooseOptions={chooseOptions} />
    </Provider>,
    document.getElementById('chooseContainer'),
  );
  return {
    performName: 'choose',
    duration: 1000 * 60 * 60 * 24,
    isHoldOn: false,
    stopFunction: () => {
      // eslint-disable-next-line react/no-deprecated
      ReactDOM.render(<div />, document.getElementById('chooseContainer'));
    },
    blockingNext: () => true,
    blockingAuto: () => true,
    stopTimeout: undefined, // 暂时不用，后面会交给自动清除
  };
};

function Choose(props: { chooseOptions: ChooseOption[] }) {
  const fontFamily = webgalStore.getState().userData.optionData.textboxFont;
  const font = fontFamily === textFont.song ? '"思源宋体", serif' : '"WebgalUI", serif';
  const { playSeEnter, playSeClick } = useSEByWebgalStore();
  const applyStyle = useApplyStyle('Stage/Choose/choose.scss');
  // 运行时计算JSX.Element[]
  const runtimeBuildList = (chooseListFull: ChooseOption[]) => {
    return chooseListFull
      .filter((e, i) => whenChecker(e.showCondition))
      .map((e, i) => {
        const enable = whenChecker(e.enableCondition);
        const className = enable
          ? applyStyle('Choose_item', styles.Choose_item)
          : applyStyle('Choose_item_disabled', styles.Choose_item_disabled);
        const onClick = enable
          ? () => {
              playSeClick();
              if (e.jumpToScene) {
                changeScene(e.jump, e.text);
              } else {
                jmp(e.jump);
              }
              WebGAL.gameplay.performController.unmountPerform('choose');
            }
          : () => {};
        return (
          <div className={applyStyle('Choose_item_outer', styles.Choose_item_outer)} key={e.jump + i}>
            <div className={className} style={{ fontFamily: font }} onClick={onClick} onMouseEnter={playSeEnter}>
              {e.text}
            </div>
          </div>
        );
      });
  };

  return <div className={applyStyle('Choose_Main', styles.Choose_Main)}>{runtimeBuildList(props.chooseOptions)}</div>;
}



================================================
FILE: webgal/src/Core/gameScripts/getUserInput/getUserInput.module.scss
================================================
.Choose_Main {
  position: absolute;
  width: 100%;
  height: 100%;
  display: flex;
  flex-flow: column;
  justify-content: center;
  align-items: center;
  z-index: 13;
  background: rgba(0, 0, 0, 0.05);
}

.Choose_item {
  cursor: pointer;
  min-width: 50%;
  padding: 0.25em 1em 0.25em 1em;
  font-size: 265%;
  color: #005caf;
  text-align: center;
  border-radius: 4px;
  border: 3px solid rgba(0, 0, 0, 0);
  box-shadow: 0 0 25px rgba(0, 0, 0, 0.25);
  background: rgba(255, 255, 255, 0.65);
  margin: 0.25em 0 0.25em 0;
  transition: background-color 0.5s, border 0.5s, font-weight 0.5s, box-shadow 0.5s;
}

//.title {
//  cursor: pointer;
//  min-width: 50%;
//  padding: 0.25em 1em 0.25em 1em;
//  font-size: 265%;
//  color: #8E354A;
//  text-align: center;
//  border-radius: 4px;
//  border: 3px solid rgba(0, 0, 0, 0);
//  box-shadow: 0 0 25px rgba(0, 0, 0, 0.25);
//  background: rgba(255, 255, 255, 0.65);
//  margin: 0.25em 0 0.25em 0;
//  transition: background-color 0.5s, border 0.5s, font-weight 0.5s, box-shadow 0.5s;
//}

.glabalDialog_container_inner {
  width: 100%;
  height: 100%;
  display: flex;
  justify-content: center;
  align-items: center;
  flex-flow: column;
  background: linear-gradient(to right,
    rgba(0, 92, 175, 0) 0%,
    rgba(0, 92, 175, 0.5) 33%,
    rgba(0, 92, 175, 0.85) 50%,
    rgba(0, 92, 175, 0.5) 66%,
    rgba(0, 92, 175, 0) 100%
  );
  padding: 1em 5em 1.5em 5em;
}

.glabalDialog_container {
  //height: 20%;
  color:white;
  width: 100%;
  border-top: 4px solid;
  border-bottom: 4px solid;
  border-image: linear-gradient(to right,
    rgba(255, 255, 255, 0.05) 0%,
    rgba(255, 255, 255, 0.85) 33%,
    rgba(255, 255, 255, 1) 50%,
    rgba(255, 255, 255, 0.85) 66%,
    rgba(255, 255, 255, 0.05) 100%
  ) 1;
  //padding: 1px 1px 1px 1px;
}

.title {
  font-size: 300%;
  letter-spacing: 0.05em;
  text-shadow: 0 0 10px rgba(255, 255, 255, 0.5);
}

.Choose_item:hover {
  //font-weight: bold;
  background: rgba(255, 255, 255, 0.9);
  box-shadow: 0 0 25px rgba(0, 0, 0, 0.35);
  border: 3px solid #005caf;
}

.button {
  font-size: 200%;
  padding: 0.15em 1em 0.15em 1em;
  margin: 0.2em 1em 0.2em 1em;
  cursor: pointer;
  transition: background-color 0.33s, color 0.33s, font-weight 0.33s, transform 0.33s;
  text-shadow: 0 0 10px rgba(255, 255, 255, 1);
  border-radius: 5px;
  //background: rgba(0, 0, 0, 0.05);
}

.button:hover {
  font-weight: bold;
  color: #005caf;
  transform: scale(1.1, 1.1);
  text-shadow: 0 0 15px rgba(0, 0, 0, 0);
  background: rgba(255, 255, 255, 0.85);
}



================================================
FILE: webgal/src/Core/gameScripts/getUserInput/index.tsx
================================================
import { ISentence } from '@/Core/controller/scene/sceneInterface';
import { IPerform } from '@/Core/Modules/perform/performInterface';
import { changeScene } from '@/Core/controller/scene/changeScene';
import { jmp } from '@/Core/gameScripts/label/jmp';
import ReactDOM from 'react-dom';
import React from 'react';
import styles from './getUserInput.module.scss';
import { webgalStore } from '@/store/store';
import { textFont } from '@/store/userDataInterface';
import { PerformController } from '@/Core/Modules/perform/performController';
import { useSEByWebgalStore } from '@/hooks/useSoundEffect';
import { WebGAL } from '@/Core/WebGAL';
import { getStringArgByKey } from '@/Core/util/getSentenceArg';
import { nextSentence } from '@/Core/controller/gamePlay/nextSentence';
import { setStageVar } from '@/store/stageReducer';

/**
 * 显示选择枝
 * @param sentence
 */
export const getUserInput = (sentence: ISentence): IPerform => {
  const varKey = sentence.content.toString().trim();

  let title = getStringArgByKey(sentence, 'title') ?? '';
  title = title === '' ? 'Please Input' : title;
  let buttonText = getStringArgByKey(sentence, 'buttonText') ?? '';
  buttonText = buttonText === '' ? 'OK' : buttonText;
  const defaultValue = getStringArgByKey(sentence, 'defaultValue');

  const fontFamily = webgalStore.getState().userData.optionData.textboxFont;
  const font = fontFamily === textFont.song ? '"思源宋体", serif' : '"WebgalUI", serif';

  const { playSeEnter, playSeClick } = useSEByWebgalStore();
  const chooseElements = (
    <div style={{ fontFamily: font }} className={styles.glabalDialog_container}>
      <div className={styles.glabalDialog_container_inner}>
        <div className={styles.title}>{title}</div>
        <input id="user-input" className={styles.Choose_item} />
        <div
          onMouseEnter={playSeEnter}
          onClick={() => {
            const userInput: HTMLInputElement = document.getElementById('user-input') as HTMLInputElement;
            if (userInput) {
              webgalStore.dispatch(
                setStageVar({
                  key: varKey,
                  value: userInput?.value || defaultValue || ' ',
                }),
              );
            }
            playSeClick();
            WebGAL.gameplay.performController.unmountPerform('userInput');
            nextSentence();
          }}
          className={styles.button}
        >
          {buttonText}
        </div>
      </div>
    </div>
  );
  // eslint-disable-next-line react/no-deprecated
  ReactDOM.render(
    <div className={styles.Choose_Main}>{chooseElements}</div>,
    document.getElementById('chooseContainer'),
  );
  return {
    performName: 'userInput',
    duration: 1000 * 60 * 60 * 24,
    isHoldOn: false,
    stopFunction: () => {
      // eslint-disable-next-line react/no-deprecated
      ReactDOM.render(<div />, document.getElementById('chooseContainer'));
    },
    blockingNext: () => true,
    blockingAuto: () => true,
    stopTimeout: undefined, // 暂时不用，后面会交给自动清除
  };
};



================================================
FILE: webgal/src/Core/gameScripts/label/index.ts
================================================
import { ISentence } from '@/Core/controller/scene/sceneInterface';
import { IPerform } from '@/Core/Modules/perform/performInterface';

/**
 * 标签代码，什么也不做
 * @param sentence
 */
export const label = (sentence: ISentence): IPerform => {
  return {
    performName: 'none',
    duration: 0,
    isHoldOn: false,
    stopFunction: () => {},
    blockingNext: () => false,
    blockingAuto: () => true,
    stopTimeout: undefined, // 暂时不用，后面会交给自动清除
  };
};



================================================
FILE: webgal/src/Core/gameScripts/label/jmp.ts
================================================
import { commandType } from '@/Core/controller/scene/sceneInterface';
import { nextSentence } from '@/Core/controller/gamePlay/nextSentence';

import { WebGAL } from '@/Core/WebGAL';

export const jmp = (labelName: string) => {
  // 在当前场景中找到指定的标签。
  const currentLine = WebGAL.sceneManager.sceneData.currentSentenceId;
  let result = currentLine;
  WebGAL.sceneManager.sceneData.currentScene.sentenceList.forEach((sentence, index) => {
    if (sentence.command === commandType.label && sentence.content === labelName && index !== currentLine) {
      result = index;
    }
  });
  WebGAL.sceneManager.sceneData.currentSentenceId = result;
  setTimeout(nextSentence, 1);
};



================================================
FILE: webgal/src/Core/gameScripts/pixi/index.ts
================================================
import { ISentence } from '@/Core/controller/scene/sceneInterface';
import { IPerform } from '@/Core/Modules/perform/performInterface';
import { logger } from '@/Core/util/logger';
import { IResult, call } from '../../util/pixiPerformManager/pixiPerformManager';

import { WebGAL } from '@/Core/WebGAL';

/**
 * 运行一段pixi演出
 * @param sentence
 */
export const pixi = (sentence: ISentence): IPerform => {
  const pixiPerformName = 'PixiPerform' + sentence.content;
  WebGAL.gameplay.performController.performList.forEach((e) => {
    if (e.performName === pixiPerformName) {
      return {
        performName: 'none',
        duration: 0,
        isOver: false,
        isHoldOn: true,
        stopFunction: () => {},
        blockingNext: () => false,
        blockingAuto: () => false,
        stopTimeout: undefined, // 暂时不用，后面会交给自动清除
      };
    }
  });
  const res: IResult = call(sentence.content);
  const { fg, bg } = res;

  return {
    performName: pixiPerformName,
    duration: 0,
    isHoldOn: true,
    stopFunction: () => {
      logger.warn('现在正在卸载pixi演出');
      if (fg) {
        fg.container.destroy({ texture: true, baseTexture: true });
        WebGAL.gameplay.pixiStage?.foregroundEffectsContainer.removeChild(fg.container);
        WebGAL.gameplay.pixiStage?.removeAnimation(fg.tickerKey);
      }
      if (bg) {
        bg.container.destroy({ texture: true, baseTexture: true });
        WebGAL.gameplay.pixiStage?.backgroundEffectsContainer.removeChild(bg.container);
        WebGAL.gameplay.pixiStage?.removeAnimation(bg.tickerKey);
      }
    },
    blockingNext: () => false,
    blockingAuto: () => false,
    stopTimeout: undefined, // 暂时不用，后面会交给自动清除
  };
};



================================================
FILE: webgal/src/Core/gameScripts/pixi/pixiInit.ts
================================================
import { commandType, ISentence } from '@/Core/controller/scene/sceneInterface';
import { IPerform } from '@/Core/Modules/perform/performInterface';
import { logger } from '@/Core/util/logger';
import { webgalStore } from '@/store/store';
import { resetStageState, stageActions } from '@/store/stageReducer';
import cloneDeep from 'lodash/cloneDeep';

import { WebGAL } from '@/Core/WebGAL';
import { IRunPerform } from '@/store/stageInterface';

/**
 * 初始化pixi
 * @param sentence
 */
export const pixiInit = (sentence: ISentence): IPerform => {
  WebGAL.gameplay.performController.performList.forEach((e) => {
    if (e.performName.match(/PixiPerform/)) {
      logger.warn('pixi 被脚本重新初始化', e.performName);
      /**
       * 卸载演出
       */
      for (let i = 0; i < WebGAL.gameplay.performController.performList.length; i++) {
        const e2 = WebGAL.gameplay.performController.performList[i];
        if (e2.performName === e.performName) {
          e2.stopFunction();
          clearTimeout(e2.stopTimeout as unknown as number);
          WebGAL.gameplay.performController.performList.splice(i, 1);
          i--;
        }
      }
      /**
       * 从状态表里清除演出
       */
      webgalStore.dispatch(stageActions.removeAllPixiPerforms());
    }
  });
  return {
    performName: 'none',
    duration: 0,
    isHoldOn: false,
    stopFunction: () => {},
    blockingNext: () => false,
    blockingAuto: () => true,
    stopTimeout: undefined, // 暂时不用，后面会交给自动清除
  };
};



================================================
FILE: webgal/src/Core/gameScripts/pixi/performs/cherryBlossoms.ts
================================================
/* eslint-disable max-params */
import * as PIXI from 'pixi.js';
import { registerPerform } from '@/Core/util/pixiPerformManager/pixiPerformManager';
import { WebGAL } from '@/Core/WebGAL';
import { SCREEN_CONSTANTS } from '@/Core/util/constants';
import { getGameAssetPath } from '@/Core/gameState';

type ContainerType = 'foreground' | 'background';

interface SakuraSprite extends PIXI.Sprite {
  speed: number;
  positionPhase: number;
  scalePhase: number;
  rotationSpeed: number;
}

const pixiCherryBlossoms = (
  tickerKey: string,
  containerType: ContainerType,
  speed: number, // 下落速度
  horizontal: number, // 横向摆动幅度
  maxNumber: number, // 最大数量
  scale: number, // 缩放
  angle: number, // 角度
) => {
  const pixiStage = WebGAL.gameplay.pixiStage!;

  const effectsContainer =
    containerType === 'foreground' ? pixiStage.foregroundEffectsContainer : pixiStage.backgroundEffectsContainer;

  const screenWidth = SCREEN_CONSTANTS.width;
  const screenHeight = SCREEN_CONSTANTS.height;

  const container = new PIXI.Container();

  container.angle = angle;

  const angleInRadians = container.rotation;
  const absCos = Math.abs(Math.cos(angleInRadians));
  const absSin = Math.abs(Math.sin(angleInRadians));

  const stageWidth = screenWidth * absCos + screenHeight * absSin;
  const stageHeight = screenWidth * absSin + screenHeight * absCos;

  container.width = stageWidth;
  container.height = stageHeight;
  container.pivot.set(stageWidth / 2, stageHeight / 2);
  container.position.set(screenWidth / 2, screenHeight / 2);

  effectsContainer.addChild(container);

  const particleContainer = new PIXI.ParticleContainer(maxNumber, {
    scale: true,
    position: true,
    rotation: true,
    uvs: false,
    alpha: true,
  });

  container.addChild(particleContainer);

  const sakuras: SakuraSprite[] = [];
  const texture = PIXI.Texture.from(getGameAssetPath('tex/cherryBlossoms.webp'));

  const randRange = (min: number, max: number): number => min + Math.random() * (max - min);

  for (let i = 0; i < maxNumber; i++) {
    const scalePhase = Math.random() * Math.PI * 2;

    const sakura = PIXI.Sprite.from(texture) as SakuraSprite;

    sakura.anchor.set(0.5);
    sakura.x = Math.random() * stageWidth;
    sakura.y = Math.random() * stageHeight;
    sakura.rotation = Math.random() * Math.PI * 2;
    sakura.scale.set(Math.cos(scalePhase) * scale, Math.sin(scalePhase) * scale);
    sakura.speed = (randRange(0.5, 2.0) + randRange(0.1, 1)) * speed;
    sakura.rotationSpeed = Math.random() * 0.015 * (Math.random() < 0.5 ? 1 : -1);
    sakura.positionPhase = Math.random() * Math.PI * 2;
    sakura.scalePhase = scalePhase;

    sakuras.push(sakura);
    particleContainer.addChild(sakura);
  }

  function tickerFn(delta: number): void {
    const currentTime = Date.now() / 1000;

    for (const sakura of sakuras) {
      const horizontalMovement = Math.sin(currentTime + sakura.positionPhase) * horizontal;
      sakura.x += horizontalMovement * delta;
      sakura.y += sakura.speed * delta;
      sakura.rotation += sakura.rotationSpeed * delta;

      const newScaleX = Math.cos(currentTime + sakura.scalePhase) * scale;
      const newScaleY = Math.sin(currentTime + sakura.scalePhase) * scale;
      sakura.scale.set(newScaleX, newScaleY);

      const actualSpriteWidth = Math.abs(sakura.width * scale);
      const actualSpriteHeight = Math.abs(sakura.height * scale);

      if (sakura.x + actualSpriteWidth / 2 < -stageWidth) {
        sakura.x = stageWidth + actualSpriteWidth / 2;
      } else if (sakura.x - actualSpriteWidth / 2 > stageWidth) {
        sakura.x = -stageWidth - actualSpriteWidth / 2;
      }

      if (sakura.y - actualSpriteHeight / 2 > stageHeight) {
        sakura.x = Math.random() * stageWidth;
        sakura.y = -Math.random() * 50 - actualSpriteHeight;

        sakura.positionPhase = Math.random() * Math.PI * 2;
        sakura.scalePhase = Math.random() * Math.PI * 2;
        sakura.speed = (randRange(0.5, 2.0) + randRange(0.1, 1)) * speed;
        sakura.rotationSpeed = Math.random() * 0.015 * (Math.random() < 0.5 ? 1 : -1);
      }
    }
  }

  pixiStage.registerAnimation(
    {
      setStartState: () => {},
      setEndState: () => {},
      tickerFunc: tickerFn,
    },
    tickerKey,
  );

  return { container, tickerKey };
};

registerPerform('cherryBlossoms', {
  fg: () => pixiCherryBlossoms('cherry-blossoms-foreground-ticker', 'foreground', 2, 3, 100, 0.05, 0),
  bg: () => pixiCherryBlossoms('cherry-blossoms-background-ticker', 'background', 1, 2, 300, 0.025, 0),
});



================================================
FILE: webgal/src/Core/gameScripts/pixi/performs/rain.ts
================================================
/* eslint-disable max-params */
import * as PIXI from 'pixi.js';
import { registerPerform } from '@/Core/util/pixiPerformManager/pixiPerformManager';
import { WebGAL } from '@/Core/WebGAL';
import { SCREEN_CONSTANTS } from '@/Core/util/constants';
import { getGameAssetPath } from '@/Core/gameState';

type ContainerType = 'foreground' | 'background';

interface RaindropSprite extends PIXI.Sprite {
  vy: number;
  vx: number;
}

const pixiRain = (
  tickerKey: string,
  containerType: ContainerType,
  speed: number, // 下落速度
  maxNumber: number, // 最大数量
  scale: number, // 大小
  angle: number, // 角度
) => {
  const pixiStage = WebGAL.gameplay.pixiStage!;
  const app = pixiStage.currentApp!;

  const effectsContainer =
    containerType === 'foreground' ? pixiStage.foregroundEffectsContainer : pixiStage.backgroundEffectsContainer;

  const screenWidth = SCREEN_CONSTANTS.width;
  const screenHeight = SCREEN_CONSTANTS.height;

  const container = new PIXI.Container();

  container.angle = angle;

  const angleInRadians = container.rotation;
  const absCos = Math.abs(Math.cos(angleInRadians));
  const absSin = Math.abs(Math.sin(angleInRadians));

  const stageWidth = screenWidth * absCos + screenHeight * absSin;
  const stageHeight = screenWidth * absSin + screenHeight * absCos;

  container.width = stageWidth;
  container.height = stageHeight;
  container.pivot.set(stageWidth / 2, stageHeight / 2);
  container.position.set(screenWidth / 2, screenHeight / 2);

  effectsContainer.addChild(container);

  const particleContainer = new PIXI.ParticleContainer(maxNumber, {
    scale: true,
    position: true,
    rotation: true,
    alpha: true,
    uvs: false,
  });

  container.addChild(particleContainer);

  const raindropTextures: PIXI.Texture[] = [];
  const raindrops: RaindropSprite[] = [];

  const baseTexturePath = getGameAssetPath('tex/rain.png');
  const SPRITE_WIDTH = 128;
  const SPRITE_HEIGHT = 640;
  const NUM_SPRITES = 5;

  const styleWeights = [10, 5, 2, 2, 1]; // 样式权重

  const getWeightedRandomIndex = (weights: number[]): number => {
    if (!weights || weights.length === 0) {
      return 0;
    }
    const totalWeight = weights.reduce((sum, weight) => sum + weight, 0);
    if (totalWeight <= 0) {
      return Math.floor(Math.random() * weights.length);
    }
    let random = Math.random() * totalWeight;
    for (let i = 0; i < weights.length; i++) {
      if (random < weights[i]) {
        return i;
      }
      random -= weights[i];
    }
    return weights.length - 1;
  };

  const resetRaindrop = (raindrop: RaindropSprite, isInitialSpawn = false) => {
    const randomScaleFactor = Math.random() * 0.5 + 0.5; // 随机缩放因子
    raindrop.scale.set(scale * randomScaleFactor);
    raindrop.anchor.set(0.5);

    if (isInitialSpawn) {
      raindrop.x = Math.random() * stageWidth;
      raindrop.y = Math.random() * stageHeight;
    } else {
      raindrop.x = Math.random() * stageWidth;
      raindrop.y = -Math.random() * 50 - raindrop.height;
    }

    raindrop.alpha = Math.random() * 0.5 + 0.5; // 随机透明度
    raindrop.vy = (Math.random() * 0.4 + 0.8) * speed; // 随机垂直速度
  };

  const createRaindropInstance = (): RaindropSprite => {
    let textureIndex: number;
    if (raindropTextures.length === NUM_SPRITES) {
      textureIndex = getWeightedRandomIndex(styleWeights);
    } else {
      textureIndex = Math.floor(Math.random() * raindropTextures.length);
    }
    textureIndex = Math.max(0, Math.min(textureIndex, raindropTextures.length - 1));

    const raindrop = new PIXI.Sprite(raindropTextures[textureIndex]) as RaindropSprite;
    resetRaindrop(raindrop, true);
    return raindrop;
  };

  const tickerFn = (delta: number) => {
    for (const raindrop of raindrops) {
      raindrop.y += raindrop.vy * delta;
      if (
        raindrop.y - raindrop.height / 2 > stageHeight ||
        raindrop.x < -raindrop.width ||
        raindrop.x > stageWidth + raindrop.width
      ) {
        resetRaindrop(raindrop, false);
      }
    }
  };

  const setupRaindropsAndAnimation = () => {
    raindropTextures.length = 0;
    while (raindrops.length > 0) raindrops.pop();
    particleContainer.removeChildren();

    const baseTexture = PIXI.BaseTexture.from(baseTexturePath);

    const finalizeSetup = () => {
      if (baseTexture.valid) {
        for (let i = 0; i < NUM_SPRITES; i++) {
          const frame = new PIXI.Rectangle(i * SPRITE_WIDTH, 0, SPRITE_WIDTH, SPRITE_HEIGHT);
          raindropTextures.push(new PIXI.Texture(baseTexture, frame));
        }
      }

      if (raindropTextures.length === 0) {
        console.error(`Failed to create any raindrop textures. Cannot create sprites.`);
        return;
      }
      if (!raindropTextures[0]?.valid) {
        console.warn(`First raindrop texture is invalid after creation. Sprites might not render correctly.`);
      }

      for (let i = 0; i < maxNumber; i++) {
        const raindrop = createRaindropInstance();
        particleContainer.addChild(raindrop);
        raindrops.push(raindrop);
      }

      pixiStage.registerAnimation(
        {
          setStartState: () => {},
          setEndState: () => {},
          tickerFunc: tickerFn,
        },
        tickerKey,
      );
    };

    if (baseTexture.valid) {
      finalizeSetup();
    } else {
      baseTexture.once('loaded', () => {
        finalizeSetup();
      });
      baseTexture.once('error', (errorEvent) => {
        console.error(`Error loading base texture ${baseTexturePath}:`, errorEvent);
        finalizeSetup();
      });
    }
  };

  setupRaindropsAndAnimation();

  return { container, tickerKey };
};

registerPerform('rain', {
  fg: () => pixiRain('rain-foreground-ticker', 'foreground', 30, 50, 0.4, 1),
  bg: () => pixiRain('rain-background-ticker', 'background', 20, 150, 0.3, 1),
});



================================================
FILE: webgal/src/Core/gameScripts/pixi/performs/snow.ts
================================================
/* eslint-disable max-params */
import * as PIXI from 'pixi.js';
import { registerPerform } from '@/Core/util/pixiPerformManager/pixiPerformManager';
import { WebGAL } from '@/Core/WebGAL';
import { SCREEN_CONSTANTS } from '@/Core/util/constants';
import { getGameAssetPath } from '@/Core/gameState';

type ContainerType = 'foreground' | 'background';

interface SnowflakeSprite extends PIXI.Sprite {
  vy: number;
  vx: number;
  rotationSpeed: number;
}

const pixiSnow = (
  tickerKey: string,
  containerType: ContainerType,
  speed: number, // 下落速度
  maxNumber: number, // 最大数量
  scale: number, // 大小
  angle: number, // 角度
) => {
  const pixiStage = WebGAL.gameplay.pixiStage!;
  const app = pixiStage.currentApp!;

  const effectsContainer =
    containerType === 'foreground' ? pixiStage.foregroundEffectsContainer : pixiStage.backgroundEffectsContainer;

  const screenWidth = SCREEN_CONSTANTS.width;
  const screenHeight = SCREEN_CONSTANTS.height;

  const container = new PIXI.Container();

  container.angle = angle;

  const angleInRadians = container.rotation;
  const absCos = Math.abs(Math.cos(angleInRadians));
  const absSin = Math.abs(Math.sin(angleInRadians));

  const stageWidth = screenWidth * absCos + screenHeight * absSin;
  const stageHeight = screenWidth * absSin + screenHeight * absCos;

  container.width = stageWidth;
  container.height = stageHeight;
  container.pivot.set(stageWidth / 2, stageHeight / 2);
  container.position.set(screenWidth / 2, screenHeight / 2);

  effectsContainer.addChild(container);

  const particleContainer = new PIXI.ParticleContainer(maxNumber, {
    scale: true,
    position: true,
    rotation: true,
    alpha: true,
    uvs: false,
  });

  container.addChild(particleContainer);

  const snowflakeTextures: PIXI.Texture[] = [];
  const snowflakes: SnowflakeSprite[] = [];

  const baseTexturePath = getGameAssetPath('tex/snow.png');
  const SPRITE_WIDTH = 128;
  const SPRITE_HEIGHT = 128;
  const NUM_SPRITES = 10;

  const styleWeights = [10, 2, 2, 2, 1, 1, 1, 2, 2, 2]; // 雪花样式权重

  const getWeightedRandomIndex = (weights: number[]): number => {
    if (!weights || weights.length === 0) {
      return 0;
    }
    const totalWeight = weights.reduce((sum, weight) => sum + weight, 0);
    if (totalWeight <= 0) {
      return Math.floor(Math.random() * weights.length);
    }
    let random = Math.random() * totalWeight;
    for (let i = 0; i < weights.length; i++) {
      if (random < weights[i]) {
        return i;
      }
      random -= weights[i];
    }
    return weights.length - 1;
  };

  const resetSnowflake = (snowflake: SnowflakeSprite, isInitialSpawn = false) => {
    const randomScaleFactor = Math.random() * 0.5 + 0.5; // 随机缩放因子
    snowflake.scale.set(scale * randomScaleFactor);
    snowflake.anchor.set(0.5);

    if (isInitialSpawn) {
      snowflake.x = Math.random() * stageWidth;
      snowflake.y = Math.random() * stageHeight;
    } else {
      snowflake.x = Math.random() * stageWidth;
      snowflake.y = -Math.random() * 50 - snowflake.height;
    }

    snowflake.alpha = Math.random() * 0.2 + 0.8; // 随机透明度
    snowflake.vy = (Math.random() * 0.4 + 0.8) * speed; // 随机垂直速度
    snowflake.vx = (Math.random() - 0.5) * 0.25 * speed; // 随机水平速度
    snowflake.rotationSpeed = (Math.random() - 0.5) * 0.005; // 随机旋转速度
  };

  const createSnowflakeInstance = (): SnowflakeSprite => {
    let textureIndex: number;
    if (snowflakeTextures.length === NUM_SPRITES) {
      textureIndex = getWeightedRandomIndex(styleWeights);
    } else {
      textureIndex = Math.floor(Math.random() * snowflakeTextures.length);
    }
    textureIndex = Math.max(0, Math.min(textureIndex, snowflakeTextures.length - 1));

    const snowflake = new PIXI.Sprite(snowflakeTextures[textureIndex]) as SnowflakeSprite;
    resetSnowflake(snowflake, true);
    return snowflake;
  };

  const tickerFn = (delta: number) => {
    for (const snowflake of snowflakes) {
      snowflake.y += snowflake.vy * delta;
      snowflake.x += snowflake.vx * delta;
      snowflake.rotation += snowflake.rotationSpeed * delta;
      if (
        snowflake.y - snowflake.height / 2 > stageHeight ||
        snowflake.x < -snowflake.width ||
        snowflake.x > stageWidth + snowflake.width
      ) {
        resetSnowflake(snowflake, false);
      }
    }
  };

  const setupSnowflakesAndAnimation = () => {
    snowflakeTextures.length = 0;
    while (snowflakes.length > 0) snowflakes.pop();
    particleContainer.removeChildren();

    const baseTexture = PIXI.BaseTexture.from(baseTexturePath);

    const finalizeSetup = () => {
      if (baseTexture.valid) {
        for (let i = 0; i < NUM_SPRITES; i++) {
          const frame = new PIXI.Rectangle(i * SPRITE_WIDTH, 0, SPRITE_WIDTH, SPRITE_HEIGHT);
          snowflakeTextures.push(new PIXI.Texture(baseTexture, frame));
        }
      }

      if (snowflakeTextures.length === 0) {
        console.error(`Failed to create any snowflake textures. Cannot create sprites.`);
        return;
      }
      if (!snowflakeTextures[0]?.valid) {
        console.warn(`First snowflake texture is invalid after creation. Sprites might not render correctly.`);
      }

      for (let i = 0; i < maxNumber; i++) {
        const snowflake = createSnowflakeInstance();
        particleContainer.addChild(snowflake);
        snowflakes.push(snowflake);
      }

      pixiStage.registerAnimation(
        {
          setStartState: () => {},
          setEndState: () => {},
          tickerFunc: tickerFn,
        },
        tickerKey,
      );
    };

    if (baseTexture.valid) {
      finalizeSetup();
    } else {
      baseTexture.once('loaded', () => {
        finalizeSetup();
      });
      baseTexture.once('error', (errorEvent) => {
        console.error(`Error loading base texture ${baseTexturePath}:`, errorEvent);
        finalizeSetup();
      });
    }
  };

  setupSnowflakesAndAnimation();

  return { container, tickerKey };
};

registerPerform('snow', {
  fg: () => pixiSnow('snow-foreground-ticker', 'foreground', 3, 250, 0.4, 0),
  bg: () => pixiSnow('snow-background-ticker', 'background', 1, 750, 0.2, 0),
});

registerPerform('heavySnow', {
  fg: () => pixiSnow('heavy-snow-foreground-ticker', 'foreground', 20, 1000, 0.6, -75),
  bg: () => pixiSnow('heavy-snow-background-ticker', 'background', 10, 2000, 0.3, -80),
});



================================================
FILE: webgal/src/Core/gameScripts/vocal/conentsCash.ts
================================================
export class FigureConentsCash {
  private _content = '';

  // public constructor() {}
  public push(sentenceContent: string) {
    this._content = sentenceContent;
  }
  public pop(): string {
    const constContent = this._content;
    this._content = '';
    return constContent;
  }
}

export class VoiceConentsCash {
  private _content = '';

  // public constructor() {}
  public push(sentenceContent: string) {
    this._content = sentenceContent;
  }
  public pop(): string {
    const constContent = this._content;
    this._content = '';
    return constContent;
  }
}

export const figureCash = new FigureConentsCash();
export const voiceCash = new VoiceConentsCash();



================================================
FILE: webgal/src/Core/gameScripts/vocal/index.ts
================================================
import { ISentence } from '@/Core/controller/scene/sceneInterface';
import { logger } from '@/Core/util/logger';
import { webgalStore } from '@/store/store';
import { setStage } from '@/store/stageReducer';
import { getBooleanArgByKey, getNumberArgByKey, getStringArgByKey } from '@/Core/util/getSentenceArg';
import { IStageState } from '@/store/stageInterface';
import {
  audioContextWrapper,
  getAudioLevel,
  performBlinkAnimation,
  performMouthAnimation,
  updateThresholds,
} from '@/Core/gameScripts/vocal/vocalAnimation';
import { match } from '../../util/match';
import { WebGAL } from '@/Core/WebGAL';

/**
 * 播放一段语音
 * @param sentence 语句
 */
export const playVocal = (sentence: ISentence) => {
  logger.debug('play vocal');
  const performInitName = 'vocal-play';

  const url = getStringArgByKey(sentence, 'vocal') ?? ''; // 获取语音的url
  let volume = getNumberArgByKey(sentence, 'volume') ?? 100; // 获取语音的音量比
  volume = Math.max(0, Math.min(volume, 100)); // 限制音量在 0-100 之间

  let currentStageState: IStageState;
  currentStageState = webgalStore.getState().stage;

  let pos: 'center' | 'left' | 'right' = 'center';
  const leftFromArgs = getBooleanArgByKey(sentence, 'left') ?? false;
  const rightFromArgs = getBooleanArgByKey(sentence, 'right') ?? false;
  if (leftFromArgs) pos = 'left';
  if (rightFromArgs) pos = 'right';

  let key = getStringArgByKey(sentence, 'figureId') ?? '';

  const freeFigure = currentStageState.freeFigure;
  const figureAssociatedAnimation = currentStageState.figureAssociatedAnimation;
  let bufferLength = 0;
  let currentMouthValue = 0;
  const lerpSpeed = 1;

  // 先停止之前的语音
  let VocalControl: any = document.getElementById('currentVocal');
  WebGAL.gameplay.performController.unmountPerform('vocal-play', true);
  if (VocalControl !== null) {
    VocalControl.currentTime = 0;
    VocalControl.pause();
  }

  // 获得舞台状态
  webgalStore.dispatch(setStage({ key: 'playVocal', value: url }));
  webgalStore.dispatch(setStage({ key: 'vocal', value: url }));

  let isOver = false;

  /**
   * 嘴型同步
   */

  return {
    arrangePerformPromise: new Promise((resolve) => {
      // 播放语音
      setTimeout(() => {
        let VocalControl: any = document.getElementById('currentVocal');
        // 设置语音音量
        webgalStore.dispatch(setStage({ key: 'vocalVolume', value: volume }));
        // 设置语音
        if (VocalControl !== null) {
          VocalControl.currentTime = 0;
          // 播放并作为一个特别演出加入
          const perform = {
            performName: performInitName,
            duration: 1000 * 60 * 60,
            isOver: false,
            isHoldOn: false,
            stopFunction: () => {
              clearInterval(audioContextWrapper.audioLevelInterval);
              VocalControl.pause();
              key = key ? key : `fig-${pos}`;
              const animationItem = figureAssociatedAnimation.find((tid) => tid.targetId === key);
              performMouthAnimation({
                audioLevel: 0,
                OPEN_THRESHOLD: 1,
                HALF_OPEN_THRESHOLD: 1,
                currentMouthValue,
                lerpSpeed,
                key,
                animationItem,
                pos,
              });
              clearTimeout(audioContextWrapper.blinkTimerID);
            },
            blockingNext: () => false,
            blockingAuto: () => {
              return !isOver;
            },
            skipNextCollect: true,
            stopTimeout: undefined, // 暂时不用，后面会交给自动清除
          };
          WebGAL.gameplay.performController.arrangeNewPerform(perform, sentence, false);
          key = key ? key : `fig-${pos}`;
          const animationItem = figureAssociatedAnimation.find((tid) => tid.targetId === key);
          if (animationItem) {
            let maxAudioLevel = 0;

            const foundFigure = freeFigure.find((figure) => figure.key === key);

            if (foundFigure) {
              pos = foundFigure.basePosition;
            }

            if (!audioContextWrapper.audioContext) {
              let audioContext: AudioContext | null;
              audioContext = new AudioContext();
              audioContextWrapper.analyser = audioContext.createAnalyser();
              audioContextWrapper.analyser.fftSize = 256;
              audioContextWrapper.dataArray = new Uint8Array(audioContextWrapper.analyser.frequencyBinCount);
            }

            if (!audioContextWrapper.analyser) {
              audioContextWrapper.analyser = audioContextWrapper.audioContext.createAnalyser();
              audioContextWrapper.analyser.fftSize = 256;
            }

            bufferLength = audioContextWrapper.analyser.frequencyBinCount;
            audioContextWrapper.dataArray = new Uint8Array(bufferLength);
            let vocalControl = document.getElementById('currentVocal') as HTMLMediaElement;

            if (!audioContextWrapper.source) {
              audioContextWrapper.source = audioContextWrapper.audioContext.createMediaElementSource(vocalControl);
              audioContextWrapper.source.connect(audioContextWrapper.analyser);
            }

            audioContextWrapper.analyser.connect(audioContextWrapper.audioContext.destination);

            // Lip-snc Animation
            audioContextWrapper.audioLevelInterval = setInterval(() => {
              const audioLevel = getAudioLevel(
                audioContextWrapper.analyser!,
                audioContextWrapper.dataArray!,
                bufferLength,
              );
              const { OPEN_THRESHOLD, HALF_OPEN_THRESHOLD } = updateThresholds(audioLevel);

              performMouthAnimation({
                audioLevel,
                OPEN_THRESHOLD,
                HALF_OPEN_THRESHOLD,
                currentMouthValue,
                lerpSpeed,
                key,
                animationItem,
                pos,
              });
            }, 50);

            // blinkAnimation
            let animationEndTime: number;

            // 10sec
            animationEndTime = Date.now() + 10000;
            performBlinkAnimation({ key, animationItem, pos, animationEndTime });

            // 10sec
            setTimeout(() => {
              clearTimeout(audioContextWrapper.blinkTimerID);
            }, 10000);
          }

          VocalControl?.play();

          VocalControl.onended = () => {
            for (const e of WebGAL.gameplay.performController.performList) {
              if (e.performName === performInitName) {
                isOver = true;
                e.stopFunction();
                WebGAL.gameplay.performController.unmountPerform(e.performName);
              }
            }
          };
        }
      }, 1);
    }),
  };
};



================================================
FILE: webgal/src/Core/gameScripts/vocal/vocalAnimation.ts
================================================
import { WebGAL } from '@/Core/WebGAL';

interface IAudioContextWrapper {
  audioContext: AudioContext;
  source: MediaElementAudioSourceNode | null;
  analyser: AnalyserNode | undefined;
  dataArray: Uint8Array | undefined;
  audioLevelInterval: ReturnType<typeof setInterval>;
  blinkTimerID: ReturnType<typeof setTimeout>;
  maxAudioLevel: number;
}

// Initialize the object based on the interface
export const audioContextWrapper: IAudioContextWrapper = {
  audioContext: new AudioContext(),
  source: null,
  analyser: undefined,
  dataArray: undefined,
  audioLevelInterval: setInterval(() => {}, 0), // dummy interval
  blinkTimerID: setTimeout(() => {}, 0), // dummy timeout
  maxAudioLevel: 0,
};

export const updateThresholds = (audioLevel: number) => {
  audioContextWrapper.maxAudioLevel = Math.max(audioLevel, audioContextWrapper.maxAudioLevel);
  return {
    OPEN_THRESHOLD: audioContextWrapper.maxAudioLevel * 0.75,
    HALF_OPEN_THRESHOLD: audioContextWrapper.maxAudioLevel * 0.5,
  };
};

export const performBlinkAnimation = (params: {
  key: string;
  animationItem: any;
  pos: string;
  animationEndTime: number;
}) => {
  let isBlinking = false;

  function blink() {
    if (isBlinking || (params.animationEndTime && Date.now() > params.animationEndTime)) return;
    isBlinking = true;
    WebGAL.gameplay.pixiStage?.performBlinkAnimation(params.key, params.animationItem, 'closed', params.pos);
    audioContextWrapper.blinkTimerID = setTimeout(() => {
      WebGAL.gameplay.pixiStage?.performBlinkAnimation(params.key, params.animationItem, 'open', params.pos);
      isBlinking = false;
      const nextBlinkTime = Math.random() * 300 + 3500;
      audioContextWrapper.blinkTimerID = setTimeout(blink, nextBlinkTime);
    }, 200);
  }
  blink();
};

// Updated getAudioLevel function
export const getAudioLevel = (analyser: AnalyserNode, dataArray: Uint8Array, bufferLength: number): number => {
  analyser.getByteFrequencyData(dataArray);
  let sum = 0;
  for (let i = 0; i < bufferLength; i++) {
    sum += dataArray[i];
  }
  return sum / bufferLength;
};

export const performMouthAnimation = (params: {
  audioLevel: number;
  OPEN_THRESHOLD: number;
  HALF_OPEN_THRESHOLD: number;
  currentMouthValue: number;
  lerpSpeed: number;
  key: string;
  animationItem: any;
  pos: string;
}) => {
  const { audioLevel, OPEN_THRESHOLD, HALF_OPEN_THRESHOLD, currentMouthValue, lerpSpeed, key, animationItem, pos } =
    params;

  let targetValue;
  if (audioLevel > OPEN_THRESHOLD) {
    targetValue = 1; // open
  } else if (audioLevel > HALF_OPEN_THRESHOLD) {
    targetValue = 0.5; // half_open
  } else {
    targetValue = 0; // closed
  }
  // Lerp
  const mouthValue = currentMouthValue + (targetValue - currentMouthValue) * lerpSpeed;
  WebGAL.gameplay.pixiStage?.setModelMouthY(key, audioLevel);

  let mouthState;
  if (mouthValue > 0.75) {
    mouthState = 'open';
  } else if (mouthValue > 0.25) {
    mouthState = 'half_open';
  } else {
    mouthState = 'closed';
  }
  if (animationItem !== undefined) {
    WebGAL.gameplay.pixiStage?.performMouthSyncAnimation(key, animationItem, mouthState, pos);
  }
};



================================================
FILE: webgal/src/Core/Modules/animationFunctions.ts
================================================
import { generateUniversalSoftInAnimationObj } from '@/Core/controller/stage/pixi/animations/universalSoftIn';
import { logger } from '@/Core/util/logger';
import { generateUniversalSoftOffAnimationObj } from '@/Core/controller/stage/pixi/animations/universalSoftOff';
import { webgalStore } from '@/store/store';
import cloneDeep from 'lodash/cloneDeep';
import { baseTransform } from '@/store/stageInterface';
import { generateTimelineObj } from '@/Core/controller/stage/pixi/animations/timeline';
import { WebGAL } from '@/Core/WebGAL';
import PixiStage, { IAnimationObject } from '@/Core/controller/stage/pixi/PixiController';
import { DEFALUT_FIG_IN_DURATION, DEFALUT_FIG_OUT_DURATION } from '../constants';

// eslint-disable-next-line max-params
export function getAnimationObject(animationName: string, target: string, duration: number, writeDefault: boolean) {
  const effect = WebGAL.animationManager.getAnimations().find((ani) => ani.name === animationName);
  if (effect) {
    const mappedEffects = effect.effects.map((effect) => {
      const targetSetEffect = webgalStore.getState().stage.effects.find((e) => e.target === target);
      let newEffect;

      if (!writeDefault && targetSetEffect && targetSetEffect.transform) {
        newEffect = cloneDeep({ ...targetSetEffect.transform, duration: 0, ease: '' });
      } else {
        newEffect = cloneDeep({ ...baseTransform, duration: 0, ease: '' });
      }

      PixiStage.assignTransform(newEffect, effect);
      newEffect.duration = effect.duration;
      newEffect.ease = effect.ease;
      return newEffect;
    });
    logger.debug('装载自定义动画', mappedEffects);
    return generateTimelineObj(mappedEffects, target, duration);
  }
  return null;
}

export function getAnimateDuration(animationName: string) {
  const effect = WebGAL.animationManager.getAnimations().find((ani) => ani.name === animationName);
  if (effect) {
    let duration = 0;
    effect.effects.forEach((e) => {
      duration += e.duration;
    });
    return duration;
  }
  return 0;
}

// eslint-disable-next-line max-params
export function getEnterExitAnimation(
  target: string,
  type: 'enter' | 'exit',
  isBg = false,
  realTarget?: string, // 用于立绘和背景移除时，以当前时间打上特殊标记
): {
  duration: number;
  animation: IAnimationObject | null;
} {
  if (type === 'enter') {
    let duration = DEFALUT_FIG_IN_DURATION;
    if (isBg) {
      duration = 1500;
    }
    // 走默认动画
    let animation: IAnimationObject | null = generateUniversalSoftInAnimationObj(realTarget ?? target, duration);

    const transformState = webgalStore.getState().stage.effects;
    const targetEffect = transformState.find((effect) => effect.target === target);

    const animarionName = WebGAL.animationManager.nextEnterAnimationName.get(target);
    if (animarionName && !targetEffect) {
      logger.debug('取代默认进入动画', target);
      animation = getAnimationObject(animarionName, realTarget ?? target, getAnimateDuration(animarionName), false);
      duration = getAnimateDuration(animarionName);
      // 用后重置
      WebGAL.animationManager.nextEnterAnimationName.delete(target);
    }
    return { duration, animation };
  } else {
    // exit
    let duration = DEFALUT_FIG_OUT_DURATION;
    if (isBg) {
      duration = 1500;
    }
    // 走默认动画
    let animation: IAnimationObject | null = generateUniversalSoftOffAnimationObj(realTarget ?? target, duration);
    const animarionName = WebGAL.animationManager.nextExitAnimationName.get(target);
    if (animarionName) {
      logger.debug('取代默认退出动画', target);
      animation = getAnimationObject(animarionName, realTarget ?? target, getAnimateDuration(animarionName), false);
      duration = getAnimateDuration(animarionName);
      // 用后重置
      WebGAL.animationManager.nextExitAnimationName.delete(target);
    }
    return { duration, animation };
  }
}



================================================
FILE: webgal/src/Core/Modules/animations.ts
================================================
import { ITransform } from '@/store/stageInterface';

export interface IUserAnimation {
  name: string;
  effects: Array<AnimationFrame>;
}

export type AnimationFrame = ITransform & { duration: number; ease: string };

export class AnimationManager {
  public nextEnterAnimationName: Map<string, string> = new Map();
  public nextExitAnimationName: Map<string, string> = new Map();
  private animations: Array<IUserAnimation> = [];

  public addAnimation(animation: IUserAnimation) {
    this.animations.push(animation);
  }
  public getAnimations() {
    return this.animations;
  }
}



================================================
FILE: webgal/src/Core/Modules/backlog.ts
================================================
/**
 * 当前的backlog
 */
import { IEffect, IStageState } from '@/store/stageInterface';
import { webgalStore } from '@/store/store';
import { ISaveScene } from '@/store/userDataInterface';
import cloneDeep from 'lodash/cloneDeep';

import { SYSTEM_CONFIG } from '@/config';
import { SceneManager } from '@/Core/Modules/scene';

export interface IBacklogItem {
  currentStageState: IStageState;
  saveScene: ISaveScene;
}

export class BacklogManager {
  public isSaveBacklogNext = false;
  private backlog: Array<IBacklogItem> = [];

  private readonly sceneManager: SceneManager;

  public constructor(sceneManager: SceneManager) {
    this.sceneManager = sceneManager;
  }

  public getBacklog() {
    return this.backlog;
  }

  public editLastBacklogItemEffect(effects: IEffect[]) {
    this.backlog[this.backlog.length - 1].currentStageState.effects = effects;
  }

  public makeBacklogEmpty() {
    this.backlog.splice(0, this.backlog.length); // 清空backlog
  }
  public insertBacklogItem(item: IBacklogItem) {
    this.backlog.push(item);
  }
  public saveCurrentStateToBacklog() {
    // 存一下 Backlog
    const currentStageState = webgalStore.getState().stage;
    const stageStateToBacklog = cloneDeep(currentStageState);
    stageStateToBacklog.PerformList.forEach((ele) => {
      ele.script.args.forEach((argelement) => {
        if (argelement.key === 'concat') {
          argelement.value = false;
          ele.script.content = stageStateToBacklog.showText;
        }
      });
    });
    const backlogElement: IBacklogItem = {
      currentStageState: stageStateToBacklog,
      saveScene: {
        currentSentenceId: this.sceneManager.sceneData.currentSentenceId, // 当前语句ID
        sceneStack: cloneDeep(this.sceneManager.sceneData.sceneStack), // 场景栈
        sceneName: this.sceneManager.sceneData.currentScene.sceneName, // 场景名称
        sceneUrl: this.sceneManager.sceneData.currentScene.sceneUrl, // 场景url
      },
    };
    this.getBacklog().push(backlogElement);

    // 清除超出长度的部分
    while (this.getBacklog().length > SYSTEM_CONFIG.backlog_size) {
      this.getBacklog().shift();
    }
  }
}



================================================
FILE: webgal/src/Core/Modules/events.ts
================================================
import mitt from 'mitt';

interface IWebgalEvent<T> {
  on: (callback: (message?: T) => void, id?: string) => void;
  off: (callback: (message?: T) => void, id?: string) => void;
  emit: (message?: T, id?: string) => void;
}

export class Events {
  public textSettle = formEvent('text-settle');
  public userInteractNext = formEvent('__NEXT');
  public fullscreenDbClick = formEvent('fullscreen-dbclick');
  public styleUpdate = formEvent('style-update');
}

const eventBus = mitt();

function formEvent<T>(eventName: string): IWebgalEvent<T> {
  return {
    on: (callback, id?) => {
      // @ts-ignore
      eventBus.on(`${eventName}-${id ?? ''}`, callback);
    },
    emit: (message?, id?) => {
      eventBus.emit(`${eventName}-${id ?? ''}`, message);
    },
    off: (callback, id?) => {
      // @ts-ignore
      eventBus.off(`${eventName}-${id ?? ''}`, callback);
    },
  };
}



================================================
FILE: webgal/src/Core/Modules/gamePlay.ts
================================================
import PixiStage from '@/Core/controller/stage/pixi/PixiController';
import { PerformController } from '@/Core/Modules/perform/performController';

/**
 * 游戏运行时变量
 */
export class Gameplay {
  public isAuto = false;
  public isFast = false;
  public autoInterval: ReturnType<typeof setInterval> | null = null;
  public fastInterval: ReturnType<typeof setInterval> | null = null;
  public autoTimeout: ReturnType<typeof setTimeout> | null = null;
  public pixiStage: PixiStage | null = null;
  public performController = new PerformController();
  public resetGamePlay() {
    this.isAuto = false;
    this.isFast = false;
    const autoInterval = this.autoInterval;
    if (autoInterval !== null) clearInterval(autoInterval);
    this.autoInterval = null;
    const fastInterval = this.fastInterval;
    if (fastInterval !== null) clearInterval(fastInterval);
    this.fastInterval = null;
    const autoTimeout = this.autoTimeout;
    if (autoTimeout !== null) clearInterval(autoTimeout);
    this.autoTimeout = null;
  }
}



================================================
FILE: webgal/src/Core/Modules/scene.ts
================================================
import { ISceneData } from '@/Core/controller/scene/sceneInterface';
import cloneDeep from 'lodash/cloneDeep';

export interface ISceneEntry {
  sceneName: string; // 场景名称
  sceneUrl: string; // 场景url
  continueLine: number; // 继续原场景的行号
}

/**
 * 初始化场景数据
 */
export const initSceneData = {
  currentSentenceId: 0, // 当前语句ID
  sceneStack: [],
  // 初始场景，没有数据
  currentScene: {
    sceneName: '', // 场景名称
    sceneUrl: '', // 场景url
    sentenceList: [], // 语句列表
    assetsList: [], // 资源列表
    subSceneList: [], // 子场景列表
  },
};

export class SceneManager {
  public settledScenes: Array<string> = [];
  public settledAssets: Array<string> = [];
  public sceneData: ISceneData = cloneDeep(initSceneData);
  public lockSceneWrite = false;

  public resetScene() {
    this.sceneData.currentSentenceId = 0;
    this.sceneData.sceneStack = [];
    this.sceneData.currentScene = cloneDeep(initSceneData.currentScene);
  }
}



================================================
FILE: webgal/src/Core/Modules/perform/performController.ts
================================================
import { IPerform } from '@/Core/Modules/perform/performInterface';
import { ISentence } from '@/Core/controller/scene/sceneInterface';
import { webgalStore } from '@/store/store';
import cloneDeep from 'lodash/cloneDeep';
import { resetStageState, stageActions } from '@/store/stageReducer';
import { nextSentence } from '@/Core/controller/gamePlay/nextSentence';
import { IRunPerform } from '@/store/stageInterface';
import { WEBGAL_NONE } from '@/Core/constants';
import { getBooleanArgByKey } from '@/Core/util/getSentenceArg';

/**
 * 获取随机演出名称
 */
export const getRandomPerformName = (): string => {
  return Math.random().toString().substring(0, 10);
};

export class PerformController {
  public performList: Array<IPerform> = [];

  public arrangeNewPerform(perform: IPerform, script: ISentence, syncPerformState = true) {
    // 检查演出列表内是否有相同的演出，如果有，一定是出了什么问题
    const dupPerformIndex = this.performList.findIndex((p) => p.performName === perform.performName);
    if (dupPerformIndex > -1) {
      // 结束并删除全部重复演出
      for (let i = 0; i < this.performList.length; i++) {
        const e = this.performList[i];
        if (e.performName === perform.performName) {
          e.stopFunction();
          clearTimeout(e.stopTimeout as unknown as number);
          this.performList.splice(i, 1);
          i--;
        }
      }
    }

    // 语句不执行演出
    if (perform.performName === WEBGAL_NONE) {
      return;
    }
    // 同步演出状态
    if (syncPerformState) {
      const performToAdd = { id: perform.performName, isHoldOn: perform.isHoldOn, script: script };
      webgalStore.dispatch(stageActions.addPerform(performToAdd));
    }

    // 时间到后自动清理演出
    perform.stopTimeout = setTimeout(() => {
      // perform.stopFunction();
      // perform.isOver = true;
      if (!perform.isHoldOn) {
        // 如果不是保持演出，清除
        this.unmountPerform(perform.performName);
      }
    }, perform.duration);

    const hasContinue = getBooleanArgByKey(script, 'continue') ?? false;
    if (hasContinue) perform.goNextWhenOver = true;

    this.performList.push(perform);
  }

  public unmountPerform(name: string, force = false) {
    if (!force) {
      for (let i = 0; i < this.performList.length; i++) {
        const e = this.performList[i];
        if (!e.isHoldOn && e.performName === name) {
          e.stopFunction();
          clearTimeout(e.stopTimeout as unknown as number);
          /**
           * 在演出列表里删除演出对象的操作必须在调用 goNextWhenOver 之前
           * 因为 goNextWhenOver 会调用 nextSentence，而 nextSentence 会清除目前未结束的演出
           * 那么 nextSentence 函数就会删除这个演出，但是此时，在这个上下文，i 已经被确定了
           * 所以 goNextWhenOver 后的代码会多删东西，解决方法就是在调用 goNextWhenOver 前先删掉这个演出对象
           * 此问题对所有 goNextWhenOver 属性为真的演出都有影响，但只有 2 个演出有此问题
           */
          this.performList.splice(i, 1);
          i--;
          if (e.goNextWhenOver) {
            // nextSentence();
            this.goNextWhenOver();
          }
        }
      }
    } else {
      for (let i = 0; i < this.performList.length; i++) {
        const e = this.performList[i];
        if (e.performName === name) {
          e.stopFunction();
          clearTimeout(e.stopTimeout as unknown as number);
          if (e.goNextWhenOver) {
            // nextSentence();
            this.goNextWhenOver();
          }
          this.performList.splice(i, 1);
          i--;
          /**
           * 从状态表里清除演出
           */
          this.erasePerformFromState(name);
        }
      }
    }
  }

  public erasePerformFromState(name: string) {
    webgalStore.dispatch(stageActions.removePerformByName(name));
  }

  public removeAllPerform() {
    for (const e of this.performList) {
      clearTimeout(e.stopTimeout);
      e.stopFunction();
    }
    this.performList = [];
  }

  private goNextWhenOver() {
    let isBlockingAuto = false;
    this.performList?.forEach((e) => {
      if (e.blockingAuto())
        // 阻塞且没有结束的演出
        isBlockingAuto = true;
    });
    if (isBlockingAuto) {
      // 有阻塞，提前结束
      setTimeout(this.goNextWhenOver, 100);
    } else {
      nextSentence();
    }
  }
}



================================================
FILE: webgal/src/Core/Modules/perform/performInterface.ts
================================================
/**
 * 描述演出的接口，主要用于控制演出，而不是执行（在演出开始时被调用演出的执行器返回）
 * @interface IPerform
 */
export interface IPerform {
  // 演出名称，用于在后面手动清除演出，如果没有标识，则代表不是保持演出，给予一个随机字符串
  performName: string;
  // 持续时间，单位为ms，持续时间到后自动回收演出
  duration: number;
  // 演出是不是一个保持类型的演出
  isHoldOn: boolean;
  // 卸载演出的函数
  stopFunction: () => void;
  // 演出是否阻塞游戏流程继续（一个函数，返回 boolean类型的结果，判断要不要阻塞）
  blockingNext: () => boolean;
  // 演出是否阻塞自动模式（一个函数，返回 boolean类型的结果，判断要不要阻塞）
  blockingAuto: () => boolean;
  // 自动回收使用的 Timeout
  stopTimeout: undefined | ReturnType<typeof setTimeout>;
  // 演出结束后转到下一句
  goNextWhenOver?: boolean;
  // 对于延迟触发的演出，使用 Promise
  arrangePerformPromise?: Promise<IPerform>;
  // 跳过由 nextSentence 函数引发的演出回收
  skipNextCollect?: boolean;
}

// next之后，可以被打断的演出会被打断，不能被打断的演出会继续，阻塞next的演出会阻止next被响应。
// 被打断或执行完毕的演出会移出演出列表
// 只有所有演出都完成，或者仅存在不阻塞auto的演出，才允许auto

/**
 * 初始化的演出
 */
export const initPerform: IPerform = {
  performName: '',
  duration: 100,
  // isOver: false,
  isHoldOn: false,
  stopFunction: () => {},
  blockingNext: () => false,
  blockingAuto: () => true,
  stopTimeout: undefined,
};



================================================
FILE: webgal/src/Core/parser/sceneParser.ts
================================================
import { assetSetter } from '@/Core/util/gameAssetsAccess/assetSetter';
import { assetsPrefetcher } from '@/Core/util/prefetcher/assetsPrefetcher';
import SceneParser from 'webgal-parser';
import { commandType, IScene } from '../controller/scene/sceneInterface';
import { logger } from '../util/logger';
import { bgm } from '@/Core/gameScripts/bgm';
import { callSceneScript } from '@/Core/gameScripts/callSceneScript';
import { changeBg } from '@/Core/gameScripts/changeBg';
import { changeFigure } from '@/Core/gameScripts/changeFigure';
import { changeSceneScript } from '@/Core/gameScripts/changeSceneScript';
import { choose } from '@/Core/gameScripts/choose';
import { comment } from '@/Core/gameScripts/comment';
import { filmMode } from '@/Core/gameScripts/filmMode';
import { getUserInput } from '@/Core/gameScripts/getUserInput';
import { intro } from '@/Core/gameScripts/intro';
import { label } from '@/Core/gameScripts/label';
import { miniAvatar } from '@/Core/gameScripts/miniAvatar';
import { pixi } from '@/Core/gameScripts/pixi';
import { playEffect } from '@/Core/gameScripts/playEffect';
import { playVideo } from '@/Core/gameScripts/playVideo';
import { setAnimation } from '@/Core/gameScripts/setAnimation';
import { setComplexAnimation } from '@/Core/gameScripts/setComplexAnimation';
import { setFilter } from '@/Core/gameScripts/setFilter';
import { setTempAnimation } from '@/Core/gameScripts/setTempAnimation';
import { setTextbox } from '@/Core/gameScripts/setTextbox';
import { setTransform } from '@/Core/gameScripts/setTransform';
import { setTransition } from '@/Core/gameScripts/setTransition';
import { unlockBgm } from '@/Core/gameScripts/unlockBgm';
import { unlockCg } from '@/Core/gameScripts/unlockCg';
import { end } from '../gameScripts/end';
import { jumpLabel } from '../gameScripts/jumpLabel';
import { pixiInit } from '../gameScripts/pixi/pixiInit';
import { say } from '../gameScripts/say';
import { setVar } from '../gameScripts/setVar';
import { showVars } from '../gameScripts/showVars';
import { defineScripts, IConfigInterface, ScriptConfig, ScriptFunction, scriptRegistry } from './utils';
import { applyStyle } from '@/Core/gameScripts/applyStyle';
import { wait } from '@/Core/gameScripts/wait';

export const SCRIPT_TAG_MAP = defineScripts({
  say: ScriptConfig(commandType.say, say),
  changeBg: ScriptConfig(commandType.changeBg, changeBg),
  changeFigure: ScriptConfig(commandType.changeFigure, changeFigure),
  bgm: ScriptConfig(commandType.bgm, bgm, { next: true }),
  playVideo: ScriptConfig(commandType.video, playVideo),
  pixiPerform: ScriptConfig(commandType.pixi, pixi, { next: true }),
  pixiInit: ScriptConfig(commandType.pixiInit, pixiInit, { next: true }),
  intro: ScriptConfig(commandType.intro, intro),
  miniAvatar: ScriptConfig(commandType.miniAvatar, miniAvatar, { next: true }),
  changeScene: ScriptConfig(commandType.changeScene, changeSceneScript),
  choose: ScriptConfig(commandType.choose, choose),
  end: ScriptConfig(commandType.end, end),
  setComplexAnimation: ScriptConfig(commandType.setComplexAnimation, setComplexAnimation),
  setFilter: ScriptConfig(commandType.setFilter, setFilter),
  label: ScriptConfig(commandType.label, label, { next: true }),
  jumpLabel: ScriptConfig(commandType.jumpLabel, jumpLabel),
  // chooseLabel: ScriptConfig(commandType.chooseLabel, undefined),
  setVar: ScriptConfig(commandType.setVar, setVar, { next: true }),
  // if: ScriptConfig(commandType.if, undefined, { next: true }),
  callScene: ScriptConfig(commandType.callScene, callSceneScript),
  showVars: ScriptConfig(commandType.showVars, showVars),
  unlockCg: ScriptConfig(commandType.unlockCg, unlockCg, { next: true }),
  unlockBgm: ScriptConfig(commandType.unlockBgm, unlockBgm, { next: true }),
  filmMode: ScriptConfig(commandType.filmMode, filmMode, { next: true }),
  setTextbox: ScriptConfig(commandType.setTextbox, setTextbox),
  setAnimation: ScriptConfig(commandType.setAnimation, setAnimation),
  playEffect: ScriptConfig(commandType.playEffect, playEffect, { next: true }),
  setTempAnimation: ScriptConfig(commandType.setTempAnimation, setTempAnimation),
  __commment: ScriptConfig(commandType.comment, comment, { next: true }),
  setTransform: ScriptConfig(commandType.setTransform, setTransform),
  setTransition: ScriptConfig(commandType.setTransition, setTransition, { next: true }),
  getUserInput: ScriptConfig(commandType.getUserInput, getUserInput),
  applyStyle: ScriptConfig(commandType.applyStyle, applyStyle, { next: true }),
  wait: ScriptConfig(commandType.wait, wait),
});

export const SCRIPT_CONFIG: IConfigInterface[] = Object.values(SCRIPT_TAG_MAP);

export const ADD_NEXT_ARG_LIST = SCRIPT_CONFIG.filter((config) => config.next).map((config) => config.scriptType);

/**
 * 场景解析器
 * @param rawScene 原始场景
 * @param sceneName 场景名称
 * @param sceneUrl 场景url
 * @return {IScene} 解析后的场景
 */
export const WebgalParser = new SceneParser(assetsPrefetcher, assetSetter, ADD_NEXT_ARG_LIST, SCRIPT_CONFIG);

export const sceneParser = (rawScene: string, sceneName: string, sceneUrl: string): IScene => {
  const parsedScene = WebgalParser.parse(rawScene, sceneName, sceneUrl);
  logger.info(`解析场景：${sceneName}，数据为：`, parsedScene);
  return parsedScene;
};

export { scriptRegistry, type ScriptFunction };



================================================
FILE: webgal/src/Core/parser/utils.ts
================================================
import { commandType, ISentence } from '@/Core/controller/scene/sceneInterface';
import { IPerform } from '@/Core/Modules/perform/performInterface';

/**
 * 规范函数的类型
 * @type {(sentence: ISentence) => IPerform}
 */
export type ScriptFunction = (sentence: ISentence) => IPerform;

export interface ScriptConfig {
  scriptType: commandType;
  scriptFunction: ScriptFunction;
  next?: boolean;
}

export interface IConfigInterface extends ScriptConfig {
  scriptString: string;
}

export function ScriptConfig(
  scriptType: commandType,
  scriptFunction: ScriptFunction,
  config?: Omit<ScriptConfig, 'scriptType' | 'scriptFunction'>,
): ScriptConfig {
  return { scriptType, scriptFunction, ...config };
}

export const scriptRegistry: Record<commandType, IConfigInterface> = {} as any;

export function defineScripts<R extends Record<string, Omit<IConfigInterface, 'scriptString'>>>(
  record: R,
): {
  [K in keyof R]: IConfigInterface;
} {
  // eslint-disable-next-line
  const result = {} as Record<keyof R, IConfigInterface>;
  for (const [scriptString, config] of Object.entries(record)) {
    result[scriptString as keyof R] = scriptRegistry[config.scriptType] = { scriptString, ...config };
  }
  return result;
}



================================================
FILE: webgal/src/Core/util/constants.scss
================================================
$screenWidth: 2560px;
$screenHeight: 1440px;



================================================
FILE: webgal/src/Core/util/constants.ts
================================================
export const SCREEN_CONSTANTS = {
  height: 1440,
  width: 2560,
};



================================================
FILE: webgal/src/Core/util/getSentenceArg.ts
================================================
import { ISentence } from '@/Core/controller/scene/sceneInterface';
import { toSafeBoolean, toSafeNumber, toSafeString } from './toSafeType';

export function getSentenceArgByKey(sentence: ISentence, argKey: string): null | string | boolean | number {
  const args = sentence.args;
  const result = args.find((arg) => arg.key === argKey);
  if (result) {
    return result.value;
  } else return null;
}

export function getBooleanArgByKey(sentence: ISentence, argKey: string): boolean | null {
  const argValue = getSentenceArgByKey(sentence, argKey);
  return toSafeBoolean(argValue);
}

export function getNumberArgByKey(sentence: ISentence, argKey: string): number | null {
  const argValue = getSentenceArgByKey(sentence, argKey);
  return toSafeNumber(argValue);
}

export function getStringArgByKey(sentence: ISentence, argKey: string): string | null {
  const argValue = getSentenceArgByKey(sentence, argKey);
  return toSafeString(argValue);
}



================================================
FILE: webgal/src/Core/util/logger.ts
================================================
import Cloudlog from 'cloudlogjs';

/**
 * 日志打印工具
 */
export const logger = new Cloudlog();
if (process.env.NODE_ENV === 'production') {
  logger.setLevel('INFO');
}



================================================
FILE: webgal/src/Core/util/match.ts
================================================
class Matcher<T, R = any> {
  private subject: T;
  private result: R | undefined;
  private isEnd = false;

  public constructor(subject: T) {
    this.subject = subject;
  }

  public with(pattern: T, fn: () => R): this {
    if (!this.isEnd && this.subject === pattern) {
      this.result = fn();
      this.isEnd = true;
    }
    return this;
  }

  public endsWith(pattern: T, fn: () => R) {
    if (!this.isEnd && this.subject === pattern) {
      this.result = fn();
      this.isEnd = true;
    }
    return this.evaluate();
  }

  public default(fn: () => R) {
    if (!this.isEnd) this.result = fn();
    return this.evaluate();
  }

  private evaluate(): R | undefined {
    return this.result;
  }
}

export function match<T, R = any>(subject: T): Matcher<T, R> {
  return new Matcher(subject);
}



================================================
FILE: webgal/src/Core/util/toSafeType.ts
================================================
export function toSafeBoolean(value: null | string | boolean | number): boolean | null {
  if (typeof value === 'boolean') return value;
  if (typeof value === 'string') {
    const lower = value.trim().toLowerCase();
    if (lower === 'true') return true;
    if (lower === 'false') return false;
  }
  if (typeof value === 'number') return value !== 0;
  return null;
}

export function toSafeNumber(value: null | string | boolean | number): number | null {
  if (typeof value === 'number') return value;
  if (typeof value === 'boolean') return value ? 1 : 0;
  if (typeof value === 'string') {
    const num = Number(value.trim());
    return isNaN(num) ? null : num;
  }
  return null;
}

export function toSafeString(value: null | string | boolean | number): string | null {
  if (typeof value === 'string') return value;
  if (typeof value === 'boolean' || typeof value === 'number') {
    return String(value);
  }
  return null;
}



================================================
FILE: webgal/src/Core/util/coreInitialFunction/bindExtraFunc.ts
================================================
import { syncFast } from '@/Core/util/syncWithEditor/syncWithOrigine';

export const bindExtraFunc = () => {
  (window as any).JMP = syncFast;
};



================================================
FILE: webgal/src/Core/util/coreInitialFunction/infoFetcher.ts
================================================
import { webgalStore } from '@/store/store';
import { setGlobalVar } from '@/store/userDataReducer';
import { setEnableAppreciationMode } from '@/store/GUIReducer';
import { Live2D, WebGAL } from '@/Core/WebGAL';
import { WebgalParser } from '@/Core/parser/sceneParser';
import { getStorageAsync, setStorage } from '@/Core/controller/storage/storageController';
import { initKey } from '@/Core/controller/storage/fastSaveLoad';
import { getFastSaveFromStorage, getSavesFromStorage } from '@/Core/controller/storage/savesController';
import { logger } from '@/Core/util/logger';
import axios from 'axios';

/**
 * 获取游戏信息
 * @param url 游戏信息路径
 */
export const infoFetcher = (url: string) => {
  const dispatch = webgalStore.dispatch;
  axios.get(url).then(async (r) => {
    let gameConfigRaw: string = r.data;
    let gameConfig = WebgalParser.parseConfig(gameConfigRaw);
    logger.info('获取到游戏信息', gameConfig);
    // 先把 key 找到并设置了
    const keyItem = gameConfig.find((e) => e.command === 'Game_key');
    WebGAL.gameKey = (keyItem?.args?.[0] as string) ?? '';
    initKey();
    await getStorageAsync();
    getFastSaveFromStorage();
    getSavesFromStorage(0, 0);
    // 按照游戏的配置开始设置对应的状态
    gameConfig.forEach((e) => {
      const { command, args } = e;
      if (args.length > 0) {
        if (args.length > 1) {
          dispatch(
            setGlobalVar({
              key: command,
              value: args.join('|'),
            }),
          );
        } else {
          let res: any = args[0].trim();
          if (/^(true|false)$/g.test(args[0])) {
            res = res === 'true';
          } else if (/^[0-9]+\.?[0-9]+$/g.test(args[0])) {
            res = Number(res);
          }

          dispatch(
            setGlobalVar({
              key: command,
              value: res,
            }),
          );

          if (command === 'Enable_Appreciation') {
            dispatch(setEnableAppreciationMode(res));
          }
          if (command === 'Legacy_Expression_Blend_Mode') {
            Live2D.legacyExpressionBlendMode = res === true;
          }
        }
      }
    });
    // @ts-expect-error renderPromiseResolve is a global variable
    window.renderPromiseResolve();
    setStorage();
  });
};



================================================
FILE: webgal/src/Core/util/gameAssetsAccess/assetSetter.ts
================================================
import { getGameAssetPath } from '@/Core/gameState';

/**
 * @file 资源的引入可能是绝对链接，也可能是文件名，必须做必要的处理。
 */

/**
 * 内置资源类型的枚举
 */
export enum fileType {
  background,
  bgm,
  figure,
  scene,
  tex,
  vocal,
  video,
}

/**
 * 获取资源路径
 * @param fileName 资源的名称或地址
 * @param assetType 资源类型
 * @return {string} 处理后的资源路径（绝对或相对）
 */
export const assetSetter = (fileName: string, assetType: fileType): string => {
  // 是绝对链接，直接返回
  if (fileName.match('http://') || fileName.match('https://')) {
    return fileName;
  }

  switch (assetType) {
    case fileType.background:
      return getGameAssetPath(`background/${fileName}`);
    case fileType.scene:
      return getGameAssetPath(`scene/${fileName}`);
    case fileType.vocal:
      return getGameAssetPath(`vocal/${fileName}`);
    case fileType.figure:
      return getGameAssetPath(`figure/${fileName}`);
    case fileType.bgm:
      return getGameAssetPath(`bgm/${fileName}`);
    case fileType.video:
      return getGameAssetPath(`video/${fileName}`);
    case fileType.tex:
      return getGameAssetPath(`tex/${fileName}`);
    default:
      return getGameAssetPath(fileName);
  }
};



================================================
FILE: webgal/src/Core/util/pixiPerformManager/initRegister.ts
================================================
import '../../gameScripts/pixi/performs/cherryBlossoms';
import '../../gameScripts/pixi/performs/rain';
import '../../gameScripts/pixi/performs/snow';



================================================
FILE: webgal/src/Core/util/pixiPerformManager/pixiPerformManager.ts
================================================
import type { Container } from 'pixi.js';
import { logger } from '../logger';

export interface ILayerResult {
  container: Container;
  tickerKey: string;
}

export type ILayerGenerator = () => ILayerResult;

/**
 * 特效执行返回的结果
 */
export interface IResult {
  fg?: ILayerResult;
  bg?: ILayerResult;
}

/**
 * 特效定义对象
 */
export interface IPerformDefinition {
  fg?: ILayerGenerator;
  bg?: ILayerGenerator;
}

type IName = string | (() => string);

type IPerformCallback = () => IResult;

const performs = new Map<string, IPerformCallback>();

/**
 * 获取名称, 可能报空
 * @param name 名称或者返回名称的函数
 * @returns {string}
 */
function getName(name: IName): string | null {
  if (!name) return null;
  if (typeof name === 'string') return name;
  return name();
}

/**
 * 获取名称, 不会报空
 * @param name 名称或者返回名称的函数
 * @returns {string}
 */
function getKey(name: IName): string {
  const key = getName(name);
  if (!key) {
    logger.error('Get name of perform failed. There no name of the perform.');
    return '';
  }
  return key;
}

/**
 * 注册特效, 注意, 同名会注销旧特效
 * @param name 特效名
 * @param callback 调用特效的函数
 */
export function registerPerform(name: IName, definition: IPerformDefinition): void {
  const effectKey = getKey(name);
  if (!effectKey) {
    throw new Error('Cannot register a perform without a valid name.');
  }

  const { fg: fgGenerator, bg: bgGenerator } = definition;

  if (typeof fgGenerator !== 'undefined' && typeof fgGenerator !== 'function') {
    throw new Error(`"fg" property for perform "${effectKey}" must be a function or undefined.`);
  }
  if (typeof bgGenerator !== 'undefined' && typeof bgGenerator !== 'function') {
    throw new Error(`"bg" property for perform "${effectKey}" must be a function or undefined.`);
  }

  if (!fgGenerator && !bgGenerator) {
    throw new Error(`Perform definition for "${effectKey}" must have at least an 'fg' or 'bg' generator function.`);
  }

  const internalCallback: IPerformCallback = (): IResult => {
    let fgResult: ILayerResult | undefined;
    let bgResult: ILayerResult | undefined;

    if (fgGenerator) {
      fgResult = fgGenerator();
      if (!fgResult || typeof fgResult.container === 'undefined' || typeof fgResult.tickerKey === 'undefined') {
        logger.error(`The 'fg' generator for perform "${effectKey}" did not return a valid ILayerResult.`);
        throw new Error(`Invalid result from 'fg' generator for perform "${effectKey}".`);
      }
    }

    if (bgGenerator) {
      bgResult = bgGenerator();
      if (!bgResult || typeof bgResult.container === 'undefined' || typeof bgResult.tickerKey === 'undefined') {
        logger.error(`The 'bg' generator for perform "${effectKey}" did not return a valid ILayerResult.`);
        throw new Error(`Invalid result from 'bg' generator for perform "${effectKey}".`);
      }
    }

    const resultPayload: IResult = {};
    if (fgResult) {
      resultPayload.fg = fgResult;
    }
    if (bgResult) {
      resultPayload.bg = bgResult;
    }

    return resultPayload;
  };

  performs.set(effectKey, internalCallback);
}

/**
 * 调用特效
 * @param name 特效名
 * @returns {IResult}
 */
export function call(name: IName): IResult {
  const callback = performs.get(getKey(name));

  if (!callback || typeof callback !== 'function') {
    const nameStr = typeof name === 'function' ? getKey(name) : name;
    const errorMsg = `Can't call the perform named "${nameStr}". It might not be registered or was unregistered.`;
    logger.error(errorMsg);
    throw new Error(
      `Perform "${nameStr}" does not have a valid callback. Available performs: ${getPerforms().join(', ')}`,
    );
  }
  return callback();
}

/**
 * 注销特效
 * @param name 特效名
 */
export function unregisterPerform(name: IName) {
  performs.delete(getKey(name));
}

/**
 * 获取全部可调用的特效特效名
 */
export function getPerforms(): string[] {
  return [...performs.keys()];
}

import('./initRegister');



================================================
FILE: webgal/src/Core/util/prefetcher/assetsPrefetcher.ts
================================================
import { IAsset } from '@/Core/controller/scene/sceneInterface';
import { logger } from '../logger';

import { WebGAL } from '@/Core/WebGAL';

/**
 * 预加载函数
 * @param assetList 场景资源列表
 */
export const assetsPrefetcher = (assetList: Array<IAsset>) => {
  // @ts-ignore
  // 未必要移除，加载到内存里也有用
  // if (window?.isElectron) {
  //   return;
  // }

  for (const asset of assetList) {
    // 判断是否已经存在
    const hasPrefetch = WebGAL.sceneManager.settledAssets.includes(asset.url);
    if (hasPrefetch) {
      logger.debug(`该资源${asset.url}已在预加载列表中，无需重复加载`);
    } else {
      const newLink = document.createElement('link');
      newLink.setAttribute('rel', 'prefetch');
      newLink.setAttribute('href', asset.url);
      const head = document.getElementsByTagName('head');
      if (head.length) {
        try {
          head[0].appendChild(newLink);
        } catch (e) {
          console.log('预加载出错', e);
        }
      }
      WebGAL.sceneManager.settledAssets.push(asset.url);
    }
  }
};



================================================
FILE: webgal/src/Core/util/prefetcher/scenePrefetcher.ts
================================================
/**
 * 场景预加载
 * @param sceneList 需要预加载的场景文件列表
 */
import { sceneFetcher } from '../../controller/scene/sceneFetcher';
import { sceneParser } from '../../parser/sceneParser';
import { logger } from '@/Core/util/logger';

import { WebGAL } from '@/Core/WebGAL';

export const scenePrefetcher = (sceneList: Array<string>): void => {
  for (const e of sceneList) {
    if (!e) continue;
    if (e.includes('/runtime/')) {
      logger.debug(`跳过运行时切片 ${e} 的预加载`);
      continue;
    }
    if (!WebGAL.sceneManager.settledScenes.includes(e)) {
      logger.info(`现在预加载场景${e}`);
      sceneFetcher(e)
        .then((r) => {
          sceneParser(r, e, e);
        })
        .catch((err) => {
          logger.warn(`预加载场景 ${e} 失败: ${err?.message ?? err}`);
        });
    } else {
      logger.warn(`场景${e}已经加载过，无需再次加载`);
    }
  }
};



================================================
FILE: webgal/src/Core/util/syncWithEditor/syncWithOrigine.ts
================================================
import { webgalStore } from '@/store/store';
import { setVisibility } from '@/store/GUIReducer';
import { WebGAL } from '@/Core/WebGAL';
import { resetStage } from '@/Core/controller/stage/resetStage';
import { sceneFetcher } from '@/Core/controller/scene/sceneFetcher';
import { IScene } from '@/Core/controller/scene/sceneInterface';
import { jumpFromBacklog } from '@/Core/controller/storage/jumpFromBacklog';
import { nextSentence } from '@/Core/controller/gamePlay/nextSentence';
import { sceneParser } from '@/Core/parser/sceneParser';
import { logger } from '@/Core/util/logger';
import { assetSetter, fileType } from '@/Core/util/gameAssetsAccess/assetSetter';
import cloneDeep from 'lodash/cloneDeep';

let syncFastTimeout: ReturnType<typeof setTimeout> | undefined;

export const syncWithOrigine = (sceneName: string, sentenceId: number, expermental = false) => {
  logger.warn('正在跳转到' + sceneName + ':' + sentenceId);
  const dispatch = webgalStore.dispatch;
  dispatch(setVisibility({ component: 'showTitle', visibility: false }));
  dispatch(setVisibility({ component: 'showMenuPanel', visibility: false }));
  dispatch(setVisibility({ component: 'isShowLogo', visibility: false }));
  const title = document.querySelector('.html-body__title-enter') as HTMLElement;
  if (title) {
    title.style.display = 'none';
  }
  const pastScene = cloneDeep(WebGAL.sceneManager.sceneData.currentScene);
  // 重新获取场景
  const sceneUrl: string = assetSetter(sceneName, fileType.scene);
  // 场景写入到运行时
  sceneFetcher(sceneUrl).then((rawScene) => {
    // 等等，先检查一下能不能恢复场景
    const lastSameSentence = findLastSameSentence(pastScene, WebGAL.sceneManager.sceneData.currentScene, sentenceId);
    const lastRecoverySentenceId = Math.min(sentenceId, lastSameSentence);
    const recId = findLastAvailableBacklog(lastRecoverySentenceId, sceneName);
    const isCanRec = recId >= 0 && expermental;
    resetStage(!isCanRec);
    WebGAL.sceneManager.sceneData.currentScene = sceneParser(rawScene, sceneName, sceneUrl);
    // 开始快进到指定语句
    const currentSceneName = WebGAL.sceneManager.sceneData.currentScene.sceneName;
    WebGAL.gameplay.isFast = true;
    if (isCanRec) {
      jumpFromBacklog(recId, false);
    }
    if (syncFastTimeout) {
      // 之前发生的跳转要清理掉
      clearTimeout(syncFastTimeout);
    }
    syncFast(sentenceId, currentSceneName);
  });
};

export function syncFast(sentenceId: number, currentSceneName: string) {
  if (
    WebGAL.sceneManager.sceneData.currentSentenceId < sentenceId &&
    WebGAL.sceneManager.sceneData.currentScene.sceneName === currentSceneName
  ) {
    nextSentence();
    syncFastTimeout = setTimeout(() => syncFast(sentenceId, currentSceneName), 2);
  } else {
    WebGAL.gameplay.isFast = false;
  }
}

function findLastSameSentence(oldScene: IScene, newScene: IScene, sentenceId: number): number {
  let lastSameSentence = 0;
  for (let i = 0; i < sentenceId && i < oldScene.sentenceList.length; i++) {
    const oldSentenceStr = JSON.stringify(oldScene.sentenceList[i]);
    const newSentenceStr = JSON.stringify(newScene.sentenceList[i]);
    if (oldSentenceStr !== newSentenceStr) {
      break;
    }
    lastSameSentence = i;
  }
  return lastSameSentence;
}

function findLastAvailableBacklog(targetSentence: number, sceneName: string) {
  let lastAvailable = -1;
  WebGAL.backlogManager.getBacklog().forEach((e, i) => {
    const recSentenceId = e.saveScene.currentSentenceId;
    const recSceneName = e.saveScene.sceneName;
    if (recSentenceId <= targetSentence && recSceneName === sceneName) {
      lastAvailable = i;
    }
  });
  return lastAvailable;
}



================================================
FILE: webgal/src/Core/util/syncWithEditor/webSocketFunc.ts
================================================
import { DebugCommand, IComponentVisibilityCommand, IDebugMessage } from '@/types/debugProtocol';
import { webgalStore } from '@/store/store';
import { setFontOptimization, setVisibility } from '@/store/GUIReducer';
import { WebGAL } from '@/Core/WebGAL';
import { sceneParser, WebgalParser } from '@/Core/parser/sceneParser';
import { ISentence } from '@/Core/controller/scene/sceneInterface';
import { runScript } from '@/Core/controller/gamePlay/runScript';
import { nextSentence } from '@/Core/controller/gamePlay/nextSentence';
import { resetStage } from '@/Core/controller/stage/resetStage';
import { logger } from '@/Core/util/logger';
import { syncWithOrigine } from './syncWithOrigine';

export const webSocketFunc = () => {
  const loc: string = window.location.hostname;
  const protocol: string = window.location.protocol;
  const port: string = window.location.port; // 获取端口号

  // 默认情况下，不需要在URL中明确指定标准HTTP(80)和HTTPS(443)端口
  let defaultPort = '';
  if (port && port !== '80' && port !== '443') {
    // 如果存在非标准端口号，将其包含在URL中
    defaultPort = `:${port}`;
  }

  if (protocol !== 'http:' && protocol !== 'https:') {
    return;
  }
  // 根据当前协议构建WebSocket URL，并包括端口号（如果有）
  let wsUrl = `ws://${loc}${defaultPort}/api/webgalsync`;
  if (protocol === 'https:') {
    wsUrl = `wss://${loc}${defaultPort}/api/webgalsync`;
  }
  logger.info('正在启动socket连接位于：' + wsUrl);
  const socket = new WebSocket(wsUrl);
  socket.onopen = () => {
    logger.info('socket已连接');
    function sendStageSyncMessage() {
      const message: IDebugMessage = {
        event: 'message',
        data: {
          command: DebugCommand.SYNCFC,
          sceneMsg: {
            scene: WebGAL.sceneManager.sceneData.currentScene.sceneName,
            sentence: WebGAL.sceneManager.sceneData.currentSentenceId,
          },
          stageSyncMsg: webgalStore.getState().stage,
          message: 'sync',
        },
      };
      socket.send(JSON.stringify(message));
      // logger.debug('传送信息', message);
      setTimeout(sendStageSyncMessage, 1000);
    }
    sendStageSyncMessage();
  };
  socket.onmessage = (e) => {
    // logger.info('收到信息', e.data);
    const str: string = e.data;
    const data: IDebugMessage = JSON.parse(str);
    const message = data.data;
    if (message.command === DebugCommand.JUMP) {
      syncWithOrigine(message.sceneMsg.scene, message.sceneMsg.sentence, message.message === 'exp');
    }
    if (message.command === DebugCommand.EXE_COMMAND) {
      const command = message.message;
      const scene = WebgalParser.parse(command, 'temp.txt', 'temp.txt');
      scene.sentenceList.forEach((sentence: ISentence) => {
        runScript(sentence);
      });
    }
    if (message.command === DebugCommand.REFETCH_TEMPLATE_FILES) {
      const title = document.querySelector('.html-body__title-enter') as HTMLElement;
      if (title) {
        title.style.display = 'none';
      }
      WebGAL.events.styleUpdate.emit();
    }
    if (message.command === DebugCommand.SET_COMPONENT_VISIBILITY) {
      // handle SET_COMPONENT_VISIBILITY message
      const command = message.message;

      const commandData = JSON.parse(command) as IComponentVisibilityCommand[];
      commandData.forEach((item) => {
        if (item) {
          webgalStore.dispatch(setVisibility({ component: item.component, visibility: item.visibility }));
        }
      });
    }
    if (message.command === DebugCommand.TEMP_SCENE) {
      const command = message.message;
      resetStage(true);
      WebGAL.sceneManager.sceneData.currentScene = sceneParser(command, 'temp', './temp.txt');
      webgalStore.dispatch(setVisibility({ component: 'showTitle', visibility: false }));
      webgalStore.dispatch(setVisibility({ component: 'showMenuPanel', visibility: false }));
      webgalStore.dispatch(setVisibility({ component: 'showPanicOverlay', visibility: false }));
      setTimeout(() => {
        nextSentence();
      }, 100);
    }
    if (message.command === DebugCommand.FONT_OPTIMIZATION) {
      const command = message.message;
      webgalStore.dispatch(setFontOptimization(command === 'true'));
    }
  };
  socket.onerror = () => {
    logger.info('当前没有连接到 Terre 编辑器');
  };
};



================================================
FILE: webgal/src/Gallery/Gallery.tsx
================================================
import { useEffect, useState, type CSSProperties } from 'react';
import { gameState } from '@/Core/gameState';

interface GameMeta {
  slug: string;
  name: string;
  author: string;
  cover: string;
}

interface GalleryProps {
  onGameSelect: (slug: string) => void;
}

const galleryStyles: Record<string, CSSProperties> = {
  root: {
    width: '100%',
    height: '100%',
    padding: '32px',
    boxSizing: 'border-box',
    display: 'flex',
    flexDirection: 'column',
    gap: '24px',
    background: 'linear-gradient(135deg, #0f172a 0%, #1e1b4b 50%, #312e81 100%)',
    color: '#f8fafc',
  },
  list: {
    display: 'grid',
    gridTemplateColumns: 'repeat(auto-fit, minmax(280px, 1fr))',
    gap: '24px',
    width: '100%',
  },
  card: {
    background: 'rgba(15, 23, 42, 0.85)',
    borderRadius: '16px',
    overflow: 'hidden',
    display: 'flex',
    flexDirection: 'column',
    border: '1px solid rgba(248, 250, 252, 0.08)',
    boxShadow: '0 20px 45px rgba(15, 23, 42, 0.45)',
    cursor: 'pointer',
    transition: 'transform 0.25s ease, box-shadow 0.25s ease',
  },
  cardImage: {
    width: '100%',
    height: '200px',
    objectFit: 'cover',
    background: '#020617',
  },
  cardBody: {
    padding: '20px',
    display: 'flex',
    flexDirection: 'column',
    gap: '8px',
  },
  playButton: {
    marginTop: '16px',
    padding: '10px 16px',
    borderRadius: '999px',
    border: 'none',
    background: '#22d3ee',
    color: '#0f172a',
    fontWeight: 600,
    cursor: 'pointer',
    textTransform: 'uppercase',
    letterSpacing: '0.04em',
  },
};

export function Gallery({ onGameSelect }: GalleryProps) {
  const [games, setGames] = useState<GameMeta[]>([]);
  const [error, setError] = useState<string | null>(null);

  useEffect(() => {
    fetch('/games.json')
      .then((res) => {
        if (!res.ok) {
          throw new Error(`Failed to load games.json (${res.status})`);
        }
        return res.json();
      })
      .then((data: GameMeta[]) => {
        setGames(data);
      })
      .catch((err) => {
        console.error('Failed to load games.json:', err);
        setError('无法加载游戏列表，请检查 public/games.json。');
      });
  }, []);

  const handleSelect = (slug: string) => {
    gameState.activeGameSlug = slug;
    try {
      sessionStorage.setItem('activeGameSlug', slug);
    } catch (err) {
      console.warn('Failed to persist activeGameSlug', err);
    }
    onGameSelect(slug);
  };

  return (
    <div style={galleryStyles.root}>
      <div>
        <h1 style={{ margin: 0, fontSize: '32px' }}>WebGAL 游戏画廊</h1>
        <p style={{ margin: '8px 0 0', color: 'rgba(248,250,252,0.7)' }}>选择一个故事开始体验</p>
      </div>
      {error && <div>{error}</div>}
      <div style={galleryStyles.list}>
        {games.map((game) => (
          <div
            key={game.slug}
            style={galleryStyles.card}
            onClick={() => handleSelect(game.slug)}
            onKeyDown={(event) => {
              if (event.key === 'Enter' || event.key === ' ') {
                handleSelect(game.slug);
              }
            }}
            role="button"
            tabIndex={0}
          >
            <img src={game.cover} alt={game.name} style={galleryStyles.cardImage} />
            <div style={galleryStyles.cardBody}>
              <h2 style={{ margin: 0, fontSize: '22px' }}>{game.name}</h2>
              <span style={{ color: 'rgba(248,250,252,0.7)', fontSize: '14px' }}>作者：{game.author}</span>
              <button
                style={galleryStyles.playButton}
                type="button"
                onClick={(event) => {
                  event.stopPropagation();
                  handleSelect(game.slug);
                }}
              >
                开始游戏
              </button>
            </div>
          </div>
        ))}
        {games.length === 0 && !error && <div>暂时没有可用的游戏，请检查 public/games 目录。</div>}
      </div>
    </div>
  );
}



================================================
FILE: webgal/src/hooks/useApplyStyle.ts
================================================
import { useEffect } from 'react';
import { WebGAL } from '@/Core/WebGAL';
import axios from 'axios';
import { scss2cssinjsParser } from '@/Core/controller/customUI/scss2cssinjsParser';
import { useValue } from '@/hooks/useValue';
import { css, injectGlobal } from '@emotion/css';
import { useSelector } from 'react-redux';
import { RootState } from '@/store/store';
import { IWebGALStyleObj } from 'webgal-parser/build/types/styleParser';
import { logger } from '@/Core/util/logger';
import { getGameAssetPath } from '@/Core/gameState';

export default function useApplyStyle(url: string) {
  const styleObject = useValue<IWebGALStyleObj>({ classNameStyles: {}, others: '' });
  const replaced = useSelector((state: RootState) => state.stage.replacedUIlable);

  const applyStyle = (classNameLable: string, fallbackClassName: string) => {
    // 先看看是否被用户用 applyStyle 指令替换了类名
    const className = replaced?.[classNameLable] ?? classNameLable;
    if (Object.keys(styleObject.value.classNameStyles).includes(className)) {
      const cijClassName = css(styleObject.value.classNameStyles?.[className] ?? '');
      return `${fallbackClassName} ${cijClassName}`;
    }
    return fallbackClassName;
  };

  const updateStyleFile = async () => {
    logger.debug('更新 Scss 文件', url);
    const resp = await axios.get(getGameAssetPath(`template/${url}`));
    const scssStr = resp.data;
    styleObject.set(scss2cssinjsParser(scssStr));
  };

  useEffect(() => {
    updateStyleFile();
  }, []);

  useEffect(() => {
    injectGlobal(styleObject.value.others);
  }, [styleObject.value.others]);

  useRigisterStyleUpdate(updateStyleFile);

  return applyStyle;
}

function useRigisterStyleUpdate(callback: Function) {
  const handler = () => {
    callback();
  };
  useEffect(() => {
    WebGAL.events.styleUpdate.on(handler);
    return () => WebGAL.events.styleUpdate.off(handler);
  }, []);
}



================================================
FILE: webgal/src/hooks/useConfigData.ts
================================================
import { getFastSaveFromStorage, getSavesFromStorage } from '@/Core/controller/storage/savesController';
import { getStorage } from '@/Core/controller/storage/storageController';
import { setEbg } from '@/Core/gameScripts/changeBg/setEbg';
import { assetSetter, fileType } from '@/Core/util/gameAssetsAccess/assetSetter';
import { WebGAL } from '@/Core/WebGAL';
import { setGuiAsset, setLogoImage } from '@/store/GUIReducer';
import { RootState, webgalStore } from '@/store/store';
import { useEffect } from 'react';
import { useSelector } from 'react-redux';

const useConfigData = () => {
  const _map = ['Title_img', 'Game_Logo', 'Title_bgm', 'Game_name', 'Game_key'];
  const configData = useSelector((state: RootState) => state.userData.globalGameVar);
  return useEffect(() => {
    // configData发生变化
    for (let i in configData) {
      if (!_map.includes(i)) {
        continue;
      }
      const val = configData[i] as string;
      switch (i) {
        case 'Title_img': {
          const titleUrl = assetSetter(val, fileType.background);
          webgalStore.dispatch(setGuiAsset({ asset: 'titleBg', value: titleUrl }));
          setEbg(titleUrl);
          break;
        }

        case 'Game_Logo': {
          const logos = val.split('|');
          const logoUrlList = logos.map((val) => assetSetter(val, fileType.background));
          webgalStore.dispatch(setLogoImage(logoUrlList));
          break;
        }

        case 'Title_bgm': {
          const bgmUrl = assetSetter(val, fileType.bgm);
          webgalStore.dispatch(setGuiAsset({ asset: 'titleBgm', value: bgmUrl }));
          break;
        }

        case 'Game_name': {
          WebGAL.gameName = val;
          document.title = val;
          break;
        }

        case 'Game_key': {
          WebGAL.gameKey = val;
          getStorage();
          getFastSaveFromStorage();
          getSavesFromStorage(0, 0);
          break;
        }
      }
    }
    return () => {};
  }, [configData.Game_Logo, configData.Game_key, configData.Game_name, configData.Title_bgm, configData.Title_img]);
};
export default useConfigData;



================================================
FILE: webgal/src/hooks/useEscape.ts
================================================
const escapeMap = [
  {
    reg: /\\\\/g,
    val: '\\',
  },
  {
    reg: /\\\|/g,
    val: '|',
  },
  {
    reg: /\\:/g,
    val: ':',
  },
  {
    reg: /\\,/g,
    val: ',',
  },
  {
    reg: /\\;/g,
    val: ';',
  },
  {
    reg: /\\\./g,
    val: '.',
  },
];
const useEscape = (val: string): string => {
  let _res = val;
  for (let i of escapeMap) {
    _res = _res.replaceAll(i.reg, i.val);
  }
  return _res;
};
export default useEscape;



================================================
FILE: webgal/src/hooks/useFontFamily.ts
================================================
import { useSelector } from 'react-redux';
import { RootState } from '@/store/store';
import { textFont } from '@/store/userDataInterface';
import { match } from '@/Core/util/match';

export function useFontFamily() {
  const fontFamily = useSelector((state: RootState) => state.userData.optionData.textboxFont);

  function getFont() {
    return match(fontFamily)
      .with(textFont.song, () => '"思源宋体", serif')
      .with(textFont.lxgw, () => '"LXGW", serif')
      .with(textFont.hei, () => '"WebgalUI", serif')
      .default(() => '"WebgalUI", serif');
  }

  return getFont();
}



================================================
FILE: webgal/src/hooks/useFullScreen.ts
================================================
import { useEffect, useState } from 'react';

const _isFullScreen = () => !!(document.fullscreenElement || (document as any).webkitFullscreenElement);
export default function useFullScreen(target: Element = document.documentElement): {
  isSupported: boolean;
  isFullScreen: boolean;
  enter: () => Promise<void>;
  exit: () => Promise<void>;
  toggle: () => Promise<void>;
} {
  const isSupported = document.fullscreenEnabled || (document as any).webkitFullscreenEnabled;
  const [isFullScreen, setFullScreen] = useState<boolean>(_isFullScreen());

  useEffect(() => {
    if (!isSupported) return;
    const onFullscreenChange = () => setFullScreen(_isFullScreen());

    document.addEventListener('fullscreenchange', onFullscreenChange);

    return () => {
      document.removeEventListener('fullscreenchange', onFullscreenChange);
    };
  }, []);

  const enter = isSupported ? () => target.requestFullscreen() : async () => {};
  const exit = isSupported ? () => document.exitFullscreen() : async () => {};

  return {
    isSupported,
    isFullScreen: isFullScreen,
    enter,
    exit,
    toggle: () => (isFullScreen ? exit() : enter()),
  };
}



================================================
FILE: webgal/src/hooks/useGenSyncRef.ts
================================================
import { useSelector } from 'react-redux';
import { useEffect, useRef } from 'react';

/**
 * 生成一个和redux自动同步的Ref对象
 */
export function useGenSyncRef<TState = unknown, Selected = unknown>(
  selector: (state: TState) => Selected,
): { readonly current: Selected } {
  const Store = useSelector(selector);
  const Ref = useRef(Store);
  useEffect(() => {
    Ref.current = Store;
  }, [Store]);
  return Ref;
}



================================================
FILE: webgal/src/hooks/useHotkey.tsx
================================================
import { startFast, stopAll, stopFast } from '@/Core/controller/gamePlay/fastSkip';
import { nextSentence } from '@/Core/controller/gamePlay/nextSentence';
import { fastSaveGame } from '@/Core/controller/storage/fastSaveLoad';
import { setStorage } from '@/Core/controller/storage/storageController';
import { WebGAL } from '@/Core/WebGAL';
import { useGenSyncRef } from '@/hooks/useGenSyncRef';
import { useMounted, useUnMounted, useUpdated } from '@/hooks/useLifeCycle';
import { componentsVisibility, MenuPanelTag } from '@/store/guiInterface';
import { setVisibility } from '@/store/GUIReducer';
import { RootState } from '@/store/store';
import { setOptionData } from '@/store/userDataReducer';
import styles from '@/UI/Backlog/backlog.module.scss';
import throttle from 'lodash/throttle';
import { useCallback, useEffect, useRef } from 'react';
import { useDispatch } from 'react-redux';
import useFullScreen from './useFullScreen';

// options备用
export interface HotKeyType {
  MouseRight: {} | boolean;
  MouseWheel: {} | boolean;
  Ctrl: boolean;
  Esc:
    | {
        href: string;
        nav: 'replace' | 'push';
      }
    | boolean;
  AutoSave: {} | boolean;
}

export interface Keyboard {
  lock: (keys: string[]) => Promise<void>;
  unlock: () => Promise<void>;
}

export const keyboard: Keyboard | undefined = 'keyboard' in navigator && (navigator.keyboard as any); // FireFox and Safari not support

// export const fastSaveGameKey = `FastSaveKey`;
// export const isFastSaveKey = `FastSaveActive`;

export function useHotkey(opt?: HotKeyType) {
  useMouseRightClickHotKey();
  useMouseWheel();
  useSkip();
  usePanic();
  useFastSaveBeforeUnloadPage();
  useSpaceAndEnter();
  useToggleFullScreen();
}

/**
 * 右键关闭 & 打开 菜单栏
 */
export function useMouseRightClickHotKey() {
  const GUIStore = useGenSyncRef((state: RootState) => state.GUI);
  const setComponentVisibility = useSetComponentVisibility();
  const isGameActive = useGameActive<typeof GUIStore>(GUIStore);
  const isInBackLog = useIsInBackLog<typeof GUIStore>(GUIStore);
  const isOpenedDialog = useIsOpenedDialog<typeof GUIStore>(GUIStore);
  const validMenuPanelTag = useValidMenuPanelTag<typeof GUIStore>(GUIStore);
  const isShowExtra = useIsOpenedExtra<typeof GUIStore>(GUIStore);
  const handleContextMenu = useCallback((ev: MouseEvent) => {
    if (isOpenedDialog()) {
      setComponentVisibility('showGlobalDialog', false);
      ev.preventDefault();
      return false;
    }
    if (isShowExtra()) {
      setComponentVisibility('showExtra', false);
    }
    if (isGameActive()) {
      setComponentVisibility('showTextBox', !GUIStore.current.showTextBox);
    }
    if (isInBackLog()) {
      setComponentVisibility('showBacklog', false);
      setComponentVisibility('showTextBox', true);
    }
    if (validMenuPanelTag()) {
      setComponentVisibility('showMenuPanel', false);
    }
    ev.preventDefault();
    return false;
  }, []);
  useMounted(() => {
    document.addEventListener('contextmenu', handleContextMenu);
  });
  useUnMounted(() => {
    document.removeEventListener('contextmenu', handleContextMenu);
  });
}

let wheelTimeout = setTimeout(() => {
  // 初始化，什么也不干
}, 0);

/**
 * 滚轮向上打开历史记录
 * 滚轮向下关闭历史记录
 * 滚轮向下下一句
 */
export function useMouseWheel() {
  const GUIStore = useGenSyncRef((state: RootState) => state.GUI);
  const setComponentVisibility = useSetComponentVisibility();
  const isGameActive = useGameActive(GUIStore);
  const isInBackLog = useIsInBackLog(GUIStore);
  const isPanicOverlayOpen = useIsPanicOverlayOpen(GUIStore);
  const next = useCallback(
    throttle(() => {
      nextSentence();
    }, 100),
    [],
  );
  // 防止一直往下滚的时候顺着滚出历史记录
  // 问就是抄的999
  const prevDownWheelTimeRef = useRef(0);
  const handleMouseWheel = useCallback((ev) => {
    if (isPanicOverlayOpen()) return;
    const direction =
      (ev.wheelDelta && (ev.wheelDelta > 0 ? 'up' : 'down')) ||
      (ev.detail && (ev.detail < 0 ? 'up' : 'down')) ||
      'down';
    const ctrlKey = ev.ctrlKey;
    const dom = document.querySelector(`.${styles.backlog_content}`);
    if (isGameActive() && direction === 'up' && !ctrlKey) {
      setComponentVisibility('showBacklog', true);
      setComponentVisibility('showTextBox', false);
    } else if (isInBackLog() && direction === 'down' && !ctrlKey) {
      if (dom) {
        let flag = hasScrollToBottom(dom);
        let curTime = new Date().getTime();
        // 滚动到底部 & 非连续滚动
        if (flag && curTime - prevDownWheelTimeRef.current > 100) {
          setComponentVisibility('showBacklog', false);
          setComponentVisibility('showTextBox', true);
        }
        prevDownWheelTimeRef.current = curTime;
      }
      // setComponentVisibility('showBacklog', false);
    } else if (isGameActive() && direction === 'down' && !ctrlKey) {
      clearTimeout(wheelTimeout);
      WebGAL.gameplay.isFast = true;
      // 滚轮视作快进
      setTimeout(() => {
        WebGAL.gameplay.isFast = false;
      }, 150);
      next();
    }
  }, []);
  useMounted(() => {
    document.addEventListener('wheel', handleMouseWheel);
  });
  useUnMounted(() => {
    document.removeEventListener('wheel', handleMouseWheel);
  });
}

/**
 * Panic Button, use Esc and Backquote
 */
export function usePanic() {
  const panicButtonList = ['Escape', 'Backquote'];
  const isPanicButton = (ev: KeyboardEvent) =>
    !ev.isComposing && !ev.defaultPrevented && panicButtonList.includes(ev.code);
  const GUIStore = useGenSyncRef((state: RootState) => state.GUI);
  const isTitleShown = useCallback(() => GUIStore.current.showTitle, [GUIStore]);
  const isPanicOverlayOpen = useIsPanicOverlayOpen(GUIStore);
  const setComponentVisibility = useSetComponentVisibility();
  const handlePressPanicButton = useCallback((ev: KeyboardEvent) => {
    if (!isPanicButton(ev) || isTitleShown()) return;
    if (isPanicOverlayOpen()) {
      setComponentVisibility('showPanicOverlay', false);
      // todo: resume
    } else {
      setComponentVisibility('showPanicOverlay', true);
      stopAll(); // despite the name, it only disables fast mode and auto mode
      // todo: pause music & animation for better performance
    }
  }, []);
  useMounted(() => {
    document.addEventListener('keyup', handlePressPanicButton);
  });
  useUnMounted(() => {
    document.removeEventListener('keyup', handlePressPanicButton);
  });
}

/**
 * ctrl控制快进
 */
export function useSkip() {
  // 因为document事件只绑定一次 为了防止之后更新GUIStore时取不到最新值
  // 使用Ref共享GUIStore
  const GUIStore = useGenSyncRef((state: RootState) => state.GUI);
  // 判断是否位于标题 & 存读档，选项 & 回想等页面
  const isGameActive = useGameActive(GUIStore);
  // 判断按键是否为ctrl
  const isCtrlKey = useCallback((e) => e.keyCode === 17, []);
  const handleCtrlKeydown = useCallback((e) => {
    if (isCtrlKey(e) && isGameActive()) {
      startFast();
    }
  }, []);
  const handleCtrlKeyup = useCallback((e) => {
    if (isCtrlKey(e) && isGameActive()) {
      stopFast();
    }
  }, []);
  const handleWindowBlur = useCallback((e) => {
    // 停止快进
    stopFast();
  }, []);
  // mounted时绑定事件
  useMounted(() => {
    document.addEventListener('keydown', handleCtrlKeydown);
    document.addEventListener('keyup', handleCtrlKeyup);
    window.addEventListener('blur', handleWindowBlur);
  });
  // unmounted解绑
  useUnMounted(() => {
    document.removeEventListener('keydown', handleCtrlKeydown);
    document.removeEventListener('keyup', handleCtrlKeyup);
    window.removeEventListener('blur', handleWindowBlur);
  });
  // updated时验证状态
  useUpdated(() => {
    if (!isGameActive()) {
      stopFast();
    }
  });
}

/**
 * F5刷新 & 其他情况下导致页面卸载时快速保存
 */
export function useFastSaveBeforeUnloadPage() {
  const validMenuGameStart = useValidMenuGameStart();
  const handleWindowUnload = useCallback(async (e: BeforeUnloadEvent) => {
    if (validMenuGameStart()) {
      // 游戏启动了才保存数据 防止无效数据覆盖现在的数据
      await fastSaveGame();
    }
  }, []);
  useMounted(() => {
    window.addEventListener('beforeunload', handleWindowUnload);
  });
  useUnMounted(() => {
    window.removeEventListener('beforeunload', handleWindowUnload);
  });
}

// 判断游戏是否激活
function useGameActive<T = any>(GUIStore: T & any): () => boolean {
  return useCallback(() => {
    return (
      !GUIStore.current.showTitle &&
      !GUIStore.current.showMenuPanel &&
      !GUIStore.current.showBacklog &&
      !GUIStore.current.showPanicOverlay
    );
  }, [GUIStore]);
}

// 判断是否打开backlog
function useIsInBackLog<T = any>(GUIStore: T & any): () => boolean {
  return useCallback(() => {
    return GUIStore.current.showBacklog;
  }, [GUIStore]);
}

// 判断是否打开了全局对话框
function useIsOpenedDialog<T = any>(GUIStore: T & any): () => boolean {
  return useCallback(() => {
    return GUIStore.current.showGlobalDialog;
  }, [GUIStore]);
}

// 判断是否打开了鉴赏模式
function useIsOpenedExtra<T = any>(GUIStore: T & any): () => boolean {
  return useCallback(() => {
    return GUIStore.current.showExtra;
  }, [GUIStore]);
}

function useIsPanicOverlayOpen<T = any>(GUIStore: T & any): () => boolean {
  return useCallback(() => {
    return GUIStore.current.showPanicOverlay;
  }, [GUIStore]);
}

// 验证是否在存档 / 读档 / 选项页面
function useValidMenuPanelTag<T = any>(GUIStore: T & any): () => boolean {
  return useCallback(() => {
    return [MenuPanelTag.Save, MenuPanelTag.Load, MenuPanelTag.Option].includes(GUIStore.current.currentMenuTag);
  }, [GUIStore]);
}

function useValidMenuGameStart() {
  return useCallback(() => {
    // return !(runtime_currentSceneData.currentSentenceId === 0 &&
    //   runtime_currentSceneData.currentScene.sceneName === 'start.txt');
    return !(WebGAL.sceneManager.sceneData.currentSentenceId === 0);
  }, [WebGAL.sceneManager.sceneData]);
}

function useSetComponentVisibility(): (component: keyof componentsVisibility, visibility: boolean) => void {
  const dispatch = useDispatch();
  return (component: keyof componentsVisibility, visibility: boolean) => {
    dispatch(setVisibility({ component, visibility }));
  };
}

function nextTick(callback: () => void) {
  // 具体实现根据浏览器的兼容实现微任务
  if (typeof Promise !== 'undefined') {
    const p = Promise.resolve();
    p.then(callback);
  } else {
    // 兼容IE
    setTimeout(callback, 0);
  }
}

/**
 * 空格 & 回车 跳转到下一条
 */
export function useSpaceAndEnter() {
  const GUIStore = useGenSyncRef((state: RootState) => state.GUI);
  const isGameActive = useGameActive(GUIStore);
  const setComponentVisibility = useSetComponentVisibility();
  // 防止一直触发keydown导致快进
  const lockRef = useRef(false);
  // 判断按键是否为空格 & 回车
  const isSpaceOrEnter = useCallback((e) => {
    return e.keyCode === 32 || e.keyCode === 13;
  }, []);
  const handleKeydown = useCallback((e) => {
    if (isSpaceOrEnter(e) && isGameActive() && !lockRef.current) {
      if (!GUIStore.current.showTextBox) {
        setComponentVisibility('showTextBox', true);
        return;
      }
      stopAll();
      nextSentence();
      lockRef.current = true;
    }
  }, []);
  const handleKeyup = useCallback((e) => {
    if (isSpaceOrEnter(e) && isGameActive()) {
      lockRef.current = false;
    }
  }, []);
  const handleWindowBlur = useCallback((e) => {
    lockRef.current = false;
  }, []);
  // mounted时绑定事件
  useMounted(() => {
    document.addEventListener('keydown', handleKeydown);
    document.addEventListener('keyup', handleKeyup);
    document.addEventListener('blur', handleWindowBlur);
  });
  // unmounted解绑
  useUnMounted(() => {
    document.removeEventListener('keydown', handleKeydown);
    document.removeEventListener('keyup', handleKeyup);
    document.removeEventListener('blur', handleWindowBlur);
  });
}

/**
 * 是否滚动到底部
 * @param dom
 */
function hasScrollToBottom(dom: Element) {
  const { scrollTop, clientHeight, scrollHeight } = dom;
  return scrollTop === 0;
}

/**
 * F11 进入全屏
 */
function useToggleFullScreen() {
  const { isSupported, isFullScreen, toggle } = useFullScreen();
  if (!isSupported) return;
  const dispatch = useDispatch();

  useEffect(() => {
    const handleKeyDown = (e: KeyboardEvent) => e.repeat || (e.key === 'F11' && toggle());
    document.addEventListener('keydown', handleKeyDown);
    return () => {
      document.removeEventListener('keydown', handleKeyDown);
    };
  }, []);
  useEffect(() => {
    dispatch(setOptionData({ key: 'fullScreen', value: isFullScreen ? 0 : 1 }));
    if (WebGAL.gameKey) setStorage();
  }, [isFullScreen]);
}



================================================
FILE: webgal/src/hooks/useLanguage.ts
================================================
import { RootState } from '@/store/store';
import { setOptionData } from '@/store/userDataReducer';
import { useTranslation } from 'react-i18next';
import { useDispatch } from 'react-redux';
import { useGenSyncRef } from './useGenSyncRef';
import { logger } from '@/Core/util/logger';
import { setStorage } from '@/Core/controller/storage/storageController';
import { language } from '@/config/language';

export function getLanguageName(lang: language): string {
  return language[lang];
}

export default function useLanguage() {
  const { i18n } = useTranslation();
  const userDataRef = useGenSyncRef((state: RootState) => state.userData);
  const dispatch = useDispatch();

  return (_lang?: language, isSyncStorage = true) => {
    const lang = _lang ?? userDataRef.current?.optionData.language ?? language.zhCn;

    const languageName = getLanguageName(lang);
    i18n.changeLanguage(languageName);

    dispatch(setOptionData({ key: 'language', value: lang }));
    logger.info('设置语言: ' + languageName);
    window?.localStorage.setItem('lang', lang.toString());
    if (isSyncStorage) {
      setStorage();
    }
  };
}



================================================
FILE: webgal/src/hooks/useLifeCycle.ts
================================================
import { useEffect } from 'react';

// 挂载
export function useMounted(callback: Function) {
  useEffect(() => {
    callback();
  }, []);
}

// 卸载
export function useUnMounted(callback: Function) {
  useEffect(() => {
    return function () {
      callback();
    };
  }, []);
}

// 更新
export function useUpdated(callback: Function) {
  useEffect(() => {
    callback();
  });
}



================================================
FILE: webgal/src/hooks/useNotFirstEffect.ts
================================================
import { DependencyList, useEffect, useState } from 'react';

export default function useNotFirstEffect(callback: () => void, deps: DependencyList) {
  const [firstly, setFirstly] = useState<boolean>(false);

  useEffect(() => {
    setFirstly(true);
    if (firstly) callback();
  }, deps);
}



================================================
FILE: webgal/src/hooks/useSoundEffect.ts
================================================
import { setStage } from '@/store/stageReducer';

import page_flip_1 from '@/assets/se/page-flip-1.mp3';
import switch_1 from '@/assets/se/switch-1.mp3';
import mouse_enter from '@/assets/se/mouse-enter.mp3';
import dialog_se from '@/assets/se/dialog.mp3';
import click_se from '@/assets/se/click.mp3';
import { useDispatch } from 'react-redux';
import { webgalStore } from '@/store/store';

/**
 * 调用音效
 */
const useSoundEffect = () => {
  const dispatch = useDispatch();

  const playSeEnter = () => {
    dispatch(setStage({ key: 'uiSe', value: mouse_enter }));
  };
  const playSeClick = () => {
    dispatch(setStage({ key: 'uiSe', value: click_se }));
  };
  const playSeSwitch = () => {
    dispatch(setStage({ key: 'uiSe', value: switch_1 }));
  };
  const playSePageChange = () => {
    dispatch(setStage({ key: 'uiSe', value: page_flip_1 }));
  };

  const playSeDialogOpen = () => {
    dispatch(setStage({ key: 'uiSe', value: dialog_se }));
  };

  return {
    playSeEnter,
    playSeClick,
    playSePageChange,
    playSeDialogOpen,
    playSeSwitch,
  };
};

/**
 * 调用音效（只供 choose.tsx 使用）
 */
export const useSEByWebgalStore = () => {
  const playSeEnter = () => {
    webgalStore.dispatch(setStage({ key: 'uiSe', value: mouse_enter }));
  };
  const playSeClick = () => {
    webgalStore.dispatch(setStage({ key: 'uiSe', value: click_se }));
  };
  return {
    playSeEnter, // 鼠标进入
    playSeClick, // 鼠标点击
  };
};

export default useSoundEffect;



================================================
FILE: webgal/src/hooks/useTextOptions.ts
================================================
import { playSpeed } from '@/store/userDataInterface';

// 范围为 [startRange, step * 100 + startRange]
export function useTextDelay(data: number) {
  const startRange = 3;
  const step = 1.5;
  return startRange + (100 - data) * step;
}

// 范围为 [startRange, step * 100 + startRange]
export function useTextAnimationDuration(data: number) {
  const startRange = 200;
  const step = 15;
  return startRange + (100 - data) * step;
}



================================================
FILE: webgal/src/hooks/useTrans.ts
================================================
import { useTranslation } from 'react-i18next';

/**
 * @param prefix 翻译时自动添加的前缀
 * @returns 翻译函数, 输入key时会自动添加前缀, "$" 开头则不填加. 输入多个 key 则会返回翻译数组.
 */
export default function useTrans(prefix?: string) {
  const { t } = useTranslation();
  const trans = (key: string) => t(key[0] === '$' ? key.slice(1) : prefix + key);

  function translation(key: string): string;
  function translation(key: string, ...keys: string[]): string[];
  function translation(key: string, ...keys: string[]) {
    if (keys.length) return [trans(key), ...keys.map((v) => trans(v))];
    return trans(key);
  }

  return translation;
}



================================================
FILE: webgal/src/hooks/useValue.ts
================================================
import { useState } from 'react';

export function useValue<T>(initialState: T) {
  const [value, setValue] = useState<T>(initialState);
  return {
    _value: value,
    set: function (newValue: T) {
      this._value = newValue;
      setValue(newValue);
    },
    get value() {
      return this._value;
    },
    set value(newValue) {
      this.set(newValue);
    },
  };
}



================================================
FILE: webgal/src/Stage/stage.module.scss
================================================
.MainStage_main {
  width: 100%;
  height: 100%;
  position: absolute;
  z-index: 1;
  //animation: MainStage_showBgSoftly 100ms forwards;
  opacity: 1;
  overflow: hidden;
}

.MainStage_main_container {
  width: 100%;
  height: 100%;
  position: absolute;
  overflow: hidden;
}

.MainStage_bgContainer {
  top: 0;
  position: absolute;
  background-size: cover;
  width: 100%;
  height: 100%;
  z-index: 1;
  animation: MainStage_showBgSoftly 1s forwards ease-in-out;
}

.MainStage_bgContainer_Settled {
  top: 0;
  position: absolute;
  background-size: cover;
  width: 100%;
  height: 100%;
  animation: MainStage_showBgSoftly 1ms forwards;
  z-index: 1;
}

.MainStage_oldBgContainer {
  background-size: cover;
  top: 0;
  position: absolute;
  width: 100%;
  height: 100%;
  z-index: 0;
  animation: MainStage_oldBgFadeout 3s forwards;
}

.MainStage_oldBgContainer_Settled {
  background-size: cover;
  top: 0;
  position: absolute;
  width: 100%;
  height: 100%;
  opacity: 0;
}

@keyframes MainStage_showBgSoftly {
  0% {
    opacity: 0.15;
  }
  100% {
    opacity: 1;
  }
}

@keyframes MainStage_oldBgFadeout {
  0% {
    opacity: 1;
  }
  100% {
    opacity: 0;
  }
}

.pixiContainer{
  position: absolute;
  z-index: 5;
}

.chooseContainer{
  z-index: 8;
}



================================================
FILE: webgal/src/Stage/Stage.tsx
================================================
import React, { FC } from 'react';
import styles from './stage.module.scss';
import { TextBox } from './TextBox/TextBox';
import { AudioContainer } from './AudioContainer/AudioContainer';
import { FullScreenPerform } from './FullScreenPerform/FullScreenPerform';
import { nextSentence } from '@/Core/controller/gamePlay/nextSentence';
import { stopAll } from '@/Core/controller/gamePlay/fastSkip';
import { useDispatch, useSelector } from 'react-redux';
import { RootState, webgalStore } from '@/store/store';
import { setVisibility } from '@/store/GUIReducer';
import { TextBoxFilm } from '@/Stage/TextBox/TextBoxFilm';
import { useHotkey } from '@/hooks/useHotkey';
import { MainStage } from '@/Stage/MainStage/MainStage';
import IntroContainer from '@/Stage/introContainer/IntroContainer';
import { isIOS } from '@/Core/initializeScript';
import { WebGAL } from '@/Core/WebGAL';
import { IGuiState } from '@/store/guiInterface';
import { IStageState } from '@/store/stageInterface';
// import OldStage from '@/Components/Stage/OldStage/OldStage';

let timeoutEventHandle: ReturnType<typeof setTimeout> | null = null;
// 视为“未移动”的最小移动阈值（像素^2），例如 4px -> 16
const MOVE_THRESHOLD_SQ = 16;
let lastMouseX = 0;
let lastMouseY = 0;
let hasLastMousePos = false;

/**
 * 检查并更新控制可见性
 * @param event 鼠标移动事件
 * @param stageState 场景状态
 * @param GUIState GUI状态
 * @param dispatch Redux dispatch函数
 */
// eslint-disable-next-line max-params
function updateControlsVisibility(
  event: React.MouseEvent,
  stageState: IStageState,
  GUIState: IGuiState,
  dispatch: ReturnType<typeof useDispatch>,
) {
  // 新逻辑：超过阈值的鼠标移动立刻显示，2s 无操作后隐藏（未锁定时）
  const { clientX, clientY } = event;
  let movedEnough = false;
  if (!hasLastMousePos) {
    movedEnough = true; // 第一次移动视为足够
    hasLastMousePos = true;
  } else {
    const dx = clientX - lastMouseX;
    const dy = clientY - lastMouseY;
    movedEnough = dx * dx + dy * dy >= MOVE_THRESHOLD_SQ;
  }
  lastMouseX = clientX;
  lastMouseY = clientY;

  if (!movedEnough) {
    // 微小移动，视为无操作，不重置计时器
    return;
  }

  if (timeoutEventHandle) {
    clearTimeout(timeoutEventHandle);
  }

  if (!GUIState.controlsVisibility) {
    dispatch(setVisibility({ component: 'controlsVisibility', visibility: true }));
  }

  timeoutEventHandle = setTimeout(() => {
    if (!webgalStore.getState().GUI.showControls) {
      dispatch(setVisibility({ component: 'controlsVisibility', visibility: false }));
    }
  }, 2000);
}

export const Stage: FC = () => {
  const stageState = useSelector((state: RootState) => state.stage);
  const GUIState = useSelector((state: RootState) => state.GUI);
  const dispatch = useDispatch();

  useHotkey();

  return (
    <div className={styles.MainStage_main}>
      <FullScreenPerform />
      {/* 已弃用旧的立绘与背景舞台 */}
      {/* <OldStage /> */}
      <MainStage />
      <div id="pixiContianer" className={styles.pixiContainer} style={{ zIndex: isIOS ? '-5' : undefined }} />
      <div id="chooseContainer" className={styles.chooseContainer} />
      {GUIState.showTextBox && stageState.enableFilm === '' && !stageState.isDisableTextbox && <TextBox />}
      {GUIState.showTextBox && stageState.enableFilm !== '' && <TextBoxFilm />}
      <AudioContainer />
      <div
        onClick={() => {
          // 如果文本框没有显示，则显示文本框
          if (!GUIState.showTextBox) {
            dispatch(setVisibility({ component: 'showTextBox', visibility: true }));
            return;
          }
          stopAll();
          nextSentence();
        }}
        onDoubleClick={() => {
          WebGAL.events.fullscreenDbClick.emit();
        }}
        id="FullScreenClick"
        style={{ width: '100%', height: '100%', position: 'absolute', zIndex: '12', top: '0' }}
        onMouseMove={(e) => !GUIState.showControls && updateControlsVisibility(e, stageState, GUIState, dispatch)}
      />
      <IntroContainer />
    </div>
  );
};



================================================
FILE: webgal/src/Stage/themeInterface.ts
================================================
export type IWebGalTextBoxTheme = 'standard' | 'imss';



================================================
FILE: webgal/src/Stage/AudioContainer/AudioContainer.tsx
================================================
import { useSelector } from 'react-redux';
import { RootState, webgalStore } from '@/store/store';
import { setStage } from '@/store/stageReducer';
import { useEffect, useState } from 'react';
import { logger } from '@/Core/util/logger';

export const AudioContainer = () => {
  const stageStore = useSelector((webgalStore: RootState) => webgalStore.stage);
  const titleBgm = useSelector((webgalStore: RootState) => webgalStore.GUI.titleBgm);
  const isShowTitle = useSelector((webgalStore: RootState) => webgalStore.GUI.showTitle);
  const userDataState = useSelector((state: RootState) => state.userData);
  const mainVol = userDataState.optionData.volumeMain;
  const vocalVol = mainVol * 0.01 * userDataState.optionData.vocalVolume * 0.01 * stageStore.vocalVolume * 0.01;
  const bgmVol = mainVol * 0.01 * userDataState.optionData.bgmVolume * 0.01 * stageStore.bgm.volume * 0.01;
  const bgmEnter = stageStore.bgm.enter;
  const uiSoundEffects = stageStore.uiSe;
  const seVol = mainVol * 0.01 * (userDataState.optionData?.seVolume ?? 100) * 0.01;
  const uiSeVol = mainVol * 0.01 * (userDataState.optionData.uiSeVolume ?? 50) * 0.01;
  const isEnterGame = useSelector((state: RootState) => state.GUI.isEnterGame);

  // 淡入淡出定时器
  const [fadeTimer, setFadeTimer] = useState(setTimeout(() => {}, 0));

  /**
   * 淡入BGM
   * @param bgm 背景音乐
   * @param maxVol 最大音量
   * @param time 淡入时间
   */
  const bgmFadeIn = (bgm: HTMLAudioElement, maxVol: number, time: number) => {
    // 设置初始音量
    time >= 0 ? (bgm.volume = 0) : (bgm.volume = maxVol);
    // 设置音量递增时间间隔
    const duration = 10;
    // 计算每duration的音量增量
    const volumeStep = (maxVol / time) * duration;
    // 基于递归调用实现淡入淡出效果
    const fade = () => {
      const timer = setTimeout(() => {
        if (bgm.volume + volumeStep >= maxVol) {
          // 如果音量接近或达到最大值，则设置最终音量（淡入）
          bgm.volume = maxVol;
        } else if (bgm.volume + volumeStep <= 0) {
          // 如果音量接近或达到最小值，则设置最终音量（淡出）
          bgm.volume = 0;
          // 淡出效果结束后，将 bgm 置空
          webgalStore.dispatch(setStage({ key: 'bgm', value: { src: '', enter: 0, volume: 100 } }));
        } else {
          // 否则增加音量，并递归调用
          bgm.volume += volumeStep;
          fade();
        }
      }, duration);
      // 将定时器引用存储到 fadeTimer 中
      setFadeTimer(timer);
    };
    // 调用淡入淡出函数
    fade();
  };

  useEffect(() => {
    // 清除之前的淡入淡出定时器
    clearTimeout(fadeTimer);
    // 获取当前背景音乐元素
    const bgmElement = document.getElementById('currentBgm') as HTMLAudioElement;
    // 如果当前背景音乐元素存在，则淡入淡出
    if (bgmElement) {
      bgmEnter === 0 ? (bgmElement.volume = bgmVol) : bgmFadeIn(bgmElement, bgmVol, bgmEnter);
    }
  }, [isShowTitle, titleBgm, stageStore.bgm.src, bgmVol, bgmEnter]);

  useEffect(() => {
    logger.debug(`设置背景音量：${bgmVol}`);
  }, [bgmVol]);

  useEffect(() => {
    logger.debug(`设置背景音量淡入时间: ${bgmEnter}`);
  }, [bgmEnter]);

  useEffect(() => {
    logger.debug(`设置语音音量：${vocalVol}`);
    const vocalElement: any = document.getElementById('currentVocal');
    if (vocalElement) {
      vocalElement.volume = vocalVol.toString();
    }
  }, [vocalVol]);

  useEffect(() => {
    if (uiSoundEffects === '') return;
    const uiSeAudioElement = document.createElement('audio');
    uiSeAudioElement.src = uiSoundEffects;
    uiSeAudioElement.loop = false;
    // 设置音量
    if (!isNaN(uiSeVol)) {
      uiSeAudioElement.volume = uiSeVol;
    } else {
      // 针对原来使用 WebGAL version <= 4.4.2 的用户数据中不存在UI音效音量的情况
      logger.error('UI SE Vol is NaN');
      uiSeAudioElement.volume = isNaN(seVol) ? mainVol / 100 : seVol / 100;
    }
    // 播放UI音效
    uiSeAudioElement.play();
    uiSeAudioElement.addEventListener('ended', () => {
      // Processing after sound effects are played
      uiSeAudioElement.remove();
    });
    webgalStore.dispatch(setStage({ key: 'uiSe', value: '' }));
  }, [uiSoundEffects]);

  useEffect(() => {
    logger.debug(`设置音效音量: ${seVol}`);
  }, [seVol]);

  useEffect(() => {
    logger.debug(`设置用户界面音效音量: ${uiSeVol}`);
  }, [uiSeVol]);

  return (
    <div>
      <audio
        key={isShowTitle.toString() + titleBgm}
        id="currentBgm"
        src={isShowTitle ? titleBgm : stageStore.bgm.src}
        loop={true}
        autoPlay={isEnterGame}
      />
      <audio id="currentVocal" src={stageStore.playVocal} />
    </div>
  );
};



================================================
FILE: webgal/src/Stage/FigureContainer/figureContainer.module.scss
================================================
.FigureContainer_main {
  z-index: 4;
  width: 100%;
  height: 100%;
  position: absolute;
  top: 0;
  display: flex;
}

.figurePic {
  max-height: 100%;
  max-width: 100%;
  width: auto;
  height: auto;
  object-fit: cover;
  animation: centerIn 0.5s ease-in-out forwards;
}

.figContainer {
  width: 98%;
  left: 1%;
  right: 1%;
  position: absolute;
  display: flex;
  top: 5px;
  bottom: 0;
  z-index: 4;
  animation: fig_default_animation 0.3s;
}

.figContainerLeft {
  justify-content: left;
}

.figContainerCenter {
  justify-content: center;
}

.figContainerRight {
  justify-content: right;
}

@keyframes fig_default_animation {
  0% {
    opacity: 0;
  }
  30% {
    opacity: 0;
  }
  100% {
    opacity: 1;
  }
}



================================================
FILE: webgal/src/Stage/FigureContainer/FigureContainer.tsx
================================================
import styles from './figureContainer.module.scss';
import { useSelector } from 'react-redux';
import { RootState } from '@/store/store';

export const FigureContainer = () => {
  const stageState = useSelector((state: RootState) => state.stage);
  return (
    <div className={styles.FigureContainer_main}>
      <div className={styles.figContainerLeft + ' ' + styles.figContainer} id="figLeftContainer">
        {stageState.figNameLeft !== '' && (
          <img className={styles.figurePic} src={stageState.figNameLeft} alt="fig_left" />
        )}
      </div>
      <div className={styles.figContainerCenter + ' ' + styles.figContainer} id="figCenterContainer">
        {stageState.figName !== '' && <img className={styles.figurePic} src={stageState.figName} alt="fig_center" />}
      </div>
      <div className={styles.figContainerRight + ' ' + styles.figContainer} id="figRightContainer">
        {stageState.figNameRight !== '' && (
          <img className={styles.figurePic} src={stageState.figNameRight} alt="fig_right" />
        )}
      </div>
    </div>
  );
};



================================================
FILE: webgal/src/Stage/FullScreenPerform/fullScreenPerform.module.scss
================================================
.FullScreenPerform_main {
  position: absolute;
  width: 100%;
  height: 100%;
  top: 0;
}

.FullScreenPerform_element {
  position: absolute;
  display: none;
  width: 100%;
  height: 100%;
  z-index: 11;
}

.fullScreen_video {
  position: absolute;
  display: block;
  width: 100%;
  height: 100%;
  z-index: 11;
}

@keyframes slideIn {
  0% {
    transform: translateX(-100%);
    opacity: 0;
  }
  100% {
    transform: translateX(0);
    opacity: 1;
  }
}

@keyframes typing {
  from { 
    width: 0; 
    height: 0;
  }
  to { 
    width: 100%; 
    height: auto;
    border-right:1px solid;
  }
}

@keyframes blinkCursor {
  50% { border-color: transparent; }
}

@keyframes pixelateAnimation {
  0% {
    filter: none;
    opacity: 0;
  }
  50% {
    filter: blur(5px);
  }
  100% {
    filter: none;
    opacity: 1;
  }
}

@keyframes revealAnimation {
  0% {
    opacity: 0;
    clip-path: polygon(0% 0%, 0% 0%, 0% 100%, 0% 100%);
  }
  100% {
    opacity: 1;
    clip-path: polygon(0% 0%, 100% 0%, 100% 100%, 0% 100%);
  }
}

.fadeIn {
  opacity: 0;
  animation: intro_showSoftly 1.5s ease-out forwards;
  font-family: "思源宋体", serif;
}

.slideIn {
  opacity: 0;
  animation: slideIn 1.5s forwards;
  font-family: "思源宋体", serif;
}

.typingEffect {
  display: block;
  overflow: hidden;
  white-space: pre-line;
  width: 0;
  animation: typing 1.5s forwards, blinkCursor 1s infinite 1.5s;
  font-family: "思源宋体", serif;
}

.pixelateEffect {
  opacity: 0;
  animation: pixelateAnimation 3s forwards;
  font-family: "思源宋体", serif;
}

.revealAnimation {
  opacity: 0;
  animation: revealAnimation 3s forwards;
  font-family: "思源宋体", serif;
}

@keyframes intro_showSoftly {
  0% {
    opacity: 0;
  }
  100% {
    opacity: 1;
  }
}

.videoContainer {
  position: absolute;
  display: block;
  width: 100%;
  height: 100%;
  z-index: 11;
  background: rgba(0, 0, 0, 1);
}



================================================
FILE: webgal/src/Stage/FullScreenPerform/FullScreenPerform.tsx
================================================
import styles from './fullScreenPerform.module.scss';
import { useSelector } from 'react-redux';
import { RootState } from '@/store/store';

export const FullScreenPerform = () => {
  const stageState = useSelector((state: RootState) => state.stage);
  let stageWidth = '100%';
  let stageHeight = '100%';
  let top = '0';
  if (stageState.enableFilm !== '') {
    stageHeight = '76%';
    top = '12%';
  }
  return (
    <div className={styles.FullScreenPerform_main} style={{ width: stageWidth, height: stageHeight, top: top }}>
      <div id="videoContainer" />
    </div>
  );
};



================================================
FILE: webgal/src/Stage/introContainer/introContainer.module.scss
================================================
.introContainer {
  box-sizing: border-box;
  position: absolute;
  z-index: 11;
  width: 100%;
  height: 100%;
  color: white;
  display: none;
  //z-index: 13;
}



================================================
FILE: webgal/src/Stage/introContainer/IntroContainer.tsx
================================================
import styles from './introContainer.module.scss';

export default function IntroContainer() {
  return <div className={styles.introContainer} id="introContainer" />;
}



================================================
FILE: webgal/src/Stage/MainStage/MainStage.tsx
================================================
import { useSelector } from 'react-redux';
import { RootState } from '@/store/store';
import { useSetBg } from '@/Stage/MainStage/useSetBg';
import { useSetFigure } from '@/Stage/MainStage/useSetFigure';
import { setStageObjectEffects } from '@/Stage/MainStage/useSetEffects';

export function MainStage() {
  const stageState = useSelector((state: RootState) => state.stage);
  useSetBg(stageState);
  useSetFigure(stageState);
  setStageObjectEffects(stageState);
  return <div style={{ display: 'none' }} />;
}



================================================
FILE: webgal/src/Stage/MainStage/useSetBg.ts
================================================
import { IStageState } from '@/store/stageInterface';
import { useEffect } from 'react';
import { logger } from '@/Core/util/logger';
import { IStageObject } from '@/Core/controller/stage/pixi/PixiController';
import { setEbg } from '@/Core/gameScripts/changeBg/setEbg';

import { getEnterExitAnimation } from '@/Core/Modules/animationFunctions';
import { WebGAL } from '@/Core/WebGAL';

export function useSetBg(stageState: IStageState) {
  const bgName = stageState.bgName;

  /**
   * 设置背景
   */
  useEffect(() => {
    const thisBgKey = 'bg-main';
    if (bgName !== '') {
      const currentBg = WebGAL.gameplay.pixiStage?.getStageObjByKey(thisBgKey);
      if (currentBg) {
        if (currentBg.sourceUrl !== bgName) {
          removeBg(currentBg);
        }
      }
      addBg(undefined, thisBgKey, bgName);
      setEbg(bgName);
      logger.debug('重设背景');
      const { duration, animation } = getEnterExitAnimation('bg-main', 'enter', true);
      WebGAL.gameplay.pixiStage!.registerPresetAnimation(animation, 'bg-main-softin', thisBgKey, stageState.effects);
      setTimeout(() => WebGAL.gameplay.pixiStage!.removeAnimationWithSetEffects('bg-main-softin'), duration);
    } else {
      const currentBg = WebGAL.gameplay.pixiStage?.getStageObjByKey(thisBgKey);
      if (currentBg) {
        removeBg(currentBg);
      }
    }
  }, [bgName]);
}

function removeBg(bgObject: IStageObject) {
  WebGAL.gameplay.pixiStage?.removeAnimationWithSetEffects('bg-main-softin');
  const oldBgKey = bgObject.key;
  bgObject.key = 'bg-main-off' + String(new Date().getTime());
  const bgKey = bgObject.key;
  const bgAniKey = bgObject.key + '-softoff';
  WebGAL.gameplay.pixiStage?.removeStageObjectByKey(oldBgKey);
  const { duration, animation } = getEnterExitAnimation('bg-main-off', 'exit', true, bgKey);
  WebGAL.gameplay.pixiStage!.registerAnimation(animation, bgAniKey, bgKey);
  setTimeout(() => {
    WebGAL.gameplay.pixiStage?.removeAnimation(bgAniKey);
    WebGAL.gameplay.pixiStage?.removeStageObjectByKey(bgKey);
  }, duration);
}

function addBg(type?: 'image' | 'spine', ...args: any[]) {
  const url: string = args[1];
  if (['mp4', 'webm', 'mkv'].some((e) => url.toLocaleLowerCase().endsWith(e))) {
    // @ts-ignore
    return WebGAL.gameplay.pixiStage?.addVideoBg(...args);
  } else if (url.toLocaleLowerCase().endsWith('.skel')) {
    // @ts-ignore
    return WebGAL.gameplay.pixiStage?.addSpineBg(...args);
  } else {
    // @ts-ignore
    return WebGAL.gameplay.pixiStage?.addBg(...args);
  }
}



================================================
FILE: webgal/src/Stage/MainStage/useSetEffects.ts
================================================
import { baseTransform, IEffect, IStageState, ITransform } from '@/store/stageInterface';

import { WebGAL } from '@/Core/WebGAL';
import PixiStage from '@/Core/controller/stage/pixi/PixiController';

export function setStageObjectEffects(stageState: IStageState) {
  const effects = stageState.effects;
  setTimeout(() => {
    setStageEffects(effects);
  }, 10);
}

export function setStageEffects(effects: IEffect[]) {
  const stageObjects = WebGAL.gameplay.pixiStage?.getAllStageObj() ?? [];
  for (const stageObj of stageObjects) {
    const key = stageObj.key;
    const effect = effects.find((effect) => effect.target === key);
    const lockedStageTargets = WebGAL.gameplay.pixiStage?.getAllLockedObject() ?? [];
    if (!lockedStageTargets.includes(key)) {
      if (effect) {
        // logger.debug('应用effects', key);
        const targetPixiContainer = WebGAL.gameplay.pixiStage?.getStageObjByKey(key);
        if (targetPixiContainer) {
          const container = targetPixiContainer.pixiContainer;
          // @ts-ignore 没有引入新的子对象
          PixiStage.assignTransform(container, convertTransform(effect.transform));
        }
      } else {
        const targetPixiContainer = WebGAL.gameplay.pixiStage?.getStageObjByKey(key);
        if (targetPixiContainer) {
          const container = targetPixiContainer.pixiContainer;
          // @ts-ignore 没有引入新的子对象
          PixiStage.assignTransform(container, convertTransform(baseTransform));
        }
      }
    }
  }
}

function convertTransform(transform: ITransform | undefined) {
  if (!transform) {
    return {};
  }
  const { position, ...rest } = transform;
  return { ...rest, x: position.x, y: position.y };
}



================================================
FILE: webgal/src/Stage/MainStage/useSetFigure.ts
================================================
import { IEffect, IStageState } from '@/store/stageInterface';
import { useEffect } from 'react';
import { logger } from '@/Core/util/logger';
import { generateUniversalSoftInAnimationObj } from '@/Core/controller/stage/pixi/animations/universalSoftIn';
import { IStageObject } from '@/Core/controller/stage/pixi/PixiController';
import { generateUniversalSoftOffAnimationObj } from '@/Core/controller/stage/pixi/animations/universalSoftOff';

import { getEnterExitAnimation } from '@/Core/Modules/animationFunctions';
import { WebGAL } from '@/Core/WebGAL';

export function useSetFigure(stageState: IStageState) {
  const {
    figNameLeft,
    figName,
    figNameRight,
    freeFigure,
    live2dMotion,
    live2dExpression,
    live2dBlink,
    live2dFocus,
    figureMetaData,
  } = stageState;

  /**
   * 同步 motion
   */
  useEffect(() => {
    for (const motion of live2dMotion) {
      WebGAL.gameplay.pixiStage?.changeModelMotionByKey(motion.target, motion.motion);
    }
  }, [live2dMotion]);

  /**
   * 同步 expression
   */
  useEffect(() => {
    for (const expression of live2dExpression) {
      WebGAL.gameplay.pixiStage?.changeModelExpressionByKey(expression.target, expression.expression);
    }
  }, [live2dExpression]);

  /**
   * 同步 blink
   */
  useEffect(() => {
    for (const blink of live2dBlink) {
      WebGAL.gameplay.pixiStage?.changeModelBlinkByKey(blink.target, blink.blink);
    }
  }, [live2dBlink]);

  /**
   * 同步 focus
   */
  useEffect(() => {
    for (const focus of live2dFocus) {
      WebGAL.gameplay.pixiStage?.changeModelFocusByKey(focus.target, focus.focus);
    }
  }, [live2dFocus]);

  /**
   * 同步元数据
   */
  useEffect(() => {
    Object.entries(figureMetaData).forEach(([key, value]) => {
      const figureObject = WebGAL.gameplay.pixiStage?.getStageObjByKey(key);
      if (figureObject && !figureObject.isExiting && value?.zIndex !== undefined && figureObject.pixiContainer) {
        figureObject.pixiContainer.zIndex = value.zIndex;
      }
    });
  }, [figureMetaData]);

  /**
   * 设置立绘
   */
  useEffect(() => {
    /**
     * 特殊处理：中间立绘
     */
    const thisFigKey = 'fig-center';
    const softInAniKey = 'fig-center-softin';
    if (figName !== '') {
      const currentFigCenter = WebGAL.gameplay.pixiStage?.getStageObjByKey(thisFigKey);
      if (currentFigCenter) {
        if (currentFigCenter.sourceUrl !== figName) {
          removeFig(currentFigCenter, softInAniKey, stageState.effects);
        }
      }
      addFigure(undefined, thisFigKey, figName, 'center');
      logger.debug('中立绘已重设');
      const { duration, animation } = getEnterExitAnimation(thisFigKey, 'enter');
      WebGAL.gameplay.pixiStage!.registerPresetAnimation(animation, softInAniKey, thisFigKey, stageState.effects);
      setTimeout(() => WebGAL.gameplay.pixiStage!.removeAnimationWithSetEffects(softInAniKey), duration);
    } else {
      logger.debug('移除中立绘');
      const currentFigCenter = WebGAL.gameplay.pixiStage?.getStageObjByKey(thisFigKey);
      if (currentFigCenter) {
        if (currentFigCenter.sourceUrl !== figName) {
          removeFig(currentFigCenter, softInAniKey, stageState.effects);
        }
      }
    }
  }, [figName]);

  useEffect(() => {
    /**
     * 特殊处理：左侧立绘
     */
    const thisFigKey = 'fig-left';
    const softInAniKey = 'fig-left-softin';
    if (figNameLeft !== '') {
      const currentFigLeft = WebGAL.gameplay.pixiStage?.getStageObjByKey(thisFigKey);
      if (currentFigLeft) {
        if (currentFigLeft.sourceUrl !== figNameLeft) {
          removeFig(currentFigLeft, softInAniKey, stageState.effects);
        }
      }
      addFigure(undefined, thisFigKey, figNameLeft, 'left');
      logger.debug('左立绘已重设');
      const { duration, animation } = getEnterExitAnimation(thisFigKey, 'enter');
      WebGAL.gameplay.pixiStage!.registerPresetAnimation(animation, softInAniKey, thisFigKey, stageState.effects);
      setTimeout(() => WebGAL.gameplay.pixiStage!.removeAnimationWithSetEffects(softInAniKey), duration);
    } else {
      logger.debug('移除左立绘');
      const currentFigLeft = WebGAL.gameplay.pixiStage?.getStageObjByKey(thisFigKey);
      if (currentFigLeft) {
        if (currentFigLeft.sourceUrl !== figNameLeft) {
          removeFig(currentFigLeft, softInAniKey, stageState.effects);
        }
      }
    }
  }, [figNameLeft]);

  useEffect(() => {
    /**
     * 特殊处理：右侧立绘
     */
    const thisFigKey = 'fig-right';
    const softInAniKey = 'fig-right-softin';
    if (figNameRight !== '') {
      const currentFigRight = WebGAL.gameplay.pixiStage?.getStageObjByKey(thisFigKey);
      if (currentFigRight) {
        if (currentFigRight.sourceUrl !== figNameRight) {
          removeFig(currentFigRight, softInAniKey, stageState.effects);
        }
      }
      addFigure(undefined, thisFigKey, figNameRight, 'right');
      logger.debug('右立绘已重设');
      const { duration, animation } = getEnterExitAnimation(thisFigKey, 'enter');
      WebGAL.gameplay.pixiStage!.registerPresetAnimation(animation, softInAniKey, thisFigKey, stageState.effects);
      setTimeout(() => WebGAL.gameplay.pixiStage!.removeAnimationWithSetEffects(softInAniKey), duration);
    } else {
      const currentFigRight = WebGAL.gameplay.pixiStage?.getStageObjByKey(thisFigKey);
      if (currentFigRight) {
        if (currentFigRight.sourceUrl !== figNameRight) {
          removeFig(currentFigRight, softInAniKey, stageState.effects);
        }
      }
    }
  }, [figNameRight]);

  useEffect(() => {
    // 自由立绘
    for (const fig of freeFigure) {
      /**
       * 特殊处理：自由立绘
       */
      const thisFigKey = `${fig.key}`;
      const softInAniKey = `${fig.key}-softin`;
      /**
       * 非空
       */
      if (fig.name !== '') {
        const currentFigThisKey = WebGAL.gameplay.pixiStage?.getStageObjByKey(thisFigKey);
        if (currentFigThisKey) {
          if (currentFigThisKey.sourceUrl !== fig.name) {
            removeFig(currentFigThisKey, softInAniKey, stageState.effects);
            addFigure(undefined, thisFigKey, fig.name, fig.basePosition);
            logger.debug(`${fig.key}立绘已重设`);
            const { duration, animation } = getEnterExitAnimation(thisFigKey, 'enter');
            WebGAL.gameplay.pixiStage!.registerPresetAnimation(animation, softInAniKey, thisFigKey, stageState.effects);
            setTimeout(() => WebGAL.gameplay.pixiStage!.removeAnimationWithSetEffects(softInAniKey), duration);
          }
        } else {
          addFigure(undefined, thisFigKey, fig.name, fig.basePosition);
          logger.debug(`${fig.key}立绘已重设`);
          const { duration, animation } = getEnterExitAnimation(thisFigKey, 'enter');
          WebGAL.gameplay.pixiStage!.registerPresetAnimation(animation, softInAniKey, thisFigKey, stageState.effects);
          setTimeout(() => WebGAL.gameplay.pixiStage!.removeAnimationWithSetEffects(softInAniKey), duration);
        }
      } else {
        const currentFigThisKey = WebGAL.gameplay.pixiStage?.getStageObjByKey(thisFigKey);
        if (currentFigThisKey) {
          if (currentFigThisKey.sourceUrl !== fig.name) {
            removeFig(currentFigThisKey, softInAniKey, stageState.effects);
          }
        }
      }
    }

    /**
     * 移除不在状态表中的立绘
     */
    const currentFigures = WebGAL.gameplay.pixiStage?.getFigureObjects();
    if (currentFigures) {
      for (const existFigure of currentFigures) {
        if (
          existFigure.key === 'fig-left' ||
          existFigure.key === 'fig-center' ||
          existFigure.key === 'fig-right' ||
          existFigure.key.endsWith('-off')
        ) {
          // 什么也不做
        } else {
          const existKey = existFigure.key;
          const existFigInState = freeFigure.findIndex((fig) => fig.key === existKey);
          if (existFigInState < 0) {
            const softInAniKey = `${existFigure.key}-softin`;
            removeFig(existFigure, softInAniKey, stageState.effects);
          }
        }
      }
    }
  }, [freeFigure]);
}

function removeFig(figObj: IStageObject, enterTikerKey: string, effects: IEffect[]) {
  WebGAL.gameplay.pixiStage?.removeAnimationWithSetEffects(enterTikerKey);
  // 快进，跳过退出动画
  if (WebGAL.gameplay.isFast) {
    logger.debug('快速模式，立刻关闭立绘');
    WebGAL.gameplay.pixiStage?.removeStageObjectByKey(figObj.key);
    return;
  }
  const oldFigKey = figObj.key;
  const figLeaveAniKey = oldFigKey + '-off';
  figObj.key = oldFigKey + String(new Date().getTime()) + '-off';
  const figKey = figObj.key;
  WebGAL.gameplay.pixiStage?.removeStageObjectByKey(oldFigKey);
  const leaveKey = figKey + '-softoff';
  const { duration, animation } = getEnterExitAnimation(figLeaveAniKey, 'exit', false, figKey);
  WebGAL.gameplay.pixiStage!.registerPresetAnimation(animation, leaveKey, figKey, effects);
  setTimeout(() => {
    WebGAL.gameplay.pixiStage?.removeAnimation(leaveKey);
    WebGAL.gameplay.pixiStage?.removeStageObjectByKey(figKey);
  }, duration);
}

function addFigure(type?: 'image' | 'live2D' | 'spine', ...args: any[]) {
  const url = args[1];
  const baseUrl = window.location.origin;
  const urlObject = new URL(url, baseUrl);
  const _type = urlObject.searchParams.get('type') as 'image' | 'live2D' | 'spine' | null;
  if (url.endsWith('.json')) {
    return addLive2dFigure(...args);
  } else if (url.endsWith('.skel') || _type === 'spine') {
    // @ts-ignore
    return WebGAL.gameplay.pixiStage?.addSpineFigure(...args);
  } else {
    // @ts-ignore
    return WebGAL.gameplay.pixiStage?.addFigure(...args);
  }
}

/**
 * 如果要使用 Live2D，取消这里的注释
 * @param args
 */
function addLive2dFigure(...args: any[]) {
  // @ts-ignore
  return WebGAL.gameplay.pixiStage?.addLive2dFigure(...args);
}



================================================
FILE: webgal/src/Stage/OldStage/OldStage.tsx
================================================
// import styles from '@/Components/Stage/stage.module.scss';
// import { FigureContainer } from '@/Components/Stage/FigureContainer/FigureContainer';
// import { useEffect } from 'react';
// import { IEffect } from '@/store/stageInterface';
// import { useSelector } from 'react-redux';
// import { RootState } from '@/store/store';

export default function OldStage() {
  // const stageState = useSelector((state: RootState) => state.stage);
  // const oldBg = useSelector((state: RootState) => state.stageTemp.oldBg);
  // const oldBgKey = useSelector((state: RootState) => state.stageTemp.oldBgKey);
  //
  // /**
  //  * 设置效果
  //  */
  // useEffect(() => {
  //   const effectList: Array<IEffect> = stageState.effects;
  //   setTimeout(() => {
  //     effectList.forEach((effect) => {
  //       const target = document.getElementById(effect.target);
  //       if (target) {
  //         if (effect.filter !== '') {
  //           target.style.filter = effect.filter;
  //         }
  //         if (effect.transform !== '') {
  //           target.style.transform = effect.transform;
  //         }
  //       }
  //     });
  //   }, 100);
  // });
  //
  // let stageWidth = '100%';
  // let stageHeight = '100%';
  // let top = '0';
  // if (stageState.enableFilm !== '') {
  //   stageHeight = '76%';
  //   top = '12%';
  // }
  //
  // return (
  //   <div className={styles.MainStage_main_container} style={{ width: stageWidth, height: stageHeight, top: top }}>
  //     {oldBg !== '' && (
  //       <div
  //         key={'bgOld' + oldBg + oldBgKey}
  //         id="MainStage_bg_OldContainer"
  //         className={styles.MainStage_oldBgContainer}
  //         style={{
  //           backgroundImage: `url("${oldBg}")`,
  //           backgroundSize: 'cover',
  //         }}
  //       />
  //     )}
  //     <div
  //       key={'bgMain' + stageState.bgName}
  //       id="MainStage_bg_MainContainer"
  //       className={styles.MainStage_bgContainer}
  //       style={{
  //         backgroundImage: `url("${stageState.bgName}")`,
  //         backgroundSize: 'cover',
  //       }}
  //     />
  //     <FigureContainer />
  //   </div>
  // );
}



================================================
FILE: webgal/src/Stage/TextBox/IMSSTextbox.tsx
================================================
import styles from './textbox.module.scss';
import { ReactNode, useEffect } from 'react';
import { WebGAL } from '@/Core/WebGAL';
import { ITextboxProps } from './types';
import useApplyStyle from '@/hooks/useApplyStyle';
import { css } from '@emotion/css';
import { textSize } from '@/store/userDataInterface';

export default function IMSSTextbox(props: ITextboxProps) {
  const {
    textArray,
    textDelay,
    currentConcatDialogPrev,
    currentDialogKey,
    isText,
    isSafari,
    isFirefox: boolean,
    fontSize,
    miniAvatar,
    isHasName,
    showName,
    font,
    textDuration,
    isUseStroke,
    textboxOpacity,
    textSizeState,
  } = props;

  const applyStyle = useApplyStyle('Stage/TextBox/textbox.scss');

  useEffect(() => {
    function settleText() {
      const textElements = document.querySelectorAll('.Textelement_start');
      const textArray = [...textElements];
      textArray.forEach((e) => {
        e.className = applyStyle('TextBox_textElement_Settled', styles.TextBox_textElement_Settled);
      });
    }

    WebGAL.events.textSettle.on(settleText);
    return () => {
      WebGAL.events.textSettle.off(settleText);
    };
  }, []);
  let allTextIndex = 0;
  const nameElementList = showName.map((line, index) => {
    const textline = line.map((en, index) => {
      const e = en.reactNode;
      let style = '';
      let tips = '';
      let style_alltext = '';
      let isEnhanced = false;
      if (en.enhancedValue) {
        isEnhanced = true;
        const data = en.enhancedValue;
        for (const dataElem of data) {
          const { key, value } = dataElem;
          switch (key) {
            case 'style':
              style = value;
              break;
            case 'tips':
              tips = value;
              break;
            case 'style-alltext':
              style_alltext = value;
              break;
          }
        }
      }
      const styleClassName = ' ' + css(style, { label: 'showname' });
      const styleAllText = ' ' + css(style_alltext, { label: 'showname' });
      if (isEnhanced) {
        return (
          <span key={index} style={{ position: 'relative' }}>
            <span className={styles.zhanwei + styleAllText}>
              {e}
              <span className={applyStyle('outerName', styles.outerName) + styleClassName + styleAllText}>{e}</span>
              {isUseStroke && <span className={applyStyle('innerName', styles.innerName) + styleAllText}>{e}</span>}
            </span>
          </span>
        );
      }
      return (
        <span key={index} style={{ position: 'relative' }}>
          <span className={styles.zhanwei + styleAllText}>
            {e}
            <span className={applyStyle('outerName', styles.outerName) + styleClassName + styleAllText}>{e}</span>
            {isUseStroke && <span className={applyStyle('innerName', styles.innerName) + styleAllText}>{e}</span>}
          </span>
        </span>
      );
    });
    return (
      <div
        style={{
          wordBreak: isSafari || props.isFirefox ? 'break-all' : undefined,
          display: isSafari ? 'flex' : undefined,
          flexWrap: isSafari ? 'wrap' : undefined,
        }}
        key={`text-line-${index}`}
      >
        {textline}
      </div>
    );
  });
  const textElementList = textArray.map((line, index) => {
    const textLine = line.map((en, index) => {
      const e = en.reactNode;
      let style = '';
      let tips = '';
      let style_alltext = '';
      if (en.enhancedValue) {
        const data = en.enhancedValue;
        for (const dataElem of data) {
          const { key, value } = dataElem;
          switch (key) {
            case 'style':
              style = value;
              break;
            case 'tips':
              tips = value;
              break;
            case 'style-alltext':
              style_alltext = value;
              break;
          }
        }
      }
      // if (e === '<br />') {
      //   return <br key={`br${index}`} />;
      // }
      let delay = allTextIndex * textDelay;
      allTextIndex++;
      let prevLength = currentConcatDialogPrev.length;
      if (currentConcatDialogPrev !== '' && allTextIndex >= prevLength) {
        delay = delay - prevLength * textDelay;
      }
      const styleClassName = ' ' + css(style);
      const styleAllText = ' ' + css(style_alltext);
      if (allTextIndex < prevLength) {
        return (
          <span
            // data-text={e}
            id={`${delay}`}
            className={applyStyle('TextBox_textElement_Settled', styles.TextBox_textElement_Settled)}
            key={currentDialogKey + index}
            style={{ animationDelay: `${delay}ms`, animationDuration: `${textDuration}ms` }}
          >
            <span className={styles.zhanwei + styleAllText}>
              {e}
              <span className={applyStyle('outer', styles.outer) + styleClassName + styleAllText}>{e}</span>
              {isUseStroke && <span className={applyStyle('inner', styles.inner) + styleAllText}>{e}</span>}
            </span>
          </span>
        );
      }
      return (
        <span
          // data-text={e}
          id={`${delay}`}
          className={`${applyStyle('TextBox_textElement_start', styles.TextBox_textElement_start)} Textelement_start`}
          key={currentDialogKey + index}
          style={{ animationDelay: `${delay}ms`, position: 'relative' }}
        >
          <span className={styles.zhanwei + styleAllText}>
            {e}
            <span className={applyStyle('outer', styles.outer) + styleClassName + styleAllText}>{e}</span>
            {isUseStroke && <span className={applyStyle('inner', styles.inner) + styleAllText}>{e}</span>}
          </span>
        </span>
      );
    });
    return (
      <div
        style={{
          wordBreak: isSafari || props.isFirefox ? 'break-all' : undefined,
          display: isSafari ? 'flex' : undefined,
          flexWrap: isSafari ? 'wrap' : undefined,
        }}
        key={`text-line-${index}`}
      >
        {textLine}
      </div>
    );
  });

  const lineHeightCssStr = `line-height: ${textSizeState === textSize.medium ? '2.2em' : '2em'}`;
  const lhCss = css(lineHeightCssStr);

  return (
    <>
      {isText && (
        <div className={styles.TextBox_Container}>
          <div
            className={
              applyStyle('TextBox_main', styles.TextBox_main) +
              ' ' +
              applyStyle('TextBox_Background', styles.TextBox_Background) +
              ' ' +
              (miniAvatar === ''
                ? applyStyle('TextBox_main_miniavatarOff', styles.TextBox_main_miniavatarOff)
                : undefined)
            }
            style={{
              opacity: `${textboxOpacity / 100}`,
            }}
          />
          <div
            id="textBoxMain"
            className={
              applyStyle('TextBox_main', styles.TextBox_main) +
              ' ' +
              (miniAvatar === ''
                ? applyStyle('TextBox_main_miniavatarOff', styles.TextBox_main_miniavatarOff)
                : undefined)
            }
            style={{
              fontFamily: font,
            }}
          >
            <div id="miniAvatar" className={applyStyle('miniAvatarContainer', styles.miniAvatarContainer)}>
              {miniAvatar !== '' && (
                <img className={applyStyle('miniAvatarImg', styles.miniAvatarImg)} alt="miniAvatar" src={miniAvatar} />
              )}
            </div>
            {isHasName && (
              <>
                <div
                  className={
                    applyStyle('TextBox_showName', styles.TextBox_showName) +
                    ' ' +
                    applyStyle('TextBox_ShowName_Background', styles.TextBox_ShowName_Background)
                  }
                  style={{
                    opacity: `${textboxOpacity / 100}`,
                    fontSize: '200%',
                  }}
                >
                  <span style={{ opacity: 0 }}>{nameElementList}</span>
                </div>
                <div
                  className={applyStyle('TextBox_showName', styles.TextBox_showName)}
                  style={{
                    fontSize: '200%',
                  }}
                >
                  {nameElementList}
                </div>
              </>
            )}
            <div
              className={`${lhCss} ${applyStyle('text', styles.text)}`}
              style={{
                fontSize,
                flexFlow: 'column',
                overflow: 'hidden',
                paddingLeft: '0.1em',
                // lineHeight: textSizeState === textSize.medium ? '2.2em' : '2em', // 不加的话上半拼音可能会被截断，同时保持排版整齐
              }}
            >
              {textElementList}
            </div>
          </div>
        </div>
      )}
    </>
  );
}



================================================
FILE: webgal/src/Stage/TextBox/textbox.module.scss
================================================
.TextBox_EventHandler {
  position: absolute;
  width: 100%;
  height: 100%;
  z-index: 6;
  top: 0;
}

@mixin text_shadow_textElement {
  //text-shadow: 0 0 3px rgba(81,168,221,1);
}

$height: 330px;

.TextBox_Container {
  position: absolute;
  z-index: 6;
  bottom: 0;
  width: 100%;
  animation: showSoftly 0.7s ease-out forwards;
}

.TextBox_main {
  z-index: 3;
  position: absolute;
  right: 25px;
  min-height: $height;
  max-height: $height;
  background-blend-mode: darken;
  border-radius: calc($height / 2) 20px 20px calc($height / 2);
  bottom: 20px;
  left: 275px;
  font-weight: bold;
  color: white;
  padding: 1em 50px 70px 200px;
  box-sizing: border-box;
  display: flex;
  flex-flow: column;
  align-items: flex-start;
  letter-spacing: 0.2em;
  transition: left 0.33s;
}

.TextBox_main_miniavatarOff {
  left: 25px;
}

.TextBox_Background {
  z-index: 2;
  background: linear-gradient(rgba(245, 247, 250, 1) 0%, rgba(189, 198, 222, 1) 100%);
}

@keyframes showSoftly {
  0% {
    opacity: 0;
  }

  100% {
    opacity: 1;
  }
}

//.TextBox_textElement {
//  opacity: 0;
//  animation: showSoftly 1000ms forwards;
//}


.TextBox_textElement_start {
  @include text_shadow_textElement;
  position: relative;
  animation: TextDelayShow 1000ms ease-out forwards;
  opacity: 0;
  display: inline-flex;
  align-content: space-between
}


.outer {
  position: absolute;
  left:0;
  top:0;
  white-space: nowrap;
  //background-image: linear-gradient(rgba(255, 255, 255, 1) 0%, rgb(225, 237, 255) 100%);
  background-image: linear-gradient(#0B346E 0%,
    //#f5f7fa 45%,
    #141423 100%);
  //background: rgba(255, 255, 255, 1);
  background-clip: text;
  -webkit-background-clip: text;
  color: transparent;
  z-index: 2;
  display: inline-block;   /* 与文本对齐 */
  vertical-align: middle;  /* 确保注音整体的垂直居中 */
}

.inner {
  white-space: nowrap;
  position: absolute;
  left:0;
  top:0;
  -webkit-text-stroke: 0.1em rgba(255, 255, 255, 1);
  z-index: 1;
  //text-shadow: 2px 2px 5px rgba(0, 0, 0, 0.75);
  display: inline-block;   /* 内层元素同样行内块布局 */
  vertical-align: middle;  /* 确保与外层的对齐一致 */
}

.zhanwei {
  color: transparent;
  white-space: nowrap;
  display: inline-block;    /* 保持行内块布局 */
  vertical-align: baseline; /* 确保文本基线对齐 */
  position: relative;       /* 保持相对定位 */
}

//
//.TextBox_textElement_start::before{
//  animation: TextDelayShow 700ms ease-out forwards;
//  opacity: 0;
//  content:attr(data-text);
//  position: absolute;
//}

.TextBox_textElement_Settled {
  position: relative;
  @include text_shadow_textElement;
  opacity: 1;
  display: inline-flex;
  align-content: space-between
}

//
//.TextBox_textElement_Settled::before{
//  content:attr(data-text);
//  position: absolute;
//  opacity: 1;
//  -webkit-text-stroke: 1px red;
//  z-index: 1;
//}

.TextBox_showName {
  @include text_shadow_textElement;
  font-size: 85%;
  //border-bottom: 3px solid rgb(176, 176, 176);
  //min-width: 25%;
  padding: 0 2em 0 2em;
  //margin: 0 0 0 0;
  position: absolute;
  left: 150px;
  top: -68px;
  height: 80px;
  line-height: 68px;
  //display: flex;
  //align-items: center;
  // background: rgba(11, 52, 110, 0.9);
  border-radius: 40px;
  // border: 4px solid rgba(255, 255, 255, 0.75);
  // box-shadow: 3px 3px 10px rgba(100, 100, 100, 0.5);
  z-index: 3;
  border: 4px solid rgba(255, 255, 255, 0);
}

.TextBox_ShowName_Background {
  z-index: 2;
  background: rgba(11, 52, 110, 1);
  border: 4px solid rgba(255, 255, 255, 0.75);
  box-shadow: 3px 3px 10px rgba(100, 100, 100, 0.5);
}

@keyframes TextDelayShow {
  0% {
    opacity: 0;
  }

  100% {
    opacity: 1;
  }
}

.miniAvatarContainer {
  position: absolute;
  height: 450px;
  width: 450px;
  bottom: 0;
  left: -250px;
  border-radius: 100% 0 0 100%;
  overflow: hidden;
}

.miniAvatarImg {
  max-height: 100%;
  max-width: 100%;
  position: absolute;
  bottom: 0;
  filter: drop-shadow(15px 0 3px rgba(0, 0, 0, 0.5));
}

.nameContainer {
  position: absolute;
  left: 2em;
  top: -3.5em;
}

.outerName {
  position: absolute;
  left: 0;
  top: 0;
  //background-image: linear-gradient(rgba(255, 255, 255, 1) 0%, rgb(225, 237, 255) 100%);
  //background-image: linear-gradient(
  //    #bfd8ff 0%,
  //    //#f5f7fa 45%,
  //    #bfbfc7 100%
  //);
  background: linear-gradient(150deg, rgb(255, 255, 255) 0%, rgb(255, 255, 255) 35%, rgb(165, 212, 228) 100%);
  //background: rgba(255, 255, 255, 1);
  background-clip: text;
  -webkit-background-clip: text;
  color: transparent;
  z-index: 2;
}

.innerName {
  position: absolute;
  left: 0;
  top: 0;
  //-webkit-text-stroke: 0.1em rgba(0, 0, 0, 0.25);
  //-webkit-text-stroke: 0.1em rgba(255, 255, 255, 1);
  z-index: 1;
  //text-shadow: 2px 2px 5px rgba(0, 0, 0, 0.75);
}

.text {
  //line-height: 2em;
  overflow: hidden;
}



================================================
FILE: webgal/src/Stage/TextBox/TextBox.tsx
================================================
import { ReactNode, useEffect, useState } from 'react';
import { useSelector } from 'react-redux';
import { RootState } from '@/store/store';
import { useFontFamily } from '@/hooks/useFontFamily';
import { useTextAnimationDuration, useTextDelay } from '@/hooks/useTextOptions';
import { getTextSize } from '@/UI/getTextSize';
import { match } from '@/Core/util/match';
import { textSize } from '@/store/userDataInterface';
import IMSSTextbox from '@/Stage/TextBox/IMSSTextbox';
import { SCREEN_CONSTANTS } from '@/Core/util/constants';
import useEscape from '@/hooks/useEscape';

const userAgent = navigator.userAgent;
const isFirefox = /firefox/i.test(userAgent);
const isSafari = /^((?!chrome|android).)*safari/i.test(userAgent);

export interface EnhancedNode {
  reactNode: ReactNode;
  enhancedValue?: { key: string; value: string }[];
}

export const TextBox = () => {
  const stageState = useSelector((state: RootState) => state.stage);
  const guiState = useSelector((state: RootState) => state.GUI);
  const userDataState = useSelector((state: RootState) => state.userData);
  const textDelay = useTextDelay(userDataState.optionData.textSpeed);
  const textDuration = useTextAnimationDuration(userDataState.optionData.textSpeed);
  let size = getTextSize(userDataState.optionData.textSize) + '%';
  const font = useFontFamily();
  const isText = stageState.showText !== '' || stageState.showName !== '';
  let textSizeState = userDataState.optionData.textSize;
  if (isText && stageState.showTextSize !== -1) {
    size = getTextSize(stageState.showTextSize) + '%';
    textSizeState = stageState.showTextSize;
  }
  const lineLimit = match(textSizeState)
    .with(textSize.small, () => 3)
    .with(textSize.medium, () => 2)
    .with(textSize.large, () => 2)
    .default(() => 2);
  // 拆字
  const textArray = compileSentence(stageState.showText, lineLimit);
  const isHasName = stageState.showName !== '';
  const showName = compileSentence(stageState.showName, lineLimit);
  const currentConcatDialogPrev = stageState.currentConcatDialogPrev;
  const currentDialogKey = stageState.currentDialogKey;
  const miniAvatar = stageState.miniAvatar;
  const textboxOpacity = userDataState.optionData.textboxOpacity;
  const Textbox = IMSSTextbox;
  const fontOptimization = guiState.fontOptimization;

  const [isShowStroke, setIsShowStroke] = useState(true);

  useEffect(() => {
    if (!fontOptimization) {
      setIsShowStroke(true);
      return;
    }

    const handleResize = () => {
      const targetHeight = SCREEN_CONSTANTS.height;
      const targetWidth = SCREEN_CONSTANTS.width;

      const h = window.innerHeight; // 窗口高度
      const w = window.innerWidth; // 窗口宽度
      const zoomH = h / targetHeight; // 以窗口高度为基准的变换比
      const zoomW = w / targetWidth; // 以窗口宽度为基准的变换比
      const zoomH2 = w / targetHeight; // 竖屏时以窗口高度为基础的变换比
      const zoomW2 = h / targetWidth; // 竖屏时以窗口宽度为基础的变换比
      [zoomH, zoomW, zoomH2, zoomW2].forEach((e) => {
        if (e <= 0.2) {
          setIsShowStroke(false);
        } else {
          setIsShowStroke(true);
        }
      });
    };
    window.addEventListener('resize', handleResize);
    handleResize();
    return () => {
      window.removeEventListener('resize', handleResize);
    };
  }, [fontOptimization]);

  return (
    <Textbox
      textArray={textArray}
      isText={isText}
      textDelay={textDelay}
      showName={showName}
      isHasName={isHasName}
      currentConcatDialogPrev={currentConcatDialogPrev}
      fontSize={size}
      currentDialogKey={currentDialogKey}
      isSafari={isSafari}
      isFirefox={isFirefox}
      miniAvatar={miniAvatar}
      textDuration={textDuration}
      font={font}
      textSizeState={textSizeState}
      lineLimit={lineLimit}
      isUseStroke={isShowStroke}
      textboxOpacity={textboxOpacity}
    />
  );
};

function isCJK(character: string) {
  return !!character.match(/[\u4e00-\u9fa5]|[\u0800-\u4e00]|[\uac00-\ud7ff]/);
}

/**
 * 编译文本拓展语法到增强版节点
 * @param sentence 原始文本
 * @param lineLimit 行数限制
 * @param ignoreLineLimit 是否忽略行数限制
 * @param replace_space_with_nbsp 是否将空格替换为不间断空格
 */
// eslint-disable-next-line max-params
export function compileSentence(
  sentence: string,
  lineLimit: number,
  ignoreLineLimit?: boolean,
  replace_space_with_nbsp = true,
): EnhancedNode[][] {
  // 先拆行
  const lines = sentence.split(/(?<!\\)\|/).map((val: string) => useEscape(val));
  // 对每一行进行注音处理
  const rubyLines = lines.map((line) => parseString(line));
  const nodeLines = rubyLines.map((line) => {
    const ln: EnhancedNode[] = [];
    line.forEach((node, index) => {
      match(node.type)
        .with(SegmentType.String, () => {
          const chars = splitChars(node.value as string, replace_space_with_nbsp);
          // eslint-disable-next-line max-nested-callbacks
          ln.push(...chars.map((c) => ({ reactNode: c })));
        })
        .endsWith(SegmentType.Link, () => {
          const val = node.value as EnhancedValue;
          // 检查是否是注音文本（通过检查是否有ruby值）
          if (val.ruby) {
            // 注音文本作为整体处理
            const enhancedNode = (
              <span className="__enhanced_text" key={val.text + `${index}`}>
                <ruby key={index + val.text}>
                  {val.text}
                  <rt>{val.ruby}</rt>
                </ruby>
              </span>
            );
            ln.push({ reactNode: enhancedNode, enhancedValue: val.values });
          } else {
            // 样式文本逐字处理
            const chars = splitChars(val.text, replace_space_with_nbsp);
            // eslint-disable-next-line max-nested-callbacks
            chars.forEach((char, charIndex) => {
              const enhancedNode = (
                <span className="__enhanced_text" key={val.text + `${index}-${charIndex}`}>
                  {char}
                </span>
              );
              ln.push({ reactNode: enhancedNode, enhancedValue: val.values });
            });
          }
        });
    });
    return ln;
  });
  return nodeLines.slice(0, ignoreLineLimit ? undefined : lineLimit);
}

/**
 * @param sentence
 * @param replace_space_with_nbsp
 */
export function splitChars(sentence: string, replace_space_with_nbsp = true) {
  if (!sentence) return [''];
  const words: string[] = [];
  let word = '';
  let cjkFlag = isCJK(sentence[0]);

  const isPunctuation = (ch: string): boolean => {
    const regex = /[!-\/:-@\[-`{-~\u2000-\u206F\u3000-\u303F\uff00-\uffef]/g;
    return regex.test(ch);
  };

  for (const character of sentence) {
    // if (character === '|') {
    //   if (word) {
    //     words.push(word);
    //     word = '';
    //   }
    //   words.push('<br />');
    //   cjkFlag = false;
    //   continue;
    // }
    if (character === ' ' || character === '\u00a0') {
      // Space
      if (word) {
        words.push(word);
        word = '';
      }
      if (replace_space_with_nbsp) {
        words.push('\u00a0');
      } else words.push(character);
      cjkFlag = false;
    } else if (isCJK(character) && !isPunctuation(character)) {
      if (!cjkFlag && word) {
        words.push(word);
        word = '';
      }
      words.push(character);
      cjkFlag = true;
    } else {
      if (isPunctuation(character)) {
        if (word) {
          // If it is a punctuation and there is a preceding word, add it to the word
          word += character;
          words.push(word);
          word = '';
        } else if (words.length > 0) {
          // If no preceding word in the current iteration, but there are already words in the array, append to the last word
          words[words.length - 1] += character;
        } else {
          // If no preceding word, still add the punctuation as a new word
          words.push(character);
        }
        continue;
      }

      if (cjkFlag && word) {
        words.push(word);
        word = '';
      }
      word += character;
      cjkFlag = false;
    }
  }

  if (word) {
    words.push(word);
  }

  return words;
}

enum SegmentType {
  String = 'SegmentType.String',
  Link = 'SegmentType.Link',
}

interface EnhancedValue {
  text: string;
  ruby: string;
  values: { key: string; value: string }[];
}

interface Segment {
  type: SegmentType;
  value?: string | EnhancedValue;
}

function parseString(input: string): Segment[] {
  const regex = /(\[(.*?)\]\((.*?)\))|([^\[\]]+)/g;
  const result: Segment[] = [];
  let match: RegExpExecArray | null;

  while ((match = regex.exec(input)) !== null) {
    if (match[1]) {
      // 链接部分
      const text = match[2];
      const enhance = match[3];
      let parsedEnhanced: KeyValuePair[] = [];
      let ruby = '';
      if (enhance.match(/style=|tips=|ruby=|style-alltext=/)) {
        parsedEnhanced = parseEnhancedString(enhance);
        const rubyKvPair = parsedEnhanced.find((e) => e.key === 'ruby');
        if (rubyKvPair) {
          ruby = rubyKvPair.value;
        }
      } else {
        ruby = enhance;
      }
      result.push({ type: SegmentType.Link, value: { text, ruby, values: parsedEnhanced } });
    } else {
      // 普通文本
      const text = match[0];
      result.push({ type: SegmentType.String, value: text });
    }
  }

  // 我也不知道为什么，不加这个就会导致在 Enhanced Value 处于行首时故障
  // 你可以认为这个代码不明所以，但是不要删除
  result.unshift({ type: SegmentType.String, value: '' });
  return result;
}

interface KeyValuePair {
  key: string;
  value: string;
}

function parseEnhancedString(enhanced: string): KeyValuePair[] {
  const result: KeyValuePair[] = [];
  const regex = /(\S+)=(.*?)(?=\s+\S+=|\s*$)/g;
  let match: RegExpExecArray | null;

  while ((match = regex.exec(enhanced)) !== null) {
    result.push({
      key: match[1],
      value: match[2].replace(/~/g, ':').trim(),
    });
  }

  return result;
}



================================================
FILE: webgal/src/Stage/TextBox/textboxFilm.module.scss
================================================
.TextBox_EventHandler {
  position: absolute;
  width: 100%;
  height: 100%;
  z-index: 6;
  top: 0;
}

.TextBox_main {
  font-family: "思源宋体", serif;
  font-style: italic;
  position: absolute;
  z-index: 6;
  width: 100%;
  height: 12%;
  //background: linear-gradient(transparent,
  //    rgba(0, 0, 0, .25) 25%,
  //    rgba(0, 0, 0, .35) 75%,
  //    rgba(0, 0, 0, .6)),
  //linear-gradient(90deg, transparent 0,
  //        rgba(0, 0, 0, .35) 25%,
  //        rgba(0, 0, 0, .35) 75%,
  //        transparent);
  background-color: black;
  bottom: 0;
  color: white;
  //padding: 1em 18em 2em 18em;
  box-sizing: border-box;
  overflow: hidden;
  display: flex;
  flex-flow: column;
  align-items: center;
  animation: showSoftly 0.7s ease-out forwards;
  letter-spacing: 0.2em;
  justify-content: center;
}

@keyframes showSoftly {
  0% {
    opacity: 0;
  }
  100% {
    opacity: 1;
  }
}

.TextBox_textElement {
  opacity: 0;
  animation: showSoftly 1000ms forwards;
}

.TextBox_textElement_start {
  animation: TextDelayShow 700ms ease-out forwards;
  opacity: 0;
}

.TextBox_textElement_Settled {
  opacity: 1;
}

.TextBox_showName {
  font-size: 85%;
  border-bottom: 2px solid rgba(255, 255, 255, 0.3);
  min-width: 50%;
  padding: 0 0.2em 0.2em 0.3em;
  margin: 0 0 0.2em 0;
}

@keyframes TextDelayShow {
  0% {
    opacity: 0;
  }
  100% {
    opacity: 1;
  }
}

.miniAvatarContainer {
  position: absolute;
  height: 80%;
  width: 17%;
  bottom: 0;
  left: 0.5em;
}

.miniAvatarImg {
  max-height: 100%;
  max-width: 100%;
  position: absolute;
  bottom: 0;
}



================================================
FILE: webgal/src/Stage/TextBox/TextBoxFilm.tsx
================================================
import styles from './textboxFilm.module.scss';
import { useEffect } from 'react';
import { useSelector } from 'react-redux';
import { RootState } from '@/store/store';

import { PERFORM_CONFIG } from '@/config';

export const TextBoxFilm = () => {
  const stageState = useSelector((state: RootState) => state.stage);
  const userDataState = useSelector((state: RootState) => state.userData);
  useEffect(() => {});
  const textDelay = PERFORM_CONFIG.textInitialDelay - 20 * userDataState.optionData.textSpeed;
  const size = userDataState.optionData.textSize * 50 + 200 + '%';

  // 拆字
  const textArray: Array<string> = stageState.showText.split('');
  const textElementList = textArray.map((e, index) => {
    let delay = index * textDelay;
    let prevLength = stageState.currentConcatDialogPrev.length;
    if (stageState.currentConcatDialogPrev !== '' && index >= prevLength) {
      delay = delay - prevLength * textDelay;
    }
    if (index < prevLength) {
      return (
        <span
          id={`${delay}`}
          className={styles.TextBox_textElement_Settled}
          key={stageState.currentDialogKey + index}
          style={{ animationDelay: `${delay}ms` }}
        >
          {e}
        </span>
      );
    }
    return (
      <span
        id={`${delay}`}
        className={styles.TextBox_textElement_start}
        key={stageState.currentDialogKey + index}
        style={{ animationDelay: `${delay}ms` }}
      >
        {e}
      </span>
    );
  });
  return (
    <div id="textBoxMain" className={styles.TextBox_main}>
      {/* <div id="miniAvatar" className={styles.miniAvatarContainer}> */}
      {/*   {stageState.miniAvatar !== '' && */}
      {/*     <img className={styles.miniAvatarImg} alt="miniAvatar" src={stageState.miniAvatar}/>} */}
      {/* </div> */}
      {/* {stageState.showName !== '' && */}
      {/*   <div className={styles.TextBox_showName} style={{fontSize: '200%'}}>{stageState.showName}</div>} */}
      <div style={{ fontSize: size }}>{textElementList}</div>
    </div>
  );
};



================================================
FILE: webgal/src/Stage/TextBox/types.ts
================================================
import { EnhancedNode } from '@/Stage/TextBox/TextBox';

export interface ITextboxProps {
  textArray: EnhancedNode[][];
  textDelay: number;
  currentConcatDialogPrev: string;
  currentDialogKey: string;
  isText: boolean;
  isSafari: boolean;
  isFirefox: boolean;
  fontSize: string;
  miniAvatar: string;
  showName: EnhancedNode[][];
  isHasName: boolean;
  font: string;
  textDuration: number;
  textSizeState: number;
  lineLimit: number;
  isUseStroke: boolean;
  textboxOpacity: number;
}



================================================
FILE: webgal/src/Stage/TextBox/legacy-themes/legacy-standard/standard.module.scss
================================================
.TextBox_EventHandler {
  position: absolute;
  width: 100%;
  height: 100%;
  z-index: 6;
  top: 0;
}

@mixin text_shadow_textElement {
  //text-shadow: 0 0 3px rgba(81,168,221,1);
}

$height: 430px;

.TextBox_main {
  position: absolute;
  z-index: 6;
  right: 0;
  bottom: 0;
  left: 0;
  min-height: $height;
  max-height: $height;
  // background: linear-gradient(transparent, rgba(0, 0, 0, .25) 25%, rgba(0, 0, 0, .35) 75%, rgba(0, 0, 0, .6)),
  // linear-gradient(90deg, transparent 0, rgba(0, 0, 0, .35) 25%, rgba(0, 0, 0, .35) 75%, transparent);
  //background-blend-mode: darken;
  font-weight: bold;
  padding: 30px 50px 100px 200px;
  box-sizing: border-box;
  display: flex;
  flex-flow: column;
  align-items: flex-start;
  animation: showSoftly 0.7s ease-out forwards;
  letter-spacing: 0.2em;
  //backdrop-filter: blur(2px);
  transition: left 0.33s, padding-left 0.33s;
}

.TextBox_showName {
  @include text_shadow_textElement;
  font-size: 85%;
  min-width: 25%;
  height: 70px;
  //display: flex;
  //align-items: center;
  transition: left 0.33s;
  border-bottom: 3px solid rgba(255, 255, 255, 0.8);
}

@keyframes showSoftly {
  0% {
    opacity: 0;
  }

  100% {
    opacity: 1;
  }
}

.TextBox_textElement_start {
  @include text_shadow_textElement;
  position: relative;
  animation: TextDelayShow 1000ms ease-out forwards;
  opacity: 0;
}

.outer {
  position: absolute;
  white-space: nowrap;
  left: 0;
  top: 0;
  background-image: linear-gradient( //135deg,
      #ffffff 0%,
      #f5f7fa 45%,
      #c3cfe2 100%);
  background-clip: text;
  -webkit-background-clip: text;
  color: transparent;
  z-index: 2;
}

.inner {
  white-space: nowrap;
  position: absolute;
  left: 0;
  top: 0;
  -webkit-text-stroke: 0.085em rgba(0, 0, 0, 0.35);
  z-index: 1;
}

.zhanwei {
  color: transparent;
  white-space: nowrap;
}


.TextBox_textElement_Settled {
  position: relative;
  @include text_shadow_textElement;
  opacity: 1;
}

@keyframes TextDelayShow {
  0% {
    opacity: 0;
  }

  100% {
    opacity: 1;
  }
}

.miniAvatarContainer {
  position: absolute;
  height: 450px;
  width: 450px;
  bottom: 0;
  left: 0;
  //border-radius: 100% 0 0 100%;
  overflow: hidden;
}

.miniAvatarImg {
  max-height: 100%;
  max-width: 100%;
  position: absolute;
  bottom: 0;
  filter: drop-shadow(15px 0 3px rgba(0, 0, 0, 0.5));
}

.nameContainer {
  position: absolute;
  left: 2em;
  top: -3.5em;
}

.outerName {
  position: absolute;
  left: 0;
  top: 0;
  background: linear-gradient(150deg, rgb(255, 255, 255) 0%, rgb(255, 255, 255) 35%, rgb(165, 212, 228) 100%);
  background-clip: text;
  -webkit-background-clip: text;
  color: transparent;
  z-index: 2;
}

.innerName {
  position: absolute;
  left: 0;
  top: 0;
  z-index: 1;
}

.text {
  line-height: 1.9em;
  display: -webkit-box;
  -webkit-box-orient: vertical;
  //-webkit-line-clamp: 2;
  overflow: hidden;
}


================================================
FILE: webgal/src/Stage/TextBox/legacy-themes/legacy-standard/StandardTextbox.tsx
================================================
import styles from './standard.module.scss';
import { textSize } from '@/store/userDataInterface';
import { ReactNode, useEffect } from 'react';
import { WebGAL } from '@/Core/WebGAL';
import { ITextboxProps } from '@/Stage/TextBox/types';

export default function StandardTextbox(props: ITextboxProps) {
  const {
    textArray,
    textDelay,
    currentConcatDialogPrev,
    currentDialogKey,
    isText,
    isSafari,
    isFirefox,
    fontSize,
    miniAvatar,
    isHasName,
    showName,
    font,
    textDuration,
    textSizeState,
    isUseStroke,
    textboxOpacity,
  } = props;

  const isHasMiniAvatar = miniAvatar !== '';

  useEffect(() => {
    function settleText() {
      const textElements = document.querySelectorAll('.Textelement_start');
      const textArray = [...textElements];
      textArray.forEach((e) => {
        e.className = styles.TextBox_textElement_Settled;
      });
    }
    WebGAL.events.textSettle.on(settleText);
    return () => {
      WebGAL.events.textSettle.off(settleText);
    };
  }, []);
  const nameElementList = showName.map((e, index) => {
    let prevLength = currentConcatDialogPrev.length;
    if (index < prevLength) {
      return (
        <span key={currentDialogKey + index} className={styles.zhanwei}>
          {e}
          <span className={styles.outer}>{e}</span>
          {isUseStroke && <span className={styles.inner}>{e}</span>}
        </span>
      );
    }
    return (
      <span key={currentDialogKey + index} className={styles.zhanwei}>
        {e}
        <span className={styles.outer}>{e}</span>
        {isUseStroke && <span className={styles.inner}>{e}</span>}
      </span>
    );
  });
  const textElementList = textArray.map((e, index) => {
    // if (e === '<br />') {
    //   return <br key={`br${index}`} />;
    // }
    let delay = index * textDelay;
    let prevLength = currentConcatDialogPrev.length;
    if (currentConcatDialogPrev !== '' && index >= prevLength) {
      delay = delay - prevLength * textDelay;
    }
    if (index < prevLength) {
      return (
        <span
          // data-text={e}
          id={`${delay}`}
          className={styles.TextBox_textElement_Settled}
          key={currentDialogKey + index}
          style={{ animationDelay: `${delay}ms`, animationDuration: `${textDuration}ms` }}
        >
          <span className={styles.zhanwei}>
            {e}
            <span className={styles.outer}>{e}</span>
            {isUseStroke && <span className={styles.inner}>{e}</span>}
          </span>
        </span>
      );
    }
    return (
      <span
        // data-text={e}
        id={`${delay}`}
        className={`${styles.TextBox_textElement_start} Textelement_start`}
        key={currentDialogKey + index}
        style={{ animationDelay: `${delay}ms`, position: 'relative' }}
      >
        <span className={styles.zhanwei}>
          {e}
          <span className={styles.outer}>{e}</span>
          {isUseStroke && <span className={styles.inner}>{e}</span>}
        </span>
      </span>
    );
  });

  const padding = isHasMiniAvatar ? 500 : undefined;
  let paddingTop = isHasName ? undefined : 15;
  if (textSizeState === textSize.small && !isHasName) {
    paddingTop = 35;
  }

  return (
    <>
      {isText && (
        <div
          id="textBoxMain"
          className={styles.TextBox_main}
          style={{
            fontFamily: font,
            paddingLeft: padding,
            paddingTop,
            background: `linear-gradient(
                transparent,
                rgba(0, 0, 0, ${textboxOpacity / 100 / 2}) 25%,
                rgba(0, 0, 0, ${textboxOpacity / 100 / 2}) 75%,
                rgba(0, 0, 0, ${textboxOpacity / 100})),
              linear-gradient(
                90deg, transparent 0,
                rgba(0, 0, 0, ${textboxOpacity / 100 / 2}) 25%,
                rgba(0, 0, 0, ${textboxOpacity / 100}) 75%, transparent)`,
          }}
        >
          {/* <div className={styles.nameContainer}>{stageState.showName !== ''}</div> */}
          <div id="miniAvatar" className={styles.miniAvatarContainer}>
            {miniAvatar !== '' && <img className={styles.miniAvatarImg} alt="miniAvatar" src={miniAvatar} />}
          </div>
          {isHasName && (
            <div className={styles.TextBox_showName} style={{ fontSize: '170%', left: padding }}>
              {nameElementList}
            </div>
          )}
          <div
            className={styles.text}
            style={{
              fontSize,
              wordBreak: isSafari || isFirefox ? 'break-all' : undefined,
              display: isSafari ? 'flex' : undefined,
              flexWrap: isSafari ? 'wrap' : undefined,
              overflow: 'hidden',
              paddingLeft: '0.1em',
              WebkitLineClamp: props.lineLimit,
            }}
          >
            {textElementList}
          </div>
        </div>
      )}
    </>
  );
}



================================================
FILE: webgal/src/store/guiInterface.ts
================================================
import { IWebGalTextBoxTheme } from '@/Stage/themeInterface';

/**
 * 当前Menu页面显示的Tag
 */
export enum MenuPanelTag {
  Save, // “保存”选项卡
  Load, // “读取”选项卡
  Option, // “设置”选项卡
}

/**
 * @interface IGuiState GUI状态接口
 */
export interface IGuiState {
  showStarter: boolean; // 是否显示初始界面（用于使得bgm可以播放)
  showTitle: boolean; // 是否显示标题界面
  showMenuPanel: boolean; // 是否显示Menu界面
  showTextBox: boolean;
  showControls: boolean;
  controlsVisibility: boolean;
  currentMenuTag: MenuPanelTag; // 当前Menu界面的选项卡
  showBacklog: boolean;
  titleBgm: string; // 标题背景音乐
  titleBg: string; // 标题背景图片
  logoImage: string[];
  showExtra: boolean;
  showGlobalDialog: boolean;
  showPanicOverlay: boolean;
  isEnterGame: boolean;
  isShowLogo: boolean;
  enableAppreciationMode: boolean; // Pc102
  fontOptimization: boolean; // 字体优化
}

export type componentsVisibility = Pick<
  IGuiState,
  Exclude<keyof IGuiState, 'currentMenuTag' | 'titleBg' | 'titleBgm' | 'logoImage' | 'theme'>
>;
// 标题资源
export type GuiAsset = Pick<IGuiState, 'titleBgm' | 'titleBg'>;

export interface IGuiStore {
  GuiState: IGuiState;
  setGuiAsset: <K extends keyof GuiAsset>(key: K, value: string) => void;
  setVisibility: <K extends keyof componentsVisibility>(key: K, value: boolean) => void;
  setMenuPanelTag: (value: MenuPanelTag) => void;
}

export interface setVisibilityPayload {
  component: keyof componentsVisibility;
  visibility: boolean;
}

export interface setAssetPayload {
  asset: keyof GuiAsset;
  value: string;
}

export type GuiStore = IGuiStore;



================================================
FILE: webgal/src/store/GUIReducer.ts
================================================
/**
 * @file 记录当前GUI的状态信息，引擎初始化时会重置。
 * @author Mahiru
 */
import { getStorage } from '@/Core/controller/storage/storageController';
import { GuiAsset, IGuiState, MenuPanelTag, setAssetPayload, setVisibilityPayload } from '@/store/guiInterface';
import { createSlice, PayloadAction } from '@reduxjs/toolkit';
import { key } from 'localforage';

/**
 * 初始GUI状态表
 */
const initState: IGuiState = {
  showBacklog: false,
  showStarter: true,
  showTitle: true,
  showMenuPanel: false,
  showTextBox: true,
  showControls: true,
  controlsVisibility: true,
  currentMenuTag: MenuPanelTag.Option,
  titleBg: '',
  titleBgm: '',
  logoImage: [],
  showExtra: false,
  showGlobalDialog: false,
  showPanicOverlay: false,
  isEnterGame: false,
  isShowLogo: true,
  enableAppreciationMode: false, // Paf87
  fontOptimization: false,
};

/**
 * GUI状态的Reducer
 */
const GUISlice = createSlice({
  name: 'gui',
  initialState: initState,
  reducers: {
    /**
     * 设置GUI的各组件的显示状态
     * @param state 当前GUI状态
     * @param action 改变显示状态的Action
     */
    setVisibility: (state, action: PayloadAction<setVisibilityPayload>) => {
      getStorage();
      const { component, visibility } = action.payload;
      state[component] = visibility;
    },
    /**
     * 设置MenuPanel的当前选中项
     * @param state 当前GUI状态
     * @param action 改变当前选中项的Action
     */
    setMenuPanelTag: (state, action: PayloadAction<MenuPanelTag>) => {
      getStorage();
      state.currentMenuTag = action.payload;
    },
    /**
     * 设置GUI资源的值
     * @param state 当前GUI状态
     * @param action 改变资源的Action
     */
    setGuiAsset: (state, action: PayloadAction<setAssetPayload>) => {
      const { asset, value } = action.payload;
      state[asset] = value;
    },
    setLogoImage: (state, action: PayloadAction<string[]>) => {
      state.logoImage = [...action.payload];
    },
    /**
     * 设置 enableAppreciationMode 属性
     * @param state 当前GUI状态
     * @param action 改变 enableAppreciationMode 属性的Action
     */
    setEnableAppreciationMode: (state, action: PayloadAction<boolean>) => {
      state.enableAppreciationMode = action.payload;
    },
    setFontOptimization: (state, action: PayloadAction<boolean>) => {
      state.fontOptimization = action.payload;
    },
  },
});

export const {
  setVisibility,
  setMenuPanelTag,
  setGuiAsset,
  setLogoImage,
  setEnableAppreciationMode,
  setFontOptimization,
} = GUISlice.actions;
export default GUISlice.reducer;

// export function GuiStateStore(): GuiStore {
//     const [GuiState, setGuiState] = useState(initState);
//     /**
//      * 设置各组件的可见性
//      * @param key 设置的组件
//      * @param value 可见性，true or false
//      */
//     const setVisibility = <K extends keyof componentsVisibility>(key: K, value: boolean) => {
//
//         setGuiState(state => {
//             getStorage();
//             state[key] = value;
//             if (key === 'showMenuPanel' || key === 'showBacklog') {
//                 state['showTextBox'] = !value;
//             }
//             return {...state};
//         });
//
//     };
//
//     /**
//      * 设置Menu组件显示的标签页
//      * @param value 标签页
//      */
//     const setMenuPanelTag = (value: MenuPanelTag) => {
//
//         setGuiState(state => {
//             getStorage();
//             state.currentMenuTag = value;
//             return {...state};
//         });
//
//     };
//
//     /**
//      * 设置标题页的资源路径
//      * @param key 资源名
//      * @param value 资源路径
//      */
//     const setGuiAsset = <K extends keyof GuiAsset>(key: K, value: string) => {
//
//         setGuiState(state => {
//             state[key] = value;
//             return {...state};
//         });
//
//     };
//
//     return {
//         GuiState,
//         setGuiAsset,
//         setVisibility,
//         setMenuPanelTag,
//     };
// }



================================================
FILE: webgal/src/store/savesReducer.ts
================================================
import { ISaveData } from './userDataInterface';
import { createSlice, PayloadAction } from '@reduxjs/toolkit';
import cloneDeep from 'lodash/cloneDeep';

export interface ISavesData {
  saveData: Array<ISaveData>; // 用户存档数据
  quickSaveData: ISaveData | null;
}

const initState: ISavesData = {
  saveData: [],
  quickSaveData: null,
};

interface SaveAction {
  saveData: ISaveData;
  index: number;
}

const saveDataSlice = createSlice({
  name: 'saveData',
  initialState: cloneDeep(initState),
  reducers: {
    setFastSave: (state, action: PayloadAction<ISaveData | null>) => {
      state.quickSaveData = action.payload;
    },
    resetFastSave: (state) => {
      state.quickSaveData = null;
    },
    resetSaves: (state) => {
      state.quickSaveData = null;
      state.saveData = [];
    },
    saveGame: (state, action: PayloadAction<SaveAction>) => {
      state.saveData[action.payload.index] = action.payload.saveData;
    },
    replaceSaveGame: (state, action: PayloadAction<ISaveData[]>) => {
      state.saveData = action.payload;
    },
  },
});

export const saveActions = saveDataSlice.actions;

export default saveDataSlice.reducer;



================================================
FILE: webgal/src/store/stageInterface.ts
================================================
import { ISentence } from '@/Core/controller/scene/sceneInterface';
import { BlinkParam, FocusParam } from '@/Core/live2DCore';

/**
 * 游戏内变量
 * @interface IGameVar
 */
export interface IGameVar {
  [propName: string]: string | boolean | number | Array<string | boolean | number>;
}

export interface ISetGameVar {
  key: string;
  value: string | boolean | number;
}

/**
 * 单个选项
 * @interface IChooseItem
 */
export interface IChooseItem {
  key: string; // 选项名称
  targetScene: string; // 选项target
  isSubScene: boolean; // 是否是子场景调用
}

export interface ITransform {
  alpha: number;
  scale: {
    x: number;
    y: number;
  };
  // pivot: {
  //   x: number;
  //   y: number;
  // };
  position: {
    x: number;
    y: number;
  };
  rotation: number;
  blur: number;
  brightness: number;
  contrast: number;
  saturation: number;
  gamma: number;
  colorRed: number;
  colorGreen: number;
  colorBlue: number;
  bevel: number;
  bevelThickness: number;
  bevelRotation: number;
  bevelSoftness: number;
  bevelRed: number;
  bevelGreen: number;
  bevelBlue: number;
  bloom: number;
  bloomBrightness: number;
  bloomBlur: number;
  bloomThreshold: number;
  shockwaveFilter: number;
  radiusAlphaFilter: number;
}

/**
 * 基本效果接口
 * @interface IEffect
 */
export interface IEffect {
  target: string; // 作用目标
  transform?: ITransform; // 变换
}

/**
 * 基本变换预设
 */
export const baseTransform: ITransform = {
  alpha: 1,
  scale: {
    x: 1,
    y: 1,
  },
  // pivot: {
  //   x: 0.5,
  //   y: 0.5,
  // },
  position: {
    x: 0,
    y: 0,
  },
  rotation: 0,
  blur: 0,
  brightness: 1,
  contrast: 1,
  saturation: 1,
  gamma: 1,
  colorRed: 255,
  colorGreen: 255,
  colorBlue: 255,
  bevel: 0,
  bevelThickness: 0,
  bevelRotation: 0,
  bevelSoftness: 0,
  bevelRed: 255,
  bevelGreen: 255,
  bevelBlue: 255,
  bloom: 0,
  bloomBrightness: 1,
  bloomBlur: 0,
  bloomThreshold: 0,
  shockwaveFilter: 0,
  radiusAlphaFilter: 0,
};

export interface IFreeFigure {
  basePosition: 'left' | 'center' | 'right';
  name: string;
  key: string;
}

export interface IFigureAssociatedAnimation {
  mouthAnimation: IMouthAnimationFile;
  blinkAnimation: IEyesAnimationFile;
  targetId: string;
  animationFlag: string;
}

export interface IMouthAnimationFile {
  open: string;
  close: string;
  halfOpen: string;
}

export interface IEyesAnimationFile {
  open: string;
  close: string;
}

/**
 * 启动演出接口
 * @interface IRunPerform
 */
export interface IRunPerform {
  id: string;
  isHoldOn: boolean; // 演出类型
  script: ISentence; // 演出脚本
}

export interface ILive2DMotion {
  target: string;
  motion: string;
  overrideBounds?: [number, number, number, number];
}

export interface ILive2DExpression {
  target: string;
  expression: string;
}

export interface ILive2DBlink {
  target: string;
  blink: BlinkParam;
}

export interface ILive2DFocus {
  target: string;
  focus: FocusParam;
}

export interface IFigureMetadata {
  zIndex?: number;
}

type figureMetaData = Record<string, IFigureMetadata>;

/**
 * @interface IStageState 游戏舞台数据接口
 */
export interface IStageState {
  oldBgName: string; // 旧背景的文件路径
  bgName: string; // 背景文件地址（相对或绝对）
  figName: string; // 立绘_中 文件地址（相对或绝对）
  figNameLeft: string; // 立绘_左 文件地址（相对或绝对）
  figNameRight: string; // 立绘_右 文件地址（相对或绝对）
  // 自由立绘
  freeFigure: Array<IFreeFigure>;
  figureAssociatedAnimation: Array<IFigureAssociatedAnimation>;
  showText: string; // 文字
  showTextSize: number; // 文字
  showName: string; // 人物名
  command: string; // 语句指令
  choose: Array<IChooseItem>; // 选项列表
  vocal: string; // 语音 文件地址（相对或绝对）
  playVocal: string; // 真实播放语音
  vocalVolume: number; // 语音 音量调整（0 - 100）
  bgm: {
    // 背景音乐
    src: string; // 背景音乐 文件地址（相对或绝对）
    enter: number; // 背景音乐 淡入或淡出的毫秒数
    volume: number; // 背景音乐 音量调整（0 - 100）
  };
  uiSe: string; // 用户界面音效 文件地址（相对或绝对）
  miniAvatar: string; // 小头像 文件地址（相对或绝对）
  GameVar: IGameVar; // 游戏内变量
  effects: Array<IEffect>; // 应用的变换
  bgTransform: string;
  bgFilter: string;
  PerformList: Array<IRunPerform>; // 要启动的演出列表
  currentDialogKey: string; // 当前对话的key
  live2dMotion: ILive2DMotion[];
  live2dExpression: ILive2DExpression[];
  live2dBlink: ILive2DBlink[];
  live2dFocus: ILive2DFocus[];
  // 当前演出的延迟，用于做对话插演出！
  // currentPerformDelay:number
  currentConcatDialogPrev: string;
  // 测试：电影叙事
  enableFilm: string;
  isDisableTextbox: boolean;
  replacedUIlable: Record<string, string>;
  figureMetaData: figureMetaData;
}

/**
 * @interface ISetStagePayload 设置舞台状态的Action的Payload的数据接口
 */
export interface ISetStagePayload {
  key: keyof IStageState;
  value: any;
}

export interface IStageStore {
  stageState: IStageState;
  setStage: <K extends keyof IStageState>(key: K, value: any) => void;
  getStageState: () => IStageState;
  restoreStage: (newState: IStageState) => void;
}

export type StageStore = IStageStore;



================================================
FILE: webgal/src/store/stageReducer.ts
================================================
/**
 * 所有会被Save和Backlog记录下的信息，构成当前的舞台状态（也包括游戏运行时变量）
 * 舞台状态是演出结束后的“终态”，在读档时不发生演出，只是将舞台状态替换为读取的状态。
 */

import {
  baseTransform,
  IEffect,
  IFigureMetadata,
  IFreeFigure,
  ILive2DBlink,
  ILive2DExpression,
  ILive2DFocus,
  ILive2DMotion,
  IRunPerform,
  ISetGameVar,
  ISetStagePayload,
  IStageState,
} from '@/store/stageInterface';
import { createSlice, PayloadAction } from '@reduxjs/toolkit';
import cloneDeep from 'lodash/cloneDeep';
import { commandType } from '@/Core/controller/scene/sceneInterface';
import { STAGE_KEYS } from '@/Core/constants';

// 初始化舞台数据

export const initState: IStageState = {
  oldBgName: '',
  bgName: '', // 背景文件地址（相对或绝对）
  figName: '', // 立绘_中 文件地址（相对或绝对）
  figNameLeft: '', // 立绘_左 文件地址（相对或绝对）
  figNameRight: '', // 立绘_右 文件地址（相对或绝对）
  freeFigure: [],
  figureAssociatedAnimation: [],
  showText: '', // 文字
  showTextSize: -1,
  showName: '', // 人物名
  command: '', // 语句指令
  choose: [], // 选项列表，现在不用，先预留
  vocal: '', // 语音 文件地址（相对或绝对）
  playVocal: '', // 语音，真实的播放音频
  vocalVolume: 100, // 语音 音量调整（0 - 100）
  bgm: {
    // 背景音乐
    src: '', // 背景音乐 文件地址（相对或绝对）
    enter: 0, // 背景音乐 淡入或淡出的毫秒数
    volume: 100, // 背景音乐 音量调整（0 - 100）
  },
  uiSe: '', // 用户界面音效 文件地址（相对或绝对）
  miniAvatar: '', // 小头像 文件地址（相对或绝对）
  GameVar: {}, // 游戏内变量
  // 应用的效果
  effects: [
    {
      target: 'stage-main',
      transform: baseTransform,
    },
  ],
  bgFilter: '', // 现在不用，先预留
  bgTransform: '', // 现在不用，先预留
  PerformList: [], // 要启动的演出列表
  currentDialogKey: 'initial',
  live2dMotion: [],
  live2dExpression: [],
  live2dBlink: [],
  live2dFocus: [],
  // currentPerformDelay: 0
  currentConcatDialogPrev: '',
  enableFilm: '',
  isDisableTextbox: false,
  replacedUIlable: {},
  figureMetaData: {},
};

/**
 * 创建舞台的状态管理
 */
const stageSlice = createSlice({
  name: 'stage',
  initialState: cloneDeep(initState),
  reducers: {
    /**
     * 替换舞台状态
     * @param state 当前状态
     * @param action 替换的状态
     */
    resetStageState: (state, action: PayloadAction<IStageState>) => {
      Object.assign(state, action.payload);
    },
    /**
     * 设置舞台状态
     * @param state 当前状态
     * @param action 要替换的键值对
     */
    setStage: (state, action: PayloadAction<ISetStagePayload>) => {
      // @ts-ignore
      state[action.payload.key] = action.payload.value;
    },
    /**
     * 修改舞台状态变量
     * @param state 当前状态
     * @param action 要改变或添加的变量
     */
    setStageVar: (state, action: PayloadAction<ISetGameVar>) => {
      state.GameVar[action.payload.key] = action.payload.value;
    },
    updateEffect: (state, action: PayloadAction<IEffect>) => {
      const { target, transform } = action.payload;
      // 如果找不到目标，不能设置 transform
      const activeTargets = [
        STAGE_KEYS.STAGE_MAIN,
        STAGE_KEYS.BGMAIN,
        STAGE_KEYS.FIG_C,
        STAGE_KEYS.FIG_L,
        STAGE_KEYS.FIG_R,
        ...state.freeFigure.map((figure) => figure.key),
      ];
      if (!activeTargets.includes(target)) return;
      // 尝试找到待修改的 Effect
      const effectIndex = state.effects.findIndex((e) => e.target === target);
      if (effectIndex >= 0) {
        // Update the existing effect
        state.effects[effectIndex].transform = transform;
      } else {
        // Add a new effect
        state.effects.push({
          target,
          transform,
        });
      }
    },
    removeEffectByTargetId: (state, action: PayloadAction<string>) => {
      const index = state.effects.findIndex((e) => e.target === action.payload);
      if (index >= 0) {
        state.effects.splice(index, 1);
      }
    },
    addPerform: (state, action: PayloadAction<IRunPerform>) => {
      // 先检查是否有重复的，全部干掉
      const dupPerformIndex = state.PerformList.findIndex((p) => p.id === action.payload.id);
      if (dupPerformIndex > -1) {
        const dupId = action.payload.id;
        // 删除全部重复演出
        for (let i = 0; i < state.PerformList.length; i++) {
          const performItem: IRunPerform = state.PerformList[i];
          if (performItem.id === dupId) {
            state.PerformList.splice(i, 1);
            i--;
          }
        }
      }
      state.PerformList.push(action.payload);
    },
    removePerformByName: (state, action: PayloadAction<string>) => {
      for (let i = 0; i < state.PerformList.length; i++) {
        const performItem: IRunPerform = state.PerformList[i];
        if (performItem.id === action.payload) {
          state.PerformList.splice(i, 1);
          i--;
        }
      }
    },
    removeAllPerform: (state) => {
      state.PerformList.splice(0, state.PerformList.length);
    },
    removeAllPixiPerforms: (state, action: PayloadAction<undefined>) => {
      for (let i = 0; i < state.PerformList.length; i++) {
        const performItem: IRunPerform = state.PerformList[i];
        if (performItem.script.command === commandType.pixi) {
          state.PerformList.splice(i, 1);
          i--;
        }
      }
    },
    setFreeFigureByKey: (state, action: PayloadAction<IFreeFigure>) => {
      const currentFreeFigures = state.freeFigure;
      const newFigure = action.payload;
      const index = currentFreeFigures.findIndex((figure) => figure.key === newFigure.key);
      if (index >= 0) {
        if (newFigure.name === '') {
          // 删掉立绘和相关的动画
          currentFreeFigures.splice(index, 1);
          const figureAssociatedAnimationIndex = state.figureAssociatedAnimation.findIndex(
            (a) => a.targetId === newFigure.key,
          );
          state.figureAssociatedAnimation.splice(figureAssociatedAnimationIndex, 1);
        } else {
          currentFreeFigures[index].basePosition = newFigure.basePosition;
          currentFreeFigures[index].name = newFigure.name;
        }
      } else {
        // 新加
        if (newFigure.name !== '') currentFreeFigures.push(newFigure);
      }
    },
    setLive2dMotion: (state, action: PayloadAction<ILive2DMotion>) => {
      const { target, motion, overrideBounds } = action.payload;

      const index = state.live2dMotion.findIndex((e) => e.target === target);

      if (index < 0) {
        // Add a new motion
        state.live2dMotion.push({ target, motion, overrideBounds });
      } else {
        // Update the existing motion
        state.live2dMotion[index].motion = motion;
        state.live2dMotion[index].overrideBounds = overrideBounds;
      }
    },
    setLive2dExpression: (state, action: PayloadAction<ILive2DExpression>) => {
      const { target, expression } = action.payload;

      const index = state.live2dExpression.findIndex((e) => e.target === target);

      if (index < 0) {
        // Add a new expression
        state.live2dExpression.push({ target, expression });
      } else {
        // Update the existing expression
        state.live2dExpression[index].expression = expression;
      }
    },
    setLive2dBlink: (state, action: PayloadAction<ILive2DBlink>) => {
      const { target, blink } = action.payload;

      const index = state.live2dBlink.findIndex((e) => e.target === target);
      if (index < 0) {
        // Add a new blink
        state.live2dBlink.push({ target, blink });
      } else {
        // Update the existing blink
        state.live2dBlink[index].blink = blink;
      }
    },
    setLive2dFocus: (state, action: PayloadAction<ILive2DFocus>) => {
      const { target, focus } = action.payload;

      const index = state.live2dFocus.findIndex((e) => e.target === target);
      if (index < 0) {
        // Add a new focus
        state.live2dFocus.push({ target, focus });
      } else {
        // Update the existing focus
        state.live2dFocus[index].focus = focus;
      }
    },
    replaceUIlable: (state, action: PayloadAction<[string, string]>) => {
      state.replacedUIlable[action.payload[0]] = action.payload[1];
    },
    /**
     * 设置 figure 元数据 [立绘 key, metadata key, 值, 是否重设]
     * @param state
     * @param action
     */
    setFigureMetaData: (state, action: PayloadAction<[string, keyof IFigureMetadata, any, undefined | boolean]>) => {
      // 立绘退出，重设
      if (action.payload[3]) {
        if (state.figureMetaData[action.payload[0]]) delete state.figureMetaData[action.payload[0]];
      } else {
        // 初始化对象
        if (!state.figureMetaData[action.payload[0]]) {
          state.figureMetaData[action.payload[0]] = {};
        }
        state.figureMetaData[action.payload[0]][action.payload[1]] = action.payload[2];
      }
    },
  },
});

export const { resetStageState, setStage, setStageVar } = stageSlice.actions;
export const stageActions = stageSlice.actions;
export default stageSlice.reducer;

// /**
//  * 创建舞台的状态管理
//  * @return {IStageState} 舞台状态
//  * @return {function} 改变舞台状态
//  */
// export function stageStateStore():StageStore {
//     const [stageState, setStageState] = useState(_.cloneDeep(initState));
//
//     /**
//      * 设置舞台状态，以后会改
//      * @param key
//      * @param value
//      */
//     const setStage = <K extends keyof IStageState>(key: K, value: any) => {
//
//         setStageState(state => {
//             state[key] = value;
//             return {...state};
//         });
//
//     };
//
//     const getStageState = () => {
//         return stageState;
//     };
//
//     const restoreStage = (newState: IStageState) => {
//         setStageState((state) => ({ ...state, ...newState }));
//     };
//
//     return {
//         stageState,
//         setStage,
//         getStageState,
//         restoreStage,
//     };
// }



================================================
FILE: webgal/src/store/store.ts
================================================
import { configureStore, getDefaultMiddleware } from '@reduxjs/toolkit';
import stageReducer from '@/store/stageReducer';
import GUIReducer from '@/store/GUIReducer';
import userDataReducer from '@/store/userDataReducer';
import savesReducer from '@/store/savesReducer';

/**
 * WebGAL 全局状态管理
 */
export const webgalStore = configureStore({
  reducer: {
    stage: stageReducer,
    GUI: GUIReducer,
    userData: userDataReducer,
    saveData: savesReducer,
  },
  middleware: getDefaultMiddleware({
    serializableCheck: false,
  }),
});

// 在 TS 中的类型声明
export type RootState = ReturnType<typeof webgalStore.getState>;



================================================
FILE: webgal/src/store/userDataInterface.ts
================================================
import { IGameVar, IStageState } from './stageInterface';
import { language } from '@/config/language';
import { IBacklogItem } from '@/Core/Modules/backlog';
import { ISceneEntry } from '@/Core/Modules/scene';

/**
 * 播放速度的枚举类型
 */
export enum playSpeed {
  slow, // 慢
  normal, // 中
  fast, // 快
}

export enum textSize {
  small,
  medium,
  large,
}

export enum textFont {
  song,
  hei,
  lxgw,
}

export enum voiceOption {
  yes,
  no,
}

export enum fullScreenOption {
  on,
  off,
}

/**
 * @interface IOptionData 用户设置数据接口
 */
export interface IOptionData {
  volumeMain: number; // 主音量
  textSpeed: number; // 文字速度
  autoSpeed: number; // 自动播放速度
  textSize: textSize;
  vocalVolume: number; // 语音音量
  bgmVolume: number; // 背景音乐音量
  seVolume: number; // 音效音量
  uiSeVolume: number; // 用户界面音效音量
  slPage: number; // 存读档界面所在页面
  textboxFont: textFont;
  textboxOpacity: number;
  language: language;
  voiceInterruption: voiceOption; // 是否中断语音
  fullScreen: fullScreenOption;
}

/**
 * 场景存档接口
 * @interface ISaveScene
 */
export interface ISaveScene {
  currentSentenceId: number; // 当前语句ID
  sceneStack: Array<ISceneEntry>; // 场景栈
  sceneName: string; // 场景名称
  sceneUrl: string; // 场景url
}

/**
 * @interface ISaveData 存档文件接口
 */
export interface ISaveData {
  nowStageState: IStageState;
  backlog: Array<IBacklogItem>; // 舞台数据
  index: number; // 存档的序号
  saveTime: string; // 保存时间
  sceneData: ISaveScene; // 场景数据
  previewImage: string;
}

export interface IAppreciationAsset {
  name: string;
  url: string;
  series: string;
}

export interface IAppreciation {
  bgm: Array<IAppreciationAsset>;
  cg: Array<IAppreciationAsset>;
}

/**
 * @interface IUserData 用户数据接口
 */
export interface IUserData {
  scriptManagedGlobalVar: string[];
  globalGameVar: IGameVar; // 不跟随存档的全局变量
  optionData: IOptionData; // 用户设置选项数据
  appreciationData: IAppreciation;
}

export interface ISetUserDataPayload {
  key: keyof IUserData;
  value: any;
}

export interface ISetOptionDataPayload {
  key: keyof IOptionData;
  value: any;
}

export interface IUserDataStore {
  userDataState: IUserData;
  setUserData: <K extends keyof IUserData>(key: K, value: any) => void;
  replaceUserData: (newUserData: IUserData) => void;
  setOptionData: <K extends keyof IOptionData>(key: K, value: any) => void;
  setSlPage: (index: number) => void;
}

export type UserDataStore = IUserDataStore;



================================================
FILE: webgal/src/store/userDataReducer.ts
================================================
/**
 * 用于存储与本地存储交换的状态信息。
 * 这些状态会在指定的生命周期与本地存储发生交换，比如打开存档界面、存档、修改设置时。
 * 在引擎初始化时会将这些状态从本地存储加载到运行时状态。
 */
import { language } from '@/config/language';
import {
  IAppreciationAsset,
  IOptionData,
  ISaveData,
  ISetOptionDataPayload,
  ISetUserDataPayload,
  IUserData,
  fullScreenOption,
  playSpeed,
  textFont,
  textSize,
  voiceOption,
} from '@/store/userDataInterface';
import { createSlice, PayloadAction } from '@reduxjs/toolkit';
import cloneDeep from 'lodash/cloneDeep';
import { ISetGameVar } from './stageInterface';

const initialOptionSet: IOptionData = {
  slPage: 1,
  volumeMain: 100, // 主音量
  textSpeed: 50, // 文字速度
  autoSpeed: 50, // 自动播放速度
  textSize: textSize.medium,
  vocalVolume: 100, // 语音音量
  bgmVolume: 25, // 背景音乐音量
  seVolume: 100, // 音效音量
  uiSeVolume: 50, // UI音效音量
  textboxFont: textFont.song,
  textboxOpacity: 75,
  language: language.zhCn,
  voiceInterruption: voiceOption.yes,
  fullScreen: fullScreenOption.off,
};

// 初始化用户数据
export const initState: IUserData = {
  optionData: initialOptionSet,
  scriptManagedGlobalVar: [],
  globalGameVar: {},
  appreciationData: {
    bgm: [],
    cg: [],
  },
};

const userDataSlice = createSlice({
  name: 'userData',
  initialState: cloneDeep(initState),
  reducers: {
    /**
     * 设置用户数据
     * @param state
     * @param action
     */
    setUserData: (state, action: PayloadAction<ISetUserDataPayload>) => {
      const { key, value } = action.payload;
      state[key] = value;
    },
    unlockCgInUserData: (state, action: PayloadAction<IAppreciationAsset>) => {
      const { name, url, series } = action.payload;
      // 检查是否存在
      let isExist = false;
      state.appreciationData.cg.forEach((e) => {
        if (url === e.url) {
          isExist = true;
          e.url = url;
          e.series = series;
        }
      });
      if (!isExist) {
        state.appreciationData.cg.push(action.payload);
      }
    },
    unlockBgmInUserData: (state, action: PayloadAction<IAppreciationAsset>) => {
      const { name, url, series } = action.payload;
      // 检查是否存在
      let isExist = false;
      state.appreciationData.bgm.forEach((e) => {
        if (url === e.url) {
          isExist = true;
          e.url = url;
          e.series = series;
        }
      });
      if (!isExist) {
        state.appreciationData.bgm.push(action.payload);
      }
    },
    /**
     * 替换用户数据
     * @param state
     * @param action
     */
    resetUserData: (state, action: PayloadAction<IUserData>) => {
      Object.assign(state, action.payload);
    },
    /**
     * 设置选项数据
     * @param state
     * @param action
     */
    setOptionData: (state, action: PayloadAction<ISetOptionDataPayload>) => {
      const { key, value } = action.payload;
      (state.optionData as any)[key] = value;
    },
    /**
     * 修改不跟随存档的全局变量
     * @param state 当前状态
     * @param action 要改变或添加的变量
     */
    setGlobalVar: (state, action: PayloadAction<ISetGameVar>) => {
      const isRegistedInUserData = state.scriptManagedGlobalVar.findIndex((key) => key === action.payload.key) >= 0;
      if (!isRegistedInUserData) {
        state.globalGameVar[action.payload.key] = action.payload.value;
      }
    },
    setScriptManagedGlobalVar: (state, action: PayloadAction<ISetGameVar>) => {
      const isRegistedInUserData = state.scriptManagedGlobalVar.findIndex((key) => key === action.payload.key) >= 0;
      state.globalGameVar[action.payload.key] = action.payload.value;
      if (!isRegistedInUserData) {
        state.scriptManagedGlobalVar.push(action.payload.key);
      }
    },
    /**
     * 设置存档/读档页面
     * @param state
     * @param action
     */
    setSlPage: (state, action: PayloadAction<number>) => {
      state.optionData.slPage = action.payload;
    },
    resetOptionSet(state) {
      Object.assign(state.optionData, initialOptionSet);
    },
    resetAllData(state) {
      Object.assign(state, cloneDeep(initState));
    },
  },
});

export const {
  setUserData,
  resetUserData,
  setOptionData,
  setGlobalVar,
  setScriptManagedGlobalVar,
  setSlPage,
  unlockCgInUserData,
  unlockBgmInUserData,
  resetOptionSet,
  resetAllData,
} = userDataSlice.actions;
export default userDataSlice.reducer;

// /**
//  * 创建用户数据的状态管理
//  * @return {IUserData} 用户数据
//  * @return {function} 改变用户数据
//  */
// export function userDataStateStore():UserDataStore {
//     const [userDataState, setUserDataState] = useState(initState);
//
//     // 设置用户数据
//     const setUserData = <K extends keyof IUserData>(key: K, value: any) => {
//
//         setUserDataState(state => {
//             state[key] = value;
//             return {...state};
//         });
//
//     };
//
//     // 替换用户数据（多用于与本地存储交互）
//     const replaceUserData = (newUserData: IUserData) => {
//
//         setUserDataState(state => ({...state, ...newUserData}));
//     };
//
//     const setOptionData = <K extends keyof IOptionData>(key: K, value: any) => {
//         setUserDataState(state => {
//             state.optionData[key] = value;
//             return {...state};
//         });
//     };
//
//     const setSlPage = (index: number) => {
//         setUserDataState(state => {
//             state.optionData.slPage = index;
//             return {...state};
//         });
//
//     };
//
//     return {
//         userDataState,
//         setUserData,
//         replaceUserData,
//         setOptionData,
//         setSlPage,
//     };
// }



================================================
FILE: webgal/src/translations/de.ts
================================================
const de = {
  // 通用
  common: {
    yes: 'Ja',
    no: 'Nein',
  },

  menu: {
    options: {
      title: 'OPTIONEN',
      pages: {
        system: {
          title: 'System',
          options: {
            autoSpeed: {
              title: 'Auto-Geschwindigkeit',
              options: {
                slow: 'Langsam',
                medium: 'Normal',
                fast: 'Schnell',
              },
            },
            language: {
              title: 'Sprache',
            },
            resetData: {
              title: 'Daten löschen oder zurücksetzen',
              options: {
                clearGameSave: 'Alle Spielstände löschen',
                resetSettings: 'Alle Einstellungen zurücksetzen',
                clearAll: 'Alle Daten löschen',
              },
              dialogs: {
                clearGameSave: 'Sind Sie sicher, dass Sie den Spielstand löschen möchten?',
                resetSettings: 'Sind Sie sicher, dass Sie alle Einstellungen zurücksetzen möchten?',
                clearAll: 'Sind Sie sicher, dass Sie alle Daten löschen möchten?',
              },
            },
            gameSave: {
              title: 'Spielstand und Optionen importieren oder exportieren',
              options: {
                export: 'Spielstand und Optionen exportieren',
                import: 'Spielstand und Optionen importieren',
              },
              dialogs: {
                import: {
                  title: 'Sind Sie sicher, dass Sie den Spielstand und die Optionen importieren möchten?',
                  tip: 'Spielstand importieren',
                  error: 'Ein Fehler ist beim Analysieren des Spielstands aufgetreten',
                },
              },
            },
            about: {
              title: 'Über WebGAL',
              subTitle: 'WebGAL: Eine Open-Source Web-Based Visual Novel Engine',
              version: 'Version',
              source: 'Source Code Repository',
              contributors: 'Contributors',
              website: 'Website',
            },
          },
        },
        display: {
          title: 'Darstellung',
          options: {
            textSpeed: {
              title: 'Geschwindigkeit der Textanzeige',
              options: {
                slow: 'Langsam',
                medium: 'Normal',
                fast: 'Schnell',
              },
            },
            textSize: {
              title: 'Textgröße',
              options: {
                small: 'Klein',
                medium: 'Normal',
                large: 'Groß',
              },
            },
            textFont: {
              title: 'Schriftart',
              options: {
                siYuanSimSun: 'Source Han Serif',
                SimHei: 'Sans',
                lxgw: 'LXGW WenKai',
              },
            },
            textboxOpacity: {
              title: 'Textbox Opacity',
            },
            textPreview: {
              title: 'Vorschautext wird angezeigt',
              text: 'Sie können jederzeit die Schriftart, Größe und Wiedergabegeschwindigkeit des Textes nach Ihrer Vorliebe anpassen.',
            },
          },
        },
        sound: {
          title: 'Ton',
          options: {
            volumeMain: { title: 'Hauptlautstärke' },
            vocalVolume: { title: 'Stimmlautstärke' },
            bgmVolume: { title: 'Musiklautstärke' },
            seVolume: { title: 'Soundeffektlautstärke' },
            uiSeVolume: { title: 'UI Soundeffektlautstärke' },
          },
        },
        // language: {
        //   title: 'Sprache',
        //   options: {
        //   },
        // },
      },
    },
    saving: {
      title: 'SPEICHERN',
      isOverwrite: 'Sind Sie sicher, dass Sie diesen Spielstand überschreiben möchten?',
    },
    loadSaving: {
      title: 'LADEN',
    },
    title: {
      title: 'TITEL',
    },
    exit: {
      title: 'ZURÜCK',
    },
  },

  title: {
    start: {
      title: 'STARTEN',
      subtitle: '',
    },
    continue: {
      title: 'WEITERLESEN',
      subtitle: '',
    },
    options: {
      title: 'OPTIONEN',
      subtitle: '',
    },
    load: {
      title: 'LADEN',
      subtitle: '',
    },
    extra: {
      title: 'EXTRA',
      subtitle: '',
    },
    exit: {
      title: 'BEENDEN',
      subtitle: '',
      tips: 'Sind Sie sicher, dass Sie das Spiel beenden möchten?',
    },
  },

  gaming: {
    noSaving: 'Keine Speicherung',
    buttons: {
      hide: 'Verstecken',
      show: 'Anzeigen',
      backlog: 'Verlauf',
      replay: 'Wiedergabe',
      auto: 'Auto',
      forward: 'Überspringen',
      quicklySave: 'Quickly Save',
      quicklyLoad: 'Quickly Load',
      save: 'Speichern',
      load: 'Laden',
      fullscrreen: 'Vollbild',
      options: 'Optionen',
      title: 'Titel',
    },
  },

  extra: {
    title: 'EXTRA',
  },
};

export default de;



================================================
FILE: webgal/src/translations/en.ts
================================================
const en = {
  // 通用
  common: {
    yes: 'OK',
    no: 'Cancel',
  },

  menu: {
    options: {
      title: 'OPTIONS',
      pages: {
        system: {
          title: 'System',
          options: {
            autoSpeed: {
              title: 'Autoplay Speed',
              options: {
                slow: 'Slow',
                medium: 'Medium',
                fast: 'Fast',
              },
            },
            language: {
              title: 'Language',
            },
            resetData: {
              title: 'Clear or Reset Data',
              options: {
                clearGameSave: 'Clear game saving',
                resetSettings: 'Reset settings',
                clearAll: 'Clear all data',
              },
              dialogs: {
                clearGameSave: 'Are you sure you want to clear game saving',
                resetSettings: 'Are you sure you want to reset all settings',
                clearAll: 'Are you sure you want to clear all data',
              },
            },
            gameSave: {
              title: 'Import or Export Game Saving and Options',
              options: {
                export: 'Export game saving and options',
                import: 'Import game saving and options',
              },
              dialogs: {
                import: {
                  title: 'Are you sure you want to import game saving and options',
                  tip: 'Import game saving',
                  error: 'Parse game saving failed',
                },
              },
            },
            about: {
              title: 'About WebGAL',
              subTitle: 'WebGAL: An Open-Source Web-Based Visual Novel Engine',
              version: 'Version',
              source: 'Source Code Repository',
              contributors: 'Contributors',
              website: 'Website',
            },
          },
        },
        display: {
          title: 'Display',
          options: {
            fullScreen: {
              title: 'Full Screen',
              options: {
                on: 'ON',
                off: 'OFF',
              },
            },
            textSpeed: {
              title: 'Text Speed',
              options: {
                slow: 'Slow',
                medium: 'Medium',
                fast: 'Fast',
              },
            },
            textSize: {
              title: 'Text Size',
              options: {
                small: 'Small',
                medium: 'Medium',
                large: 'Large',
              },
            },
            textFont: {
              title: 'Text Font',
              options: {
                siYuanSimSun: 'Source Han Serif',
                SimHei: 'Sans',
                lxgw: 'LXGW WenKai',
              },
            },
            textboxOpacity: {
              title: 'Textbox Opacity',
            },
            textPreview: {
              title: 'Preview Text Showing',
              text: "You are previewing the text's font, size and playback speed, now. You can adjust the above options according to your perception.",
            },
          },
        },
        sound: {
          title: 'Sound',
          options: {
            volumeMain: { title: 'Main Volume' },
            vocalVolume: { title: 'Vocal Volume' },
            bgmVolume: { title: 'BGM Volume' },
            seVolume: { title: 'Sound Effects Volume' },
            uiSeVolume: { title: 'UI Sound Effects Volume' },
          },
        },
        // language: {
        //   title: '语言',
        //   options: {
        //   },
        // },
      },
    },
    saving: {
      title: 'SAVE',
      isOverwrite: 'Are you sure you want to overwrite this save?',
    },
    loadSaving: {
      title: 'LOAD',
    },
    title: {
      title: 'TITLE',
    },
    exit: {
      title: 'BACK',
    },
  },

  title: {
    start: {
      title: 'START',
      subtitle: '',
    },
    continue: {
      title: 'CONTINUE',
      subtitle: '',
    },
    options: {
      title: 'OPTIONS',
      subtitle: '',
    },
    load: {
      title: 'LOAD',
      subtitle: '',
    },
    extra: {
      title: 'EXTRA',
      subtitle: '',
    },
    exit: {
      title: 'EXIT',
      subtitle: '',
      tips: 'Are you sure you want to exit?',
    },
  },

  gaming: {
    noSaving: 'No saving',
    buttons: {
      hide: 'Hide',
      show: 'Show',
      backlog: 'Backlog',
      replay: 'Replay',
      auto: 'Auto',
      forward: 'Forward',
      quicklySave: 'Quickly Save',
      quicklyLoad: 'Quickly Load',
      save: 'Save',
      load: 'Load',
      fullscreen: 'Full Screen',
      options: 'Options',
      title: 'Title',
      titleTips: 'Confirm return to the title screen',
    },
  },

  extra: {
    title: 'EXTRA',
  },
};

export default en;



================================================
FILE: webgal/src/translations/fr.ts
================================================
const fr = {
  // 通用
  common: {
    yes: 'OK',
    no: 'Annuler',
  },

  menu: {
    options: {
      title: 'OPTIONS',
      pages: {
        system: {
          title: 'Système',
          options: {
            autoSpeed: {
              title: 'Vitesse de lecture automatique',
              options: {
                slow: 'Lente',
                medium: 'Moyenne',
                fast: 'Rapide',
              },
            },
            language: {
              title: 'Langue',
            },
            resetData: {
              title: 'Effacer ou réinitialiser les données',
              options: {
                clearGameSave: 'Effacer la sauvegarde du jeu',
                resetSettings: 'Réinitialiser les paramètres',
                clearAll: 'Tout effacer',
              },
              dialogs: {
                clearGameSave: 'Êtes-vous sûr de vouloir effacer la sauvegarde du jeu',
                resetSettings: 'Êtes-vous sûr de vouloir réinitialiser tous les paramètres',
                clearAll: 'Êtes-vous sûr de vouloir tout effacer',
              },
            },
            gameSave: {
              title: 'Importer ou exporter la sauvegarde du jeu et les options',
              options: {
                export: 'Exporter la sauvegarde du jeu et les options',
                import: 'Importer la sauvegarde du jeu et les options',
              },
              dialogs: {
                import: {
                  title: 'Êtes-vous sûr de vouloir importer la sauvegarde du jeu et les options',
                  tip: 'Importer la sauvegarde du jeu',
                  error: "Impossible d'analyser la sauvegarde du jeu",
                },
              },
            },
            about: {
              title: 'À propos de WebGAL',
              subTitle: 'WebGAL: Un moteur de visual novel basé sur le web en open-source',
              version: 'Version',
              source: 'Dépôt de code source',
              contributors: 'Contributeurs',
              website: 'Site web',
            },
          },
        },
        display: {
          title: 'Affichage',
          options: {
            textSpeed: {
              title: "Vitesse d'affichage du texte",
              options: {
                slow: 'Lente',
                medium: 'Moyenne',
                fast: 'Rapide',
              },
            },
            textSize: {
              title: 'Taille du texte',
              options: {
                small: 'Petite',
                medium: 'Moyenne',
                large: 'Grande',
              },
            },
            textFont: {
              title: 'Police du texte',
              options: {
                siYuanSimSun: 'Source Han Serif',
                SimHei: 'Sans',
                lxgw: 'LXGW WenKai',
              },
            },
            textboxOpacity: {
              title: 'Textbox Opacity',
            },
            textPreview: {
              title: "Aperçu de l'affichage du texte",
              text: 'Vous prévisualisez la police, la taille et la vitesse de lecture du texte, maintenant. Vous pouvez ajuster les options ci-dessus selon votre perception.',
            },
          },
        },
        sound: {
          title: 'Son',
          options: {
            volumeMain: { title: 'Volume principal' },
            vocalVolume: { title: 'Volume des voix' },
            bgmVolume: { title: 'Volume de la musique de fond' },
            seVolume: { title: 'Volume des effets sonores' },
            uiSeVolume: { title: 'Volume de l’interface utilisateur' },
          },
        },
        // language: {
        //   title: 'Langue',
        //   options: {
        //   },
        // },
      },
    },
    saving: {
      title: 'SAUVEGARDER',
      isOverwrite: 'Êtes-vous sûr de vouloir écraser cette sauvegarde ?',
    },
    loadSaving: {
      title: 'CHARGER',
    },
    title: {
      title: 'TITRE',
    },
    exit: {
      title: 'RETOUR',
    },
  },

  title: {
    start: {
      title: 'COMMENCER',
      subtitle: '',
    },
    continue: {
      title: 'CONTINUER',
      subtitle: '',
    },
    options: {
      title: 'OPTIONS',
      subtitle: '',
    },
    load: {
      title: 'CHARGER',
      subtitle: '',
    },
    extra: {
      title: 'EXTRA',
      subtitle: '',
    },
    exit: {
      title: 'QUITTER',
      subtitle: '',
      tips: 'Êtes-vous sûr de vouloir quitter ?',
    },
  },

  gaming: {
    noSaving: 'Aucune sauvegarde',
    buttons: {
      hide: 'Masquer',
      show: 'Afficher',
      backlog: 'Journal',
      replay: 'Rejouer',
      auto: 'Automatique',
      forward: 'Avancer',
      quicklySave: 'Sauvegarde rapide',
      quicklyLoad: 'Chargement rapide',
      save: 'Sauvegarder',
      load: 'Charger',
      fullscrren: 'Plein écran',
      options: 'Options',
      title: 'Titre',
      titleTips: "Confirmer le retour à l'écran titre ?",
    },
  },

  extra: {
    title: 'EXTRA',
  },
};

export default fr;



================================================
FILE: webgal/src/translations/jp.ts
================================================
const jp = {
  // 通用
  common: {
    yes: 'はい',
    no: 'いいえ',
  },

  menu: {
    options: {
      title: 'CONFIG',
      pages: {
        system: {
          title: 'システム',
          options: {
            autoSpeed: {
              title: '自動再生速度',
              options: {
                slow: '遅く',
                medium: '標準',
                fast: '速く',
              },
            },
            language: {
              title: '言語',
            },
            resetData: {
              title: 'データの復元と削除',
              options: {
                clearGameSave: 'すべてのセーブデータを削除',
                resetSettings: '設定を元に戻す',
                clearAll: 'すべてのデータを削除',
              },
              dialogs: {
                clearGameSave: 'すべてのセーブデータを削除しますか？',
                resetSettings: '設定を元に戻しますか？',
                clearAll: 'すべてのデータを削除しますか？',
              },
            },
            gameSave: {
              title: 'セーブデータと設定のインポートとエクスポート',
              options: {
                export: 'セーブデータと設定のエクスポート',
                import: 'セーブデータと設定のインポート',
              },
              dialogs: {
                import: {
                  title: 'セーブデータと設定をインポートしますか？',
                  tip: 'セーブデータのインポート',
                  error: 'セーブデータの読み込みに失敗しました',
                },
              },
            },
            about: {
              title: 'WebGAL について',
              subTitle: 'WebGAL: オープンソースのウェブベースビジュアルノベルエンジン',
              version: 'バージョン',
              source: 'ソースコードリポジトリ',
              contributors: '貢献者',
              website: 'ウェブサイト',
            },
          },
        },
        display: {
          title: 'ウィンドウ',
          options: {
            fullScreen: {
              title: 'フルスクリーン',
              options: {
                on: 'オン',
                off: 'オフ',
              },
            },
            textSpeed: {
              title: 'テキスト表示速度',
              options: {
                slow: '遅く',
                medium: '標準',
                fast: '速く',
              },
            },
            textSize: {
              title: 'テキストサイズ',
              options: {
                small: '小',
                medium: '中',
                large: '大',
              },
            },
            textFont: {
              title: 'フォント',
              options: {
                siYuanSimSun: '源ノ明朝(中国語)',
                SimHei: 'OPPO Sans',
                lxgw: 'LXGW WenKai',
              },
            },
            textboxOpacity: {
              title: 'テキストボックスの不透明度',
            },
            textPreview: {
              title: 'テキスト表示プレビュー',
              text: 'これはテキストボックスのフォントとサイズ、表示速度のプレビューです。上にある設定で変更できます。',
            },
          },
        },
        sound: {
          title: 'サウンド',
          options: {
            volumeMain: { title: 'メイン音量' },
            vocalVolume: { title: 'ボイス音量' },
            bgmVolume: { title: 'BGM 音量' },
            seVolume: { title: '効果音音量' },
            uiSeVolume: { title: 'UI 効果音音量' },
            voiceOption: { title: 'ボイスの中断' },
            voiceStop: { title: '中断する' },
            voiceContinue: { title: '中断しない' },
          },
        },
        // language: {
        //   title: '言語',
        //   options: {
        //   },
        // },
      },
    },
    saving: {
      title: 'SAVE',
      isOverwrite: 'セーブデータを上書きしますか？',
    },
    loadSaving: {
      title: 'LOAD',
    },
    title: {
      title: 'HOME',
    },
    exit: {
      title: 'BACK',
    },
  },

  title: {
    start: {
      title: '初めから',
      subtitle: 'START',
    },
    continue: {
      title: '続きから',
      subtitle: 'CONTINUE',
    },
    options: {
      title: '設定',
      subtitle: 'CONFIG',
    },
    load: {
      title: 'ロード',
      subtitle: 'LOAD',
    },
    extra: {
      title: '鑑賞モード',
      subtitle: 'EXTRA',
    },
    exit: {
      title: 'ゲーム終了',
      subtitle: 'EXIT',
      tips: 'ゲームを終了しますか？',
    },
  },

  gaming: {
    noSaving: 'クイックセーブなし',
    buttons: {
      hide: 'CLOSE',
      show: 'SHOW',
      backlog: 'LOG',
      replay: 'REPLAY',
      auto: 'AUTO',
      forward: 'SKIP',
      quicklySave: 'QUICK SAVE',
      quicklyLoad: 'QUICK LOAD',
      save: 'SAVE',
      load: 'LOAD',
      fullscrren: 'FULLSCREEN',
      options: 'CONFIG',
      title: 'HOME',
      titleTips: 'タイトル画面に戻りますか？',
    },
  },

  extra: {
    title: '鑑賞モード',
  },
};

export default jp;



================================================
FILE: webgal/src/translations/zh-cn.ts
================================================
const zhCn = {
  // 通用
  common: {
    yes: '是',
    no: '否',
  },

  menu: {
    options: {
      title: '选项',
      pages: {
        system: {
          title: '系统',
          options: {
            autoSpeed: {
              title: '自动播放速度',
              options: {
                slow: '慢',
                medium: '中',
                fast: '快',
              },
            },
            language: {
              title: '语言',
            },
            resetData: {
              title: '清除或还原数据',
              options: {
                clearGameSave: '清除所有存档',
                resetSettings: '还原默认设置',
                clearAll: '清除所有数据',
              },
              dialogs: {
                clearGameSave: '确定要清除存档吗',
                resetSettings: '确定要还原默认设置吗',
                clearAll: '确定要清除所有数据吗',
              },
            },
            gameSave: {
              title: '导入或导出存档与选项',
              options: {
                export: '导出存档与选项',
                import: '导入存档与选项',
              },
              dialogs: {
                import: {
                  title: '确定要导入存档与选项吗',
                  tip: '导入存档',
                  error: '存档解析失败',
                },
              },
            },
            about: {
              title: '关于 WebGAL',
              subTitle: 'WebGAL：开源的网页端视觉小说引擎',
              version: '版本号',
              source: '源代码仓库',
              contributors: '贡献者',
              website: '网站',
            },
          },
        },
        display: {
          title: '显示',
          options: {
            fullScreen: {
              title: '全屏模式',
              options: {
                on: '开启',
                off: '关闭',
              },
            },
            textSpeed: {
              title: '文字显示速度',
              options: {
                slow: '慢',
                medium: '中',
                fast: '快',
              },
            },
            textSize: {
              title: '文本大小',
              options: {
                small: '小',
                medium: '中',
                large: '大',
              },
            },
            textFont: {
              title: '文本字体',
              options: {
                siYuanSimSun: '思源宋体',
                SimHei: '黑体',
                lxgw: '霞鹜文楷',
              },
            },
            textboxOpacity: {
              title: '文本框不透明度',
            },
            textPreview: {
              title: '文本显示预览',
              text: '现在预览的是文本框字体大小和播放速度的情况，您可以根据您的观感调整上面的选项。',
            },
          },
        },
        sound: {
          title: '音频',
          options: {
            volumeMain: { title: '主音量' },
            vocalVolume: { title: '语音音量' },
            bgmVolume: { title: '背景音乐音量' },
            seVolume: { title: '音效音量' },
            uiSeVolume: { title: '用户界面音效音量' },
            voiceOption: { title: '是否中断语音' },
            voiceStop: { title: '停止语音' },
            voiceContinue: { title: '继续语音' },
          },
        },
        // language: {
        //   title: '语言',
        //   options: {
        //   },
        // },
      },
    },
    saving: {
      title: '存档',
      isOverwrite: '是否覆盖存档？',
    },
    loadSaving: {
      title: '读档',
    },
    title: {
      title: '标题',
      options: {
        load: '',
        extra: '鉴赏模式',
      },
    },
    exit: {
      title: '返回',
    },
  },

  title: {
    start: {
      title: '开始游戏',
      subtitle: 'START',
    },
    continue: {
      title: '继续游戏',
      subtitle: 'CONTINUE',
    },
    options: {
      title: '游戏选项',
      subtitle: 'OPTIONS',
    },
    load: {
      title: '读取存档',
      subtitle: 'LOAD',
    },
    extra: {
      title: '鉴赏模式',
      subtitle: 'EXTRA',
    },
    exit: {
      title: '退出游戏',
      subtitle: 'EXIT',
      tips: '确定要退出游戏吗？',
    },
  },

  gaming: {
    noSaving: '暂无存档',
    buttons: {
      hide: '隐藏',
      show: '显示',
      backlog: '回想',
      replay: '重播',
      auto: '自动',
      forward: '快进',
      quicklySave: '快速存档',
      quicklyLoad: '快速读档',
      save: '存档',
      load: '读档',
      fullscreen: '全屏',
      options: '选项',
      title: '标题',
      titleTips: '确定要返回标题界面吗？',
    },
  },

  extra: {
    title: '鉴赏模式',
  },
};

export default zhCn;



================================================
FILE: webgal/src/translations/zh-tw.ts
================================================
const zhTw = {
  // 通用
  common: {
    yes: '是',
    no: '否',
  },

  menu: {
    options: {
      title: '設定',
      pages: {
        system: {
          title: '系統',
          options: {
            autoSpeed: {
              title: '自動播放速度',
              options: {
                slow: '慢',
                medium: '中',
                fast: '快',
              },
            },
            language: {
              title: '語言',
            },
            resetData: {
              title: '清除或還原紀錄',
              options: {
                clearGameSave: '清除所有存檔',
                resetSettings: '還原預設設定',
                clearAll: '清除所有紀錄',
              },
              dialogs: {
                clearGameSave: '確定要清除存檔嗎',
                resetSettings: '確定要還原預設設定嗎',
                clearAll: '確定要清除所有紀錄嗎',
              },
            },
            gameSave: {
              title: '匯入或匯出存檔與設定',
              options: {
                export: '匯出存檔與設定',
                import: '匯入存檔與設定',
              },
              dialogs: {
                import: {
                  title: '確定要匯入存檔與設定嗎',
                  tip: '匯入存檔',
                  error: '存檔匯入失敗',
                },
              },
            },
            about: {
              title: '關於 WebGAL',
              subTitle: 'WebGAL：開源的線上視覺小說製作引擎',
              version: '版本號',
              source: '原始碼倉庫',
              contributors: '貢獻者',
              website: '網站',
            },
          },
        },
        display: {
          title: '顯示',
          options: {
            fullScreen: {
              title: '全螢幕模式',
              options: {
                on: '開啟',
                off: '關閉',
              },
            },
            textSpeed: {
              title: '文字顯示速度',
              options: {
                slow: '慢',
                medium: '中',
                fast: '快',
              },
            },
            textSize: {
              title: '文字大小',
              options: {
                small: '小',
                medium: '中',
                large: '大',
              },
            },
            textFont: {
              title: '文字字體',
              options: {
                siYuanSimSun: '思源宋體',
                SimHei: '黑體',
                lxgw: '霞鶩文楷',
              },
            },
            textboxOpacity: {
              title: '文字方塊不透明度',
            },
            textPreview: {
              title: '文字顯示預覽',
              text: '現在預覽的是文字方塊字體大小和播放速度的情況，您可以根據您的觀感調整上面的設定。',
            },
          },
        },
        sound: {
          title: '音量',
          options: {
            volumeMain: { title: '主音量' },
            vocalVolume: { title: '語音音量' },
            bgmVolume: { title: '背景音樂音量' },
            seVolume: { title: '音效音量' },
            uiSeVolume: { title: '介面音效音量' },
            voiceOption: { title: '是否中斷語音' },
            voiceStop: { title: '停止語音' },
            voiceContinue: { title: '繼續語音' },
          },
        },
        // language: {
        //   title: '語言',
        //   options: {
        //   },
        // },
      },
    },
    saving: {
      title: '存檔',
      isOverwrite: '是否要覆蓋存檔?',
    },
    loadSaving: {
      title: '讀檔',
    },
    title: {
      title: '主選單',
      options: {
        load: '',
        extra: 'CG模式',
      },
    },
    exit: {
      title: '返回',
    },
  },

  title: {
    start: {
      title: '開始遊戲',
      subtitle: 'START',
    },
    continue: {
      title: '繼續遊戲',
      subtitle: 'CONTINUE',
    },
    options: {
      title: '遊戲設定',
      subtitle: 'OPTIONS',
    },
    load: {
      title: '讀取存檔',
      subtitle: 'LOAD',
    },
    extra: {
      title: 'CG模式',
      subtitle: 'EXTRA',
    },
    exit: {
      title: '退出遊戲',
      subtitle: 'EXIT',
      tips: '確定要退出遊戲嗎？',
    },
  },

  gaming: {
    noSaving: '暫無存檔',
    buttons: {
      hide: '隱藏',
      show: '顯示',
      backlog: '回想',
      replay: '重播',
      auto: '自動',
      forward: '加速',
      quicklySave: '快速存檔',
      quicklyLoad: '快速讀檔',
      save: '存檔',
      load: '讀檔',
      fullscreen: '全螢幕',
      options: '設定',
      title: '主選單',
      titleTips: '確定要返回主選單嗎？',
    },
  },

  extra: {
    title: 'CG模式',
  },
};

export default zhTw;



================================================
FILE: webgal/src/types/angular-expressions.d.ts
================================================
import { EvaluatorFunc } from 'angular-expressions';
declare module 'angular-expressions' {
  export function compile(src: string, lexerOptions?: any): () => number | boolean | EvaluatorFunc;
}



================================================
FILE: webgal/src/types/debugProtocol.ts
================================================
import { IStageState } from '@/store/stageInterface';

export enum DebugCommand {
  // 跳转
  JUMP,
  // 同步自客户端
  SYNCFC,
  // 同步自编辑器
  SYNCFE,
  // 执行指令
  EXE_COMMAND,
  // 重新拉取模板样式文件
  REFETCH_TEMPLATE_FILES,
  // 返回主界面
  SET_COMPONENT_VISIBILITY,
  // 临时场景
  TEMP_SCENE,
  // 字体优化
  FONT_OPTIMIZATION,
}

export interface IDebugMessage {
  event: string;
  data: {
    command: DebugCommand;
    sceneMsg: {
      sentence: number;
      scene: string;
    };
    message: string;
    stageSyncMsg: IStageState;
  };
}

export interface IComponentsVisibility {
  showStarter: boolean; // 是否显示初始界面（用于使得bgm可以播放)
  showTitle: boolean; // 是否显示标题界面
  showMenuPanel: boolean; // 是否显示Menu界面
  showTextBox: boolean;
  showControls: boolean;
  controlsVisibility: boolean;
  showBacklog: boolean;
  showExtra: boolean;
  showGlobalDialog: boolean;
  showPanicOverlay: boolean;
  isEnterGame: boolean;
  isShowLogo: boolean;
}

export interface IComponentVisibilityCommand {
  component: keyof IComponentsVisibility;
  visibility: boolean;
}



================================================
FILE: webgal/src/UI/getTextSize.ts
================================================
export function getTextSize(size: number) {
  switch (size) {
    case 0:
      return 155;
    case 1:
      return 205;
    case 2:
      return 230;
    default:
      return 205;
  }
}



================================================
FILE: webgal/src/UI/Backlog/backlog.module.scss
================================================
.Backlog_main {
  font-family: "思源宋体", serif;
  position: absolute;
  top: 0;
  width: 100%;
  height: 100%;
  z-index: 10;
  background: rgba(0, 0, 0, 0.7);
  padding: 2em 0 2em 0;
  animation: backlog_soft_in 0.7s ease-out forwards;
  box-sizing: border-box;
}

.Backlog_main_out {
  font-family: "思源宋体", serif;
  position: absolute;
  top: 0;
  width: 100%;
  height: 100%;
  z-index: 10;
  background: rgba(0, 0, 0, 0.7);
  padding: 2em 0 2em 0;
  animation: backlog_soft_out 0.7s ease-out forwards;
  box-sizing: border-box;
}

// 把z-index置为负数 不然会挡住点击层
.Backlog_main_out_IndexHide {
  z-index: -10;
}

// 暂时禁用滚动
.Backlog_main_DisableScroll {
  overflow: hidden !important;
}


.backlog_top {
  padding: 0 0 0 1em;
  display: flex;
  height: 10%;
}

.backlog_top_icon {
  padding: 0.6em 0.6em 0 0.6em;
  border-radius: 1000px;
  transform: translate(0, -13px);
  cursor: pointer;
}

.backlog_top_icon:hover {
  background: rgba(255, 255, 255, 0.25);
  animation: backlog_icon_softin 0.25s ease-out forwards;
}

@keyframes backlog_icon_softin {
  0% {
    background: rgba(255, 255, 255, 0);
  }
  100% {
    background: rgba(255, 255, 255, 0.25);
  }
}


.backlog_title {
  height: 100%;
  line-height: 100%;
  font-size: 360%;
  font-weight: bold;
  color: transparent;
  background: linear-gradient(150deg, rgba(255, 255, 255, 1) 0%, rgba(255, 255, 255, 1) 35%, rgba(165, 212, 228, 1) 100%);
  -webkit-background-clip: text;
}

.backlog_content {
  position: absolute;
  height: 80%;
  padding: 1em 10em 1em 10em;
  overflow: auto;
  display: flex;
  flex-flow: column-reverse;
  font-weight: normal;
  width: 100%;
  box-sizing: border-box;
}


.backlog_item {
  display: flex;
  color: white;
  font-size: 165%;
  opacity: 0;
  animation: backlog_item_in 0.5s ease-out forwards;
  margin: 1.25em 0 0 0;
  width: 100%;
}

.backlog_item_out {
  display: flex;
  color: white;
  font-size: 165%;
  opacity: 0;
  animation: backlog_item_out 0.5s ease-out forwards;
  margin: 1.25em 0 0 0;
  width: 100%;
}

.backlog_func_area {
  display: flex;
  flex-flow: row;
  align-items: flex-start;
  width: 30%;
  max-width: 30%;
  min-width: 30%;
}

.backlog_item_content_name {
  font-weight: bold;
  color: transparent;
  //background: linear-gradient(150deg, rgba(255, 255, 255, 1) 0%, rgba(255, 255, 255, 1) 55%, rgb(210, 243, 255) 100%);
  background: linear-gradient(150deg, rgba(255, 255, 255, 1) 0%, rgba(255, 255, 255, 1) 35%, rgba(165, 212, 228, 1) 100%);
  -webkit-background-clip: text;
  //width: 20%;
  margin: 0 0 0 auto;
  overflow-wrap: break-word;
  box-sizing: border-box;
  //background: rgba(255, 255, 255, 0.175);
  border-radius: 7px;
  padding: 0.2em 0.5em 0.2em 0.5em;
  font-size: 115%;
  width: 50%;
  text-align: left;
  //font-family: WebgalUI, serif;
  letter-spacing: 0.1em;
}

.backlog_item_content {
  //display: flex;
  font-size: 115%;
  width: 82.5%;
  box-sizing: border-box;
  padding: 0.2em 0 0 1em;
  //font-family: WebgalUI, serif;
  letter-spacing: 0.05em;
}

.backlog_item_button_list {
  display: flex;
  //padding: 0 2em 0 0.3em;
  flex-flow: row;
  align-items: flex-start;
  margin: 0.35em 0 0 0;
}

.backlog_item_button_element {
  cursor: pointer;
  padding: 0.01em 0.75em 0 0.75em;
  margin: 0 0 0 0.5em;
  background: rgba(255, 255, 255, 0.075);
  border-radius: 7px;
  display: flex;
  //border: 1px solid rgba(255, 255, 255, 0.15);
  //box-shadow: 0 0 15px rgba(255, 255, 255, 0.25);
}

.backlog_item_button_element:hover {
  background: rgba(255, 255, 255, 0.25);
  //border: 1px solid rgba(255, 255, 255, 0);
  //box-shadow: 0 0 15px rgba(255, 255, 255, 0.3);
}


.backlog_item_content_text {
  //width: 80%;
  box-sizing: border-box;
}


@keyframes backlog_soft_in {
  0% {
    opacity: 0;
  }
  100% {
    opacity: 1;
  }
}

@keyframes backlog_soft_out {
  0% {
    opacity: 1;
  }
  100% {
    opacity: 0;
  }
}

@keyframes backlog_item_in {
  0% {
    opacity: 0;
    transform: scale(1.05, 1.05) translate(-15px, 10px) rotateX(-5deg) rotateY(-5deg);
    //background-color: rgba(255, 255, 255, 0.2);
  }
  100% {
    opacity: 1;
    transform: scale(1, 1) translate(0, 0);
  }
}

@keyframes backlog_item_out {
  0% {
    opacity: 1;
    transform: scale(1, 1) translate(0, 0);
  }
  100% {
    opacity: 0;
    transform: scale(1.05, 1.05) translate(-15px, 10px) rotateX(-5deg) rotateY(-5deg);
    background-color: rgba(255, 255, 255, 0.2);
  }
}



================================================
FILE: webgal/src/UI/Backlog/Backlog.tsx
================================================
import styles from './backlog.module.scss';
import { CloseSmall, Return, VolumeNotice } from '@icon-park/react';
import { jumpFromBacklog } from '@/Core/controller/storage/jumpFromBacklog';
import { useDispatch, useSelector } from 'react-redux';
import { RootState, webgalStore } from '@/store/store';
import { setVisibility } from '@/store/GUIReducer';
import { logger } from '@/Core/util/logger';
import { ReactNode, useEffect, useMemo, useRef, useState } from 'react';
import useTrans from '@/hooks/useTrans';
import { compileSentence, EnhancedNode } from '@/Stage/TextBox/TextBox';
import useSoundEffect from '@/hooks/useSoundEffect';
import { WebGAL } from '@/Core/WebGAL';

export const Backlog = () => {
  const t = useTrans('gaming.');
  // logger.info('Backlog render');
  const { playSeEnter, playSeClick } = useSoundEffect();
  const GUIStore = useSelector((state: RootState) => state.GUI);
  const isBacklogOpen = GUIStore.showBacklog;
  const dispatch = useDispatch();
  const iconSize = '0.8em';
  const [indexHide, setIndexHide] = useState(false);
  const [isDisableScroll, setIsDisableScroll] = useState(false);
  const [limit, setLimit] = useState(20);
  useEffect(() => {
    if (!isBacklogOpen) {
      return;
    }
    let options = {
      root: null,
      rootMargin: '0px',
      threshold: [1.0],
    };

    let observer = new IntersectionObserver((entries) => {
      if ((entries?.[0]?.intersectionRatio ?? 0) <= 0) return;
      setLimit(limit + 20);
    }, options);

    const observeTarget = document.querySelector(`#backlog_item_${limit - 5}`);
    if (observeTarget) {
      observer.observe(observeTarget);
    }

    return () => {
      observer.disconnect();
    };
  }, [limit, isBacklogOpen]);

  useEffect(() => {
    if (!isBacklogOpen) {
      setLimit(20);
    }
  }, [isBacklogOpen]);

  let timeRef = useRef<ReturnType<typeof setTimeout>>();
  // 缓存一下vdom
  const backlogList = useMemo<any>(() => {
    let backlogs = [];
    const current_backlog_len = WebGAL.backlogManager.getBacklog().length;
    // logger.info('backlogList render');
    for (let i = 0; i < Math.min(current_backlog_len, limit); i++) {
      const indexOfBacklog = current_backlog_len - i - 1;
      const backlogItem = WebGAL.backlogManager.getBacklog()[indexOfBacklog];
      const showTextArray = compileSentence(backlogItem.currentStageState.showText, 3, true, false);
      const showTextArray2 = showTextArray.map((line) => {
        return line.map((c) => {
          return c.reactNode;
        });
      });
      const showTextArrayReduced = mergeStringsAndKeepObjects(showTextArray2);
      const showTextElementList = showTextArrayReduced.map((line, index) => {
        return (
          <div key={`backlog-line-${index}`}>
            {line.map((e, index) => {
              if (e === '<br />') {
                return <br key={`br${index}`} />;
              } else {
                return e;
              }
            })}
          </div>
        );
      });
      const showNameArray = compileSentence(backlogItem.currentStageState.showName, 3, true);
      const showNameArray2 = showNameArray.map((line) => {
        return line.map((c) => {
          return c.reactNode;
        });
      });
      const showNameArrayReduced = mergeStringsAndKeepObjects(showNameArray2);
      const nameElementList = showNameArrayReduced.map((line, index) => {
        return (
          <div key={`backlog-line-${index}`}>
            {line.map((e, index) => {
              if (e === '<br />') {
                return <br key={`br${index}`} />;
              } else {
                return e;
              }
            })}
          </div>
        );
      });
      const singleBacklogView = (
        <div
          className={styles.backlog_item}
          id={`backlog_item_${i}`}
          style={{ animationDelay: `${20 * ((i - 1) % 20)}ms` }}
          key={'backlogItem' + backlogItem.currentStageState.showText + backlogItem.saveScene.currentSentenceId}
        >
          <div className={styles.backlog_func_area}>
            <div className={styles.backlog_item_button_list}>
              <div
                onClick={(e) => {
                  playSeClick();
                  jumpFromBacklog(indexOfBacklog);
                  e.preventDefault();
                  e.stopPropagation();
                }}
                onMouseEnter={playSeEnter}
                className={styles.backlog_item_button_element}
              >
                <Return theme="outline" size={iconSize} fill="#ffffff" strokeWidth={3} />
              </div>
              {backlogItem.currentStageState.vocal ? (
                <div
                  onClick={() => {
                    playSeClick();
                    // 获取到播放 backlog 语音的元素
                    const backlog_audio_element: any = document.getElementById(
                      'backlog_audio_play_element_' + indexOfBacklog,
                    );
                    if (backlog_audio_element) {
                      backlog_audio_element.currentTime = 0;
                      const userDataStore = webgalStore.getState().userData;
                      const mainVol = userDataStore.optionData.volumeMain;
                      backlog_audio_element.volume = mainVol * 0.01 * userDataStore.optionData.vocalVolume * 0.01;
                      backlog_audio_element?.play();
                    }
                  }}
                  onMouseEnter={playSeEnter}
                  className={styles.backlog_item_button_element}
                >
                  <VolumeNotice theme="outline" size={iconSize} fill="#ffffff" strokeWidth={3} />
                </div>
              ) : null}
            </div>
            <div className={styles.backlog_item_content_name}>{nameElementList}</div>
          </div>
          <div className={styles.backlog_item_content}>
            <span className={styles.backlog_item_content_text}>{showTextElementList}</span>
          </div>
          <audio id={'backlog_audio_play_element_' + indexOfBacklog} src={backlogItem.currentStageState.vocal} />
        </div>
      );
      backlogs.push(singleBacklogView);
    }
    return backlogs;
  }, [
    WebGAL.backlogManager.getBacklog()[WebGAL.backlogManager.getBacklog().length - 1]?.saveScene?.currentSentenceId ??
      0,
    limit,
  ]);
  useEffect(() => {
    /* 切换为展示历史记录时触发 */
    if (GUIStore.showBacklog) {
      // logger.info('展示backlog');
      // 立即清除 防止来回滚动时可能导致的错乱
      if (timeRef.current) {
        clearTimeout(timeRef.current);
      }
      // setIsDisableScroll(false);
      // 重新把index调回正数
      setIndexHide(false);
      // 向上滑动触发回想时会带着backlog一起滑一下 我也不知道为什么，可能是我的鼠标问题 所以先ban掉滚动
      setIsDisableScroll(true);
      // nextTick开启滚动
      setTimeout(() => {
        setIsDisableScroll(false);
      }, 0);
    } else {
      /* 隐藏历史记录触发 */
      // 这里是为了让backlog的z-index降低
      timeRef.current = setTimeout(() => {
        setIndexHide(true);
        // setIsDisableScroll(false);
        // setIsDisableScroll(true);
        timeRef.current = undefined;
        // 700是和动画一样的延时 保险起见多个80ms
        // 不加也没啥 问题不大
      }, 700 + 80);
    }
  }, [GUIStore.showBacklog]);
  return (
    <>
      {
        // ${indexHide ? styles.Backlog_main_out_IndexHide : ''}
        <div
          className={`
          ${GUIStore.showBacklog ? styles.Backlog_main : styles.Backlog_main_out}
          ${indexHide ? styles.Backlog_main_out_IndexHide : ''}
          `}
        >
          <div className={styles.backlog_top}>
            <CloseSmall
              className={styles.backlog_top_icon}
              onClick={() => {
                playSeClick();
                dispatch(setVisibility({ component: 'showBacklog', visibility: false }));
                dispatch(setVisibility({ component: 'showTextBox', visibility: true }));
              }}
              onMouseEnter={playSeEnter}
              theme="outline"
              size="4em"
              fill="#ffffff"
              strokeWidth={3}
            />
            <div
              className={styles.backlog_title}
              onClick={() => {
                logger.info('Rua! Testing');
              }}
            >
              {t('buttons.backlog')}
            </div>
          </div>
          {GUIStore.showBacklog && (
            <div className={`${styles.backlog_content} ${isDisableScroll ? styles.Backlog_main_DisableScroll : ''}`}>
              {backlogList}
            </div>
          )}
        </div>
      }
    </>
  );
};

export function mergeStringsAndKeepObjects(arr: ReactNode[]): ReactNode[][] {
  let result = [];
  let currentString = '';

  // eslint-disable-next-line @typescript-eslint/prefer-for-of
  for (let i = 0; i < arr.length; i++) {
    const currentItem = arr[i];

    if (typeof currentItem === 'string') {
      currentString += currentItem;
    } else {
      if (currentString !== '') {
        result.push(currentString);
        currentString = '';
      }
      result.push(currentItem);
    }
  }

  if (currentString !== '') {
    result.push(currentString);
  }

  return result as ReactNode[][];
}



================================================
FILE: webgal/src/UI/BottomControlPanel/bottomControlPanel.module.scss
================================================
//.ToCenter {
//  display: flex;
//  justify-content: center;
//  position: absolute;
//  bottom: 0;
//  left: 0;
//  width: 100%;
//  z-index: 9;
//}

.main {
  //border-bottom: 2px solid rgba(255,255,255,0.25);
  position: absolute;
  bottom: 20px;
  //will-change: z-index;
  z-index: 9;
  display: flex;
  //background-image: linear-gradient(rgba(245, 247, 250, 0.7) 0%, rgba(195, 207, 226, 0.7) 100%);
  flex-flow: row;
  justify-content: center;
  align-items: center;
  //width: 100%;
  height: 70px;
  right: 20px;
  border-radius: 35px;
  //backdrop-filter: blur(5px);
  padding: 0.15em 1.75em 0.15em 1.75em;
  //background: linear-gradient(rgba(255, 255, 255, 0) 0%, rgba(255, 255, 255, 0.25) 100%);
  //border-radius: 10px;
  font-size: 80%;
}

.button {
  position: relative;
  top: 2px;
  padding: 0 0 0 0;
  filter: drop-shadow(1px 1px 5px rgba(0, 0, 0, 1));
}

.button_text {
  position: relative;
  bottom: 8px;
  color: white;
  text-shadow: 1px 1px 5px rgba(0, 0, 0, 1);
  padding-left: 3px;
}

.button_on {
  height: 100%;
  display: inline-block;
  font-size: 150%;
  padding: 0.25em 0.3em 0 0.15em;
  transition: background-color 0.5s;
  background: rgba(255, 255, 255, 0.3);
  border-radius: 4px;
  margin: 0 0.1em 0 0.1em;
}

.singleButton {
  //border-bottom: 1px solid rgba(255, 255, 255, 0.5);
  height: 100%;
  display: inline-block;
  color: white;
  font-size: 150%;
  padding: 0.3em 0.3em 0 0.15em;
  transition: background-color 0.5s;
  cursor: pointer;
  border-radius: 4px;
  margin: 0 0.1em 0 0.1em;
  position: relative;
}

.singleButton:hover, .singleButton_active {
  background-color: rgba(255, 255, 255, 0.3);
}

.fastSlPreview {
  position: absolute;
  top: -250px;
  right: 0;
  background: linear-gradient(315deg, rgba(253, 251, 251, 0.9) 0%, rgba(235, 237, 238, 0.85) 100%);
  width: 900px;
  height: 230px;
  color: #005caf;
  border-radius: 5px;
  display: none;
  animation: fastSlEnter 0.33s;
  transition: opacity 0.33s;
}

.fastsave:hover .fastSPreview {
  display: block;
}

.fastload:hover .fastLPreview {
  display: block;
}

@keyframes fastSlEnter {
  0% {
    opacity: 0;
  }
  100% {
    opacity: 1;
  }
}

.slPreviewMain {
  padding: 0.5em 0.5em 0.5em 0.5em;
  display: flex;
  box-sizing: border-box;
  height: 100%;
  width: 100%;
}

.imgContainer {
  display: flex;
  overflow: hidden;
  border-radius: 5px;
  //outline: 4px solid #005caf;
  flex-shrink: 0;
  height: 100%;
}

.textContainer {
  overflow: hidden;
  padding: 0 0 0 0.5em;
}



================================================
FILE: webgal/src/UI/BottomControlPanel/BottomControlPanel.tsx
================================================
import { switchAuto } from '@/Core/controller/gamePlay/autoPlay';
import { backToTitle } from '@/Core/controller/gamePlay/backToTitle';
import { switchFast } from '@/Core/controller/gamePlay/fastSkip';
import { loadGame } from '@/Core/controller/storage/loadGame';
import { saveGame } from '@/Core/controller/storage/saveGame';
import { showGlogalDialog, switchControls } from '@/UI/GlobalDialog/GlobalDialog';
import { easyCompile } from '@/UI/Menu/SaveAndLoad/Save/Save';
import useFullScreen from '@/hooks/useFullScreen';
import useSoundEffect from '@/hooks/useSoundEffect';
import useTrans from '@/hooks/useTrans';
import { setMenuPanelTag, setVisibility } from '@/store/GUIReducer';
import { componentsVisibility, MenuPanelTag } from '@/store/guiInterface';
import { RootState } from '@/store/store';
import {
  AlignTextLeftOne,
  DoubleDown,
  DoubleRight,
  DoubleUp,
  FolderOpen,
  FullScreen,
  Home,
  Lock,
  OffScreen,
  PlayOne,
  PreviewCloseOne,
  PreviewOpen,
  ReplayMusic,
  Save,
  SettingTwo,
  Unlock,
} from '@icon-park/react';
import { useTranslation } from 'react-i18next';
import { useDispatch, useSelector } from 'react-redux';
import styles from './bottomControlPanel.module.scss';

export const BottomControlPanel = () => {
  const t = useTrans('gaming.');
  const strokeWidth = 2.5;
  const { i18n } = useTranslation();
  const { playSeEnter, playSeClick, playSeDialogOpen } = useSoundEffect();
  const lang = i18n.language;
  const isFr = lang === 'fr';
  let size = 42;
  let fontSize = '150%';
  if (isFr) {
    fontSize = '125%';
    size = 40;
  }
  const { isSupported: isFullscreenSupport, isFullScreen, toggle: toggleFullscreen } = useFullScreen();
  const GUIStore = useSelector((state: RootState) => state.GUI);
  const stageState = useSelector((state: RootState) => state.stage);
  const dispatch = useDispatch();
  const setComponentVisibility = (component: keyof componentsVisibility, visibility: boolean) => {
    dispatch(setVisibility({ component, visibility }));
  };
  const setMenuPanel = (menuPanel: MenuPanelTag) => {
    dispatch(setMenuPanelTag(menuPanel));
  };

  const saveData = useSelector((state: RootState) => state.saveData.saveData);
  let fastSlPreview = (
    <div style={{ height: '100%', width: '100%', display: 'flex', justifyContent: 'center', alignItems: 'center' }}>
      <div style={{ fontSize: '125%' }}>{t('noSaving')}</div>
    </div>
  );
  if (saveData[0]) {
    const data = saveData[0];
    fastSlPreview = (
      <div className={styles.slPreviewMain}>
        <div className={styles.imgContainer}>
          <img style={{ height: '100%' }} alt="q-save-preview image" src={data.previewImage} />
        </div>
        <div className={styles.textContainer}>
          <div>{easyCompile(data.nowStageState.showName)}</div>
          <div style={{ fontSize: '75%', color: 'rgb(55,60,56)' }}>{easyCompile(data.nowStageState.showText)}</div>
        </div>
      </div>
    );
  }

  return (
    // <div className={styles.ToCenter}>
    <>
      {GUIStore.showTextBox && stageState.enableFilm === '' && (
        <div className={styles.main} style={{ visibility: GUIStore.controlsVisibility ? 'visible' : 'hidden' }}>
          {GUIStore.showTextBox && (
            <span
              className={styles.singleButton}
              style={{ fontSize }}
              onClick={() => {
                setComponentVisibility('showTextBox', false);
                playSeClick();
              }}
              onMouseEnter={playSeEnter}
            >
              <PreviewCloseOne
                className={styles.button}
                theme="outline"
                size={size}
                fill="#f5f5f7"
                strokeWidth={strokeWidth}
              />
              <span className={styles.button_text}>{t('buttons.hide')}</span>
            </span>
          )}
          {!GUIStore.showTextBox && (
            <span
              className={styles.singleButton}
              style={{ fontSize }}
              onClick={() => {
                setComponentVisibility('showTextBox', true);
                playSeClick();
              }}
              onMouseEnter={playSeEnter}
            >
              <PreviewOpen
                className={styles.button}
                theme="outline"
                size={size}
                fill="#f5f5f7"
                strokeWidth={strokeWidth}
              />
              <span className={styles.button_text}>{t('buttons.show')}</span>
            </span>
          )}
          <span
            className={styles.singleButton}
            style={{ fontSize }}
            onClick={() => {
              setComponentVisibility('showBacklog', true);
              setComponentVisibility('showTextBox', false);
              playSeClick();
            }}
            onMouseEnter={playSeEnter}
          >
            <AlignTextLeftOne
              className={styles.button}
              theme="outline"
              size={size}
              fill="#f5f5f7"
              strokeWidth={strokeWidth}
            />
            <span className={styles.button_text}>{t('buttons.backlog')}</span>
          </span>
          <span
            className={styles.singleButton}
            style={{ fontSize }}
            onClick={() => {
              let VocalControl: any = document.getElementById('currentVocal');
              if (VocalControl !== null) {
                VocalControl.currentTime = 0;
                VocalControl.pause();
                VocalControl?.play();
              }
              playSeClick();
            }}
            onMouseEnter={playSeEnter}
          >
            <ReplayMusic
              className={styles.button}
              theme="outline"
              size={size}
              fill="#f5f5f7"
              strokeWidth={strokeWidth}
            />
            <span className={styles.button_text}>{t('buttons.replay')}</span>
          </span>
          <span
            id="Button_ControlPanel_auto"
            className={styles.singleButton}
            style={{ fontSize }}
            onClick={() => {
              switchAuto();
              playSeClick();
            }}
            onMouseEnter={playSeEnter}
          >
            <PlayOne className={styles.button} theme="outline" size={size} fill="#f5f5f7" strokeWidth={strokeWidth} />
            <span className={styles.button_text}>{t('buttons.auto')}</span>
          </span>
          <span
            id="Button_ControlPanel_fast"
            className={styles.singleButton}
            style={{ fontSize }}
            onClick={() => {
              switchFast();
              playSeClick();
            }}
            onMouseEnter={playSeEnter}
          >
            <DoubleRight
              className={styles.button}
              theme="outline"
              size={size}
              fill="#f5f5f7"
              strokeWidth={strokeWidth}
            />
            <span className={styles.button_text}>{t('buttons.forward')}</span>
          </span>
          <span
            className={styles.singleButton + ' ' + styles.fastsave}
            style={{ fontSize }}
            onClick={() => {
              saveGame(0);
              playSeClick();
            }}
            onMouseEnter={playSeEnter}
          >
            <DoubleDown
              className={styles.button}
              theme="outline"
              size={size}
              fill="#f5f5f7"
              strokeWidth={strokeWidth}
            />
            <span className={styles.button_text}>{t('buttons.quicklySave')}</span>
            <div className={styles.fastSlPreview + ' ' + styles.fastSPreview}>{fastSlPreview}</div>
          </span>
          <span
            className={styles.singleButton + ' ' + styles.fastload}
            style={{ fontSize }}
            onClick={() => {
              loadGame(0);
              playSeClick();
            }}
            onMouseEnter={playSeEnter}
          >
            <DoubleUp className={styles.button} theme="outline" size={size} fill="#f5f5f7" strokeWidth={strokeWidth} />
            <span className={styles.button_text}>{t('buttons.quicklyLoad')}</span>
            <div className={styles.fastSlPreview + ' ' + styles.fastLPreview}>{fastSlPreview}</div>
          </span>
          <span
            className={styles.singleButton}
            style={{ fontSize }}
            onClick={() => {
              setMenuPanel(MenuPanelTag.Save);
              setComponentVisibility('showMenuPanel', true);
              playSeClick();
            }}
            onMouseEnter={playSeEnter}
          >
            <Save className={styles.button} theme="outline" size={size} fill="#f5f5f7" strokeWidth={strokeWidth} />
            <span className={styles.button_text}>{t('buttons.save')}</span>
          </span>
          <span
            className={styles.singleButton}
            style={{ fontSize }}
            onClick={() => {
              setMenuPanel(MenuPanelTag.Load);
              setComponentVisibility('showMenuPanel', true);
              playSeClick();
            }}
            onMouseEnter={playSeEnter}
          >
            <FolderOpen
              className={styles.button}
              theme="outline"
              size={size}
              fill="#f5f5f7"
              strokeWidth={strokeWidth}
            />
            <span className={styles.button_text}>{t('buttons.load')}</span>
          </span>
          <span
            className={styles.singleButton}
            style={{ fontSize }}
            onClick={() => {
              setMenuPanel(MenuPanelTag.Option);
              setComponentVisibility('showMenuPanel', true);
              playSeClick();
            }}
            onMouseEnter={playSeEnter}
          >
            <SettingTwo
              className={styles.button}
              theme="outline"
              size={size}
              fill="#f5f5f7"
              strokeWidth={strokeWidth}
            />
            <span className={styles.button_text}>{t('buttons.options')}</span>
          </span>
          <span
            className={styles.singleButton}
            style={{ fontSize }}
            onClick={() => {
              playSeDialogOpen();
              showGlogalDialog({
                title: t('buttons.titleTips'),
                leftText: t('$common.yes'),
                rightText: t('$common.no'),
                leftFunc: () => {
                  backToTitle();
                },
                rightFunc: () => {},
              });
            }}
            onMouseEnter={playSeEnter}
          >
            <Home className={styles.button} theme="outline" size={size} fill="#f5f5f7" strokeWidth={strokeWidth} />
            <span className={styles.button_text}>{t('buttons.title')}</span>
          </span>
          {isFullscreenSupport && (
            <span
              className={`${styles.singleButton}`}
              style={{ fontSize }}
              onClick={toggleFullscreen}
              onMouseEnter={playSeEnter}
            >
              {!isFullScreen && (
                <FullScreen
                  className={styles.button}
                  theme="outline"
                  size={size}
                  fill="#f5f5f7"
                  strokeWidth={strokeWidth}
                />
              )}
              {isFullScreen && (
                <OffScreen
                  className={styles.button}
                  theme="outline"
                  size={size}
                  fill="#f5f5f7"
                  strokeWidth={strokeWidth}
                />
              )}
              <span className={styles.button_text}>{t('buttons.fullscreen')}</span>
            </span>
          )}
          <span
            className={styles.singleButton}
            style={{ fontSize }}
            onClick={() => {
              switchControls();
              playSeClick();
            }}
            onMouseEnter={playSeEnter}
          >
            {GUIStore.showControls ? (
              <Lock className={styles.button} theme="outline" size={size} fill="#f5f5f7" strokeWidth={strokeWidth} />
            ) : (
              <Unlock className={styles.button} theme="outline" size={size} fill="#f5f5f7" strokeWidth={strokeWidth} />
            )}
          </span>
        </div>
      )}
    </>
    // </div>
  );
};



================================================
FILE: webgal/src/UI/BottomControlPanel/bottomControlPanelFilm.module.scss
================================================
.tag {
  position: absolute;
  top: 2.5%;
  left: 2.5%;
  color: white;
  z-index: 10;
  padding: 10px 10px 5px 10px;
  border-radius: 100px;
  transition: background-color 0.33s;
}

.tag:hover {
  background-color: rgba(255, 255, 255, 0.5);
}

.container {
  color: white;
  position: absolute;
  top: 0;
  width: 100%;
  height: 100%;
  display: flex;
  flex-flow: column;
  background-color: rgba(0, 0, 0, 0.7);
  z-index: 9;
  padding: 7em 5em 5em 10em;
  opacity: 0;
  animation: showContainer 1s forwards;
  transition: background-color 0.33s;
}

.singleButton {
  padding: 0.5em 0 0.5em 0;
}

.button_text {
  font-family: "思源宋体", serif;
  font-size: 250%;
  letter-spacing: 0.07em;
  transition: text-shadow 0.33s;
}

.button_text:hover {
  text-shadow: 0 0 15px rgba(255, 255, 255, 1);
}

@keyframes showContainer {
  0% {
    opacity: 0;
  }
  100% {
    opacity: 1;
  }
}



================================================
FILE: webgal/src/UI/BottomControlPanel/BottomControlPanelFilm.tsx
================================================
import styles from './bottomControlPanelFilm.module.scss';
import { switchAuto } from '@/Core/controller/gamePlay/autoPlay';
import { switchFast } from '@/Core/controller/gamePlay/fastSkip';
import { useDispatch, useSelector } from 'react-redux';
import { RootState } from '@/store/store';
import { setMenuPanelTag, setVisibility } from '@/store/GUIReducer';
import { componentsVisibility, MenuPanelTag } from '@/store/guiInterface';
import { backToTitle } from '@/Core/controller/gamePlay/backToTitle';
import { useValue } from '@/hooks/useValue';
import { HamburgerButton } from '@icon-park/react';

export const BottomControlPanelFilm = () => {
  const showPanel = useValue(false);
  const stageState = useSelector((state: RootState) => state.stage);
  const dispatch = useDispatch();
  const setComponentVisibility = (component: keyof componentsVisibility, visibility: boolean) => {
    dispatch(setVisibility({ component, visibility }));
  };
  const setMenuPanel = (menuPanel: MenuPanelTag) => {
    dispatch(setMenuPanelTag(menuPanel));
  };
  return (
    <>
      {stageState.enableFilm !== '' && (
        <>
          <div
            className={styles.tag}
            onClick={() => {
              showPanel.set(!showPanel.value);
            }}
          >
            <HamburgerButton theme="outline" size="32" fill="#fff" />
          </div>
          {showPanel.value && (
            <div className={styles.container}>
              <span
                className={styles.singleButton}
                onClick={() => {
                  setComponentVisibility('showBacklog', true);
                  setComponentVisibility('showTextBox', false);
                  showPanel.set(!showPanel.value);
                }}
              >
                <span className={styles.button_text}>剧情回想 / BACKLOG</span>
              </span>
              <span
                className={styles.singleButton}
                onClick={() => {
                  showPanel.set(!showPanel.value);
                  let VocalControl: any = document.getElementById('currentVocal');
                  if (VocalControl !== null) {
                    VocalControl.currentTime = 0;
                    VocalControl.pause();
                    VocalControl?.play();
                  }
                }}
              >
                <span className={styles.button_text}>重播语音 / REPLAY VOICE</span>
              </span>
              <span
                id="Button_ControlPanel_auto"
                className={styles.singleButton}
                onClick={() => {
                  switchAuto();
                  showPanel.set(!showPanel.value);
                }}
              >
                <span className={styles.button_text}>自动模式 / AUTO</span>
              </span>
              <span
                id="Button_ControlPanel_fast"
                className={styles.singleButton}
                onClick={() => {
                  switchFast();
                  showPanel.set(!showPanel.value);
                }}
              >
                <span className={styles.button_text}>快进 / FAST</span>
              </span>
              <span
                className={styles.singleButton}
                onClick={() => {
                  showPanel.set(!showPanel.value);
                  setMenuPanel(MenuPanelTag.Save);
                  setComponentVisibility('showMenuPanel', true);
                }}
              >
                <span className={styles.button_text}>存档 / SAVE</span>
              </span>
              <span
                className={styles.singleButton}
                onClick={() => {
                  showPanel.set(!showPanel.value);
                  setMenuPanel(MenuPanelTag.Load);
                  setComponentVisibility('showMenuPanel', true);
                }}
              >
                <span className={styles.button_text}>读档 / LOAD</span>
              </span>
              <span
                className={styles.singleButton}
                onClick={() => {
                  showPanel.set(!showPanel.value);
                  setMenuPanel(MenuPanelTag.Option);
                  setComponentVisibility('showMenuPanel', true);
                }}
              >
                <span className={styles.button_text}>选项 / OPTIONS</span>
              </span>
              <span
                className={styles.singleButton}
                onClick={() => {
                  showPanel.set(!showPanel.value);
                  backToTitle();
                }}
              >
                <span className={styles.button_text}>标题 / TITLE</span>
              </span>
            </div>
          )}
        </>
      )}
    </>
  );
};



================================================
FILE: webgal/src/UI/DevPanel/devPanel.module.scss
================================================
.devPanelMain {
  font-size: 150%;
  position: absolute;
  right: 0;
  top: 0;
  bottom: 0;
  width: 35%;
  background: rgba(255, 255, 255, 0.75);
  z-index: 99;
  overflow: auto;
}

.devPanelOpener {
  position: absolute;
  right: 5px;
  top: 5px;
  background: rgba(255, 255, 255, 0.75);
  z-index: 100;
  padding: 3px 7px 3px 7px;
  border-radius: 4px;
  cursor: pointer;
}



================================================
FILE: webgal/src/UI/DevPanel/DevPanel.tsx
================================================
import styles from './devPanel.module.scss';
import { useValue } from '@/hooks/useValue';
import { getPixiSscreenshot } from '@/UI/DevPanel/devFunctions/getPixiSscreenshot';
import { useEffect } from 'react';
import { useSelector } from 'react-redux';
import { RootState } from '@/store/store';
import { useTranslation } from 'react-i18next';

import { WebGAL } from '@/Core/WebGAL';

export default function DevPanel() {
  // 控制显隐
  function isShowDevPanel() {
    const hash = window.location.hash;
    return !!hash.match(/dev/);
  }
  const isOpenDevPanel = useValue(false);
  const hash = useValue(window.location.hash);
  const stageState = useSelector((state: RootState) => state.stage);
  useEffect(() => {
    window.onhashchange = () => {
      hash.set(window.location.hash);
    };
  }, []);
  const isShow = isShowDevPanel();

  const { t, i18n } = useTranslation();

  const devMainArea = (
    <>
      <div onClick={() => getPixiSscreenshot()}>Save PIXI Screenshot</div>
      <div>Current Language:{i18n.language}</div>
      <div onClick={() => WebGAL.gameplay.pixiStage?.removeAnimation('snow-ticker')}>Remove Snow Ticker</div>
      <div>Stage State</div>
      <div>{JSON.stringify(stageState, null, '  ')}</div>
    </>
  );
  return (
    <>
      {isShow && isOpenDevPanel.value && (
        <div className={styles.devPanelMain}>
          <div style={{ display: 'flex', alignItems: 'center' }}>
            <div
              onClick={() => isOpenDevPanel.set(false)}
              style={{ fontSize: '150%', padding: '0 0 0 15px', cursor: 'pointer' }}
            >
              ×
            </div>
            <div style={{ padding: '0 0 0 15px', fontSize: '115%' }}>WebGAL DEV PANEL</div>
          </div>
          <div style={{ padding: '10px 10px 10px 10px', overflow: 'auto' }}>{devMainArea}</div>
        </div>
      )}
      {!isOpenDevPanel.value && isShow && (
        <div onClick={() => isOpenDevPanel.set(true)} className={styles.devPanelOpener}>
          Open Dev Panel
        </div>
      )}
    </>
  );
}



================================================
FILE: webgal/src/UI/DevPanel/devFunctions/getPixiSscreenshot.ts
================================================
export function getPixiSscreenshot() {
  const canvas: HTMLCanvasElement = document.getElementById('pixiCanvas')! as HTMLCanvasElement;
  canvas.toBlob((b) => {
    if (b) {
      const a = document.createElement('a');
      document.body.append(a);
      a.download = 'screenshot';
      a.href = URL.createObjectURL(b);
      a.click();
      a.remove();
    }
  }, 'image/png');
}



================================================
FILE: webgal/src/UI/etc/QuickSL.tsx
================================================
export const QuickSL = () => {
  return <div />;
};



================================================
FILE: webgal/src/UI/Extra/extra.module.scss
================================================
.extra {
  width: 100%;
  height: 100%;
  position: absolute;
  top: 0;
  left: 0;
  z-index: 14;
  background-image: linear-gradient(135deg, #93a5cf 0%, #e4efe9 100%);;
  padding: 2em 2em 2em 2em;
  box-sizing: border-box;
}

.extra_top {
  padding: 0 0 0 0;
  display: flex;
  height: 10%;
}

.extra_top_icon {
  padding: 0.6em 0.6em 0 0.6em;
  border-radius: 1000px;
  transform: translate(0, -13px);
  cursor: pointer;
}

.extra_top_icon:hover {
  background: rgba(255, 255, 255, 0.25);
  animation: extra_icon_softin 0.25s ease-out forwards;
}

@keyframes extra_icon_softin {
  0% {
    background: rgba(255, 255, 255, 0);
  }
  100% {
    background: rgba(0, 0, 0, 0.25);
  }
}


.extra_title {
  font-family: "思源宋体", serif;
  height: 100%;
  line-height: 100%;
  font-size: 325%;
  font-weight: bold;
  color: transparent;
  background: linear-gradient(150deg, rgba(255, 255, 255, 1) 0%, rgba(255, 255, 255, 1) 75%, #51A8DD 100%);
  -webkit-background-clip: text;
}

.mainContainer {
  box-sizing: border-box;
  padding: 0 2em 0 2em;
  display: flex;
  height: 92%;
  flex-flow: column;
}

.bgmContainer {
  left: 50px;
  right: 50px;
  bottom: 30px;
  position: absolute;
  overflow: auto;
  //width: 100%;
  //height: 70%;
  box-sizing: border-box;
  display: flex;
  flex-flow: column-reverse;
  align-content: center;
  background-image: linear-gradient(315deg, rgba(163, 189, 237, 0.95) 0%, rgba(105, 145, 199, 0.95) 100%);
  padding: 1em 2em 1em 2em;
  border-radius: 4px;
  transition: max-height 0.5s;
  z-index: 2;
}

.bgmListContainer {
  z-index: 2;
  bottom: 0;
  //overflow: hidden;
  width: 100%;
  box-sizing: border-box;
  display: flex;
  flex: 1;
  flex-flow: row;
  justify-content: flex-start;
  align-items: flex-start;
  margin: 0 0 15px 0;
  flex-wrap: wrap;
  overflow: auto;
}

.bgmPlayerMain {
  display: flex;
}

.bgmControlButton {
  padding: 0.6em 1.2em 0.2em 1.2em;
  margin: 0 5px 0 5px;
  box-sizing: border-box;
  border-radius: 4px;
  border: 1px solid rgba(255, 255, 255, 0.5);
  cursor: pointer;
  transition: background-color 0.33s, color 0.33s;
  flex-shrink: 0;
}

.bgmControlButton:hover {
  box-shadow: 0 0 10px 5px rgba(255, 255, 255, 0.35);
}

.bgmName {
  color: rgba(255, 255, 255, 0.8);
  font-family: "思源宋体", serif;
  font-size: 155%;
  margin: 5px 5px 0 15px;
  overflow: hidden;
}

.bgmElement {
  font-family: "思源宋体", serif;
  padding: 0.5em 1em 0.5em 1em;
  overflow: hidden;
  background-color: rgba(0, 0, 0, 0.1);
  border-radius: 5px;
  color: white;
  font-size: 125%;
  margin: 0.5em 1em 0.5em 0.5em;
  transition: background-color 1s, color 1s;
  opacity: 1;
  //animation: bgmElement_In 0.5s forwards ease-out;
  cursor: pointer;
  width: 28%;
  flex-shrink: 0;
}

@keyframes bgmElement_In {
  0% {
    opacity: 0.95;
    //transform: translate(-50px, 0);
  }
  100% {
    opacity: 1;
  }
}

.bgmElement:hover {
  background-color: rgba(255, 255, 255, 0.65);
  color: #666;
  transition: background-color 0.5s, color 0.5s;
}

.bgmElement_active {
  background-color: rgba(255, 255, 255, 0.85) !important;
  color: #666;
}

.cgMain {
  width: 100%;
  height: 88%;
}

.cgContainer {
  width: 100%;
  display: flex;
  flex-wrap: wrap;
  justify-content: flex-start;
  align-items: flex-start;
  align-content: flex-start;
  height: 90%;
  box-sizing: border-box;
  padding: 4em 0 0 2em;
}

.cgElement {
  width: 22.5%;
  height: 37.5%;
  background-color: rgba(255, 255, 255, 0.75);
  box-shadow: 0 0 15px 5px rgba(0, 0, 0, 0.35);
  box-sizing: border-box;
  padding: 0.75em 0.75em 0.75em 0.75em;
  opacity: 0;
  margin: 1em 1em 1em 1em;
  animation-delay: 100ms;
  z-index: 1;
  position: relative;
  cursor: pointer;
}

.cgShowDiv {
  height: 8%;
  width: 100%;
  display: flex;
  flex-flow: row;
  justify-content: center;
  align-items: flex-end;
}

.cgShowDivWarpper {
  display: flex;
  flex-flow: row;
  justify-content: center;
  align-items: flex-end;
  //background: rgba(255, 255, 255, 0.35);
  border-radius: 7px;
  padding: 12px 15px;
}

.cgNav {
  font-size: 170%;
  background-color: rgba(255,255,255,0.5);
  color: #666;
  padding: 0.12em 1em 0.12em 1em;
  margin: 0 0.25em 0 0.25em;
  //width: 20px;
  text-align: center;
  cursor: pointer;
  transition: background-color 0.5s, color 0.5s, font-weight 0.5s;
  border-radius: 7px;
}

.cgNav:first-child {
  margin-left: 0;
}

.cgNav:last-child {
  margin-right: 0;
}

.cgNav_active {
  background-color: rgba(255,255,255,0.7) !important;
  color: #005CAF;
}

.cgNav:hover {
  color: #005CAF;
  background-color: rgba(255,255,255,0.6);
}


.showFullContainer {
  z-index: 13;
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background: rgba(0, 0, 0, 0.1);
  display: flex;
  justify-content: center;
  align-items: center;
}

.showFullCgMain {
  cursor: pointer;
  width: 80%;
  height: 80%;
  box-sizing: border-box;
  padding: 2em 2em 2em 2em;
  background: rgba(255, 255, 255, 0.95);
  animation: fullCgIn 0.5s ease-out forwards;
  opacity: 0;
}

$initialTransform: scale(1.05, 1.05) translate(-25px, -50px) rotateX(-10deg) rotateY(10deg);
$endTransform: scale(1, 1) translate3d(0, 0, 0);

@keyframes fullCgIn {
  0% {
    opacity: 0;
    transform: $initialTransform;
  }
  100% {
    opacity: 1;
    transform: $endTransform;
  }
}



================================================
FILE: webgal/src/UI/Extra/Extra.tsx
================================================
import styles from './extra.module.scss';
import { useDispatch, useSelector } from 'react-redux';
import { RootState } from '@/store/store';
import { setVisibility } from '@/store/GUIReducer';
import { CloseSmall } from '@icon-park/react';
import { ExtraBgm } from '@/UI/Extra/ExtraBgm';
import { ExtraCg } from './ExtraCg';
import useTrans from '@/hooks/useTrans';
import useSoundEffect from '@/hooks/useSoundEffect';

export function Extra() {
  const { playSeClick } = useSoundEffect();
  const showExtra = useSelector((state: RootState) => state.GUI.showExtra);
  const dispatch = useDispatch();

  const t = useTrans('extra.');
  return (
    <>
      {showExtra && (
        <div className={styles.extra}>
          <div className={styles.extra_top}>
            <CloseSmall
              className={styles.extra_top_icon}
              onClick={() => {
                dispatch(setVisibility({ component: 'showExtra', visibility: false }));
                playSeClick();
              }}
              onMouseEnter={playSeClick}
              theme="outline"
              size="4em"
              fill="#fff"
              strokeWidth={3}
            />
            <div className={styles.extra_title}>{t('title')}</div>
          </div>
          <div className={styles.mainContainer}>
            <ExtraCg />
            <ExtraBgm />
          </div>
        </div>
      )}
    </>
  );
}



================================================
FILE: webgal/src/UI/Extra/ExtraBgm.tsx
================================================
import { useDispatch, useSelector } from 'react-redux';
import { RootState } from '@/store/store';
import React from 'react';
import styles from '@/UI/Extra/extra.module.scss';
import { useValue } from '@/hooks/useValue';
import { setStage } from '@/store/stageReducer';
import { GoEnd, GoStart, MusicList, PlayOne, SquareSmall } from '@icon-park/react';
import useSoundEffect from '@/hooks/useSoundEffect';
import { setGuiAsset } from '@/store/GUIReducer';

export function ExtraBgm() {
  const { playSeClick, playSeEnter } = useSoundEffect();
  // 检查当前正在播放的bgm是否在bgm列表内
  const currentBgmSrc = useSelector((state: RootState) => state.GUI.titleBgm);
  const extraState = useSelector((state: RootState) => state.userData.appreciationData);
  const initName = 'Title_BGM';
  // 是否展示 bgm 列表
  const isShowBgmList = useValue(false);
  let foundCurrentBgmName = initName;
  let foundCurrentBgmIndex = -1;
  const iconSize = 39;
  const bgmPlayerHeight = isShowBgmList.value ? '80%' : '10%';
  const bgmListLen = extraState.bgm.length;
  extraState.bgm.forEach((e, i) => {
    if (e.url === currentBgmSrc) {
      foundCurrentBgmName = e.name;
      foundCurrentBgmIndex = i;
    }
  });
  const currentPlayingBgmName = useValue('');
  if (foundCurrentBgmName !== initName && foundCurrentBgmName !== currentPlayingBgmName.value) {
    currentPlayingBgmName.set(foundCurrentBgmName);
  }
  const dispatch = useDispatch();

  function setBgmByIndex(index: number) {
    const e = extraState.bgm[index];
    currentPlayingBgmName.set(e.name);
    dispatch(setGuiAsset({ asset: 'titleBgm', value: e.url }));
  }

  const showBgmList = extraState.bgm.map((e, i) => {
    let className = styles.bgmElement;
    if (e.name === currentPlayingBgmName.value) {
      className = className + ' ' + styles.bgmElement_active;
    }
    return (
      <div
        onClick={() => {
          playSeClick();
          currentPlayingBgmName.set(e.name);
          dispatch(setGuiAsset({ asset: 'titleBgm', value: e.url }));
        }}
        key={e.name}
        className={className}
        style={{
          animationDelay: `${i * 150}ms`,
        }}
        onMouseEnter={playSeEnter}
      >
        {e.name}
      </div>
    );
  });

  // If there are no BGM tracks available, don't render the player controls
  if (bgmListLen === 0) {
    return null;
  }

  return (
    <div className={styles.bgmContainer} style={{ maxHeight: bgmPlayerHeight }}>
      <div className={styles.bgmPlayerMain}>
        <div
          onClick={() => {
            playSeClick();
            if (foundCurrentBgmIndex <= 0) {
              setBgmByIndex(bgmListLen - 1);
            } else {
              setBgmByIndex(foundCurrentBgmIndex - 1);
            }
          }}
          onMouseEnter={playSeEnter}
          className={styles.bgmControlButton}
        >
          <GoStart theme="filled" size={iconSize} fill="#fff" strokeWidth={3} strokeLinejoin="miter" />
        </div>
        <div
          onClick={() => {
            playSeClick();
            const bgmControl: HTMLAudioElement = document.getElementById('currentBgm') as HTMLAudioElement;
            bgmControl?.play().then();
          }}
          onMouseEnter={playSeEnter}
          className={styles.bgmControlButton}
        >
          <PlayOne theme="filled" size={iconSize} fill="#fff" strokeWidth={3} strokeLinejoin="miter" />
        </div>
        <div
          onClick={() => {
            playSeClick();
            if (foundCurrentBgmIndex >= bgmListLen - 1) {
              setBgmByIndex(0);
            } else {
              setBgmByIndex(foundCurrentBgmIndex + 1);
            }
          }}
          onMouseEnter={playSeEnter}
          className={styles.bgmControlButton}
        >
          <GoEnd theme="filled" size={iconSize} fill="#fff" strokeWidth={3} strokeLinejoin="miter" />
        </div>
        <div
          onClick={() => {
            playSeClick();
            const bgmControl: HTMLAudioElement = document.getElementById('currentBgm') as HTMLAudioElement;
            bgmControl.pause();
          }}
          onMouseEnter={playSeEnter}
          className={styles.bgmControlButton}
        >
          <SquareSmall theme="filled" size={iconSize} fill="#fff" strokeWidth={3} strokeLinejoin="miter" />
        </div>
        <div className={styles.bgmName}>{foundCurrentBgmName}</div>
        <div
          onClick={() => {
            playSeClick();
            isShowBgmList.set(!isShowBgmList.value);
          }}
          onMouseEnter={playSeEnter}
          className={styles.bgmControlButton}
          style={{ marginLeft: 'auto' }}
        >
          <MusicList theme="filled" size={iconSize} fill="#fff" strokeWidth={3} strokeLinejoin="miter" />
        </div>
      </div>
      {isShowBgmList.value && <div className={styles.bgmListContainer}> {showBgmList}</div>}
    </div>
  );
}



================================================
FILE: webgal/src/UI/Extra/ExtraCg.tsx
================================================
import styles from '@/UI/Extra/extra.module.scss';
import React from 'react';
import { useSelector } from 'react-redux';
import { RootState } from '@/store/store';
import { useValue } from '@/hooks/useValue';
import './extraCG_animation_List.scss';
import { ExtraCgElement } from '@/UI/Extra/ExtraCgElement';
import useSoundEffect from '@/hooks/useSoundEffect';

export function ExtraCg() {
  const cgPerPage = 8;
  const extraState = useSelector((state: RootState) => state.userData.appreciationData);
  const pageNumber = Math.ceil(extraState.cg.length / cgPerPage);
  // const pageNumber = 10;
  const currentPage = useValue(1);
  const { playSeEnter, playSeClick } = useSoundEffect();

  // 开始生成立绘鉴赏的图片
  const showCgList = [];
  const len = extraState.cg.length;
  for (
    let i = (currentPage.value - 1) * cgPerPage;
    i < Math.min(len, (currentPage.value - 1) * cgPerPage + cgPerPage);
    i++
  ) {
    const index = i - (currentPage.value - 1) * cgPerPage;
    const deg = Random(-5, 5);
    const temp = (
      <ExtraCgElement
        name={extraState.cg[i].name}
        resourceUrl={extraState.cg[i].url}
        transformDeg={deg}
        index={index}
        key={index.toString() + extraState.cg[i].url}
      />
    );
    showCgList.push(temp);
  }

  // 生成cg鉴赏的导航
  const showNav = [];
  for (let i = 1; i <= pageNumber; i++) {
    let className = styles.cgNav;
    if (currentPage.value === i) {
      className = className + ' ' + styles.cgNav_active;
    }
    const temp = (
      <div
        onClick={() => {
          currentPage.set(i);
          playSeClick();
        }}
        key={'nav' + i}
        onMouseEnter={playSeEnter}
        className={className}
      >
        {i}
      </div>
    );
    showNav.push(temp);
  }

  return (
    <div className={styles.cgMain}>
      <div className={styles.cgShowDiv}>
        <div className={styles.cgShowDivWarpper}>{showNav}</div>
      </div>
      <div className={styles.cgContainer}>{showCgList}</div>
    </div>
  );
}

function Random(min: number, max: number) {
  return Math.round(Math.random() * (max - min)) + min;
}



================================================
FILE: webgal/src/UI/Extra/extraCG_animation_List.scss
================================================
$initialTransform: scale(1.15, 1.15) translate(-50px, -125px) rotateX(-25deg) rotateY(25deg);
$endTransform: scale(1, 1) translate3d(0, 0, 0);

@keyframes cg_softIn_-5 {
  0% {
    opacity: 0;
    transform: $initialTransform;
  }
  100% {
    opacity: 1;
    transform: $endTransform +  rotate(-5deg);
  }
}

@keyframes cg_softIn_-4 {
  0% {
    opacity: 0;
    transform: $initialTransform;
  }
  100% {
    opacity: 1;
    transform: $endTransform +  rotate(-4deg);
  }
}

@keyframes cg_softIn_-3 {
  0% {
    opacity: 0;
    transform: $initialTransform;
  }
  100% {
    opacity: 1;
    transform: $endTransform +  rotate(-3deg);
  }
}

@keyframes cg_softIn_-2 {
  0% {
    opacity: 0;
    transform: $initialTransform;
  }
  100% {
    opacity: 1;
    transform: $endTransform +  rotate(-2deg);
  }
}

@keyframes cg_softIn_-1 {
  0% {
    opacity: 0;
    transform: $initialTransform;
  }
  100% {
    opacity: 1;
    transform: $endTransform +  rotate(-1deg);
  }
}

@keyframes cg_softIn_0 {
  0% {
    opacity: 0;
    transform: $initialTransform;
  }
  100% {
    opacity: 1;
    transform: $endTransform +  rotate(0);
  }
}

@keyframes cg_softIn_1 {
  0% {
    opacity: 0;
    transform: $initialTransform;
  }
  100% {
    opacity: 1;
    transform: $endTransform +  rotate(1deg);
  }
}

@keyframes cg_softIn_2 {
  0% {
    opacity: 0;
    transform: $initialTransform;
  }
  100% {
    opacity: 1;
    transform: $endTransform +  rotate(2deg);
  }
}

@keyframes cg_softIn_3 {
  0% {
    opacity: 0;
    transform: $initialTransform;
  }
  100% {
    opacity: 1;
    transform: $endTransform +  rotate(3deg);
  }
}

@keyframes cg_softIn_4 {
  0% {
    opacity: 0;
    transform: $initialTransform;
  }
  100% {
    opacity: 1;
    transform: $endTransform +  rotate(4deg);
  }
}

@keyframes cg_softIn_5 {
  0% {
    opacity: 0;
    transform: $initialTransform;
  }
  100% {
    opacity: 1;
    transform: $endTransform +  rotate(5deg);
  }
}



================================================
FILE: webgal/src/UI/Extra/ExtraCgElement.tsx
================================================
import { useValue } from '@/hooks/useValue';
import styles from '@/UI/Extra/extra.module.scss';
import React, { useMemo } from 'react';
import useSoundEffect from '@/hooks/useSoundEffect';

interface IProps {
  name: string;
  resourceUrl: string;
  transformDeg: number;
  index: number;
}

export function ExtraCgElement(props: IProps) {
  const showFull = useValue(false);
  const { playSeEnter, playSeClick } = useSoundEffect();

  // Determine if the resource is a video based on file extension
  const isVideo = useMemo(() => {
    const extension = props.resourceUrl.split('.').pop()?.toLowerCase() || '';
    return ['mp4', 'webm', 'mkv'].includes(extension);
  }, [props.resourceUrl]);

  // Determine if the resource is an image based on file extension
  const isImage = useMemo(() => {
    const extension = props.resourceUrl.split('.').pop()?.toLowerCase() || '';
    return ['jpg', 'jpeg', 'png', 'gif', 'webp', 'svg', 'bmp'].includes(extension);
  }, [props.resourceUrl]);

  // Render media content based on resource type
  const renderMedia = (fullScreen: boolean) => {
    if (isVideo) {
      return (
        <video
          src={props.resourceUrl}
          autoPlay
          loop
          muted
          playsInline
          style={{
            width: '100%',
            height: '100%',
            objectFit: 'cover',
          }}
        />
      );
    } else if (isImage) {
      return (
        <div
          style={{
            backgroundImage: `url('${props.resourceUrl}')`,
            backgroundSize: 'cover',
            backgroundPosition: 'center',
            width: '100%',
            height: '100%',
          }}
        />
      );
    } else {
      // Fallback for unsupported file types
      return (
        <div
          style={{
            backgroundImage: `url('${props.resourceUrl}')`,
            backgroundSize: 'cover',
            backgroundPosition: 'center',
            width: '100%',
            height: '100%',
          }}
        />
      );
    }
  };

  return (
    <>
      {showFull.value && (
        <div
          onClick={() => {
            showFull.set(!showFull.value);
            playSeClick();
          }}
          className={styles.showFullContainer}
          onMouseEnter={playSeEnter}
        >
          <div className={styles.showFullCgMain}>{renderMedia(true)}</div>
        </div>
      )}
      <div
        onClick={() => {
          showFull.set(!showFull.value);
          playSeClick();
        }}
        onMouseEnter={playSeEnter}
        style={{
          animation: `cg_softIn_${props.transformDeg} 1.5s ease-out ${100 + props.index * 100}ms forwards`,
        }}
        key={props.name}
        className={styles.cgElement}
      >
        {renderMedia(false)}
      </div>
    </>
  );
}



================================================
FILE: webgal/src/UI/GlobalDialog/globalDialog.module.scss
================================================
.GlobalDialog_main {
  height: 100%;
  width: 100%;
  position: absolute;
  z-index: 20;
  background: rgba(15, 37, 64, 0.39);
  color: white;
  opacity: 0.5;
  animation: showGlobalDialog 0.33s forwards;
  display: flex;
  justify-content: center;
  align-items: center;
  //font-family: "WebgalUI", -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Oxygen', 'Ubuntu', 'Cantarell', 'Fira Sans', 'Droid Sans', 'Helvetica Neue', sans-serif;
  font-family: "思源宋体", serif;
}

.glabalDialog_container_inner {
  width: 100%;
  height: 100%;
  display: flex;
  justify-content: center;
  align-items: center;
  flex-flow: column;
  background: linear-gradient(to right,
    rgba(0, 92, 175, 0) 0%,
    rgba(0, 92, 175, 0.5) 33%,
    rgba(0, 92, 175, 0.85) 50%,
    rgba(0, 92, 175, 0.5) 66%,
    rgba(0, 92, 175, 0) 100%
  );
  padding: 1em 5em 1.5em 5em;
}

.glabalDialog_container {
  height: 20%;
  width: 100%;
  border-top: 4px solid;
  border-bottom: 4px solid;
  border-image: linear-gradient(to right,
    rgba(255, 255, 255, 0.05) 0%,
    rgba(255, 255, 255, 0.85) 33%,
    rgba(255, 255, 255, 1) 50%,
    rgba(255, 255, 255, 0.85) 66%,
    rgba(255, 255, 255, 0.05) 100%
  ) 1;
  //padding: 1px 1px 1px 1px;
}

.title {
  font-size: 300%;
  text-shadow: 0 0 10px rgba(255, 255, 255, 0.5);
}

.button_list {
  display: flex;
  margin: auto 0 0 0;
}

.button {
  font-size: 200%;
  padding: 0.15em 1em 0.15em 1em;
  margin: 0.2em 1em 0.2em 1em;
  cursor: pointer;
  transition: background-color 0.33s, color 0.33s, font-weight 0.33s, transform 0.33s;
  text-shadow: 0 0 10px rgba(255, 255, 255, 1);
  border-radius: 5px;
  //background: rgba(0, 0, 0, 0.05);
}

.button:hover {
  font-weight: bold;
  color: #005caf;
  transform: scale(1.1, 1.1);
  text-shadow: 0 0 15px rgba(0, 0, 0, 0);
  background: rgba(255, 255, 255, 0.85);
}

@keyframes showGlobalDialog {
  0% {
    opacity: 0;
  }
  100% {
    opacity: 1;
  }
}



================================================
FILE: webgal/src/UI/GlobalDialog/GlobalDialog.tsx
================================================
import styles from './globalDialog.module.scss';
import ReactDOM from 'react-dom';
import { useSelector } from 'react-redux';
import { RootState, webgalStore } from '@/store/store';
import { setVisibility } from '@/store/GUIReducer';
import { useSEByWebgalStore } from '@/hooks/useSoundEffect';

export default function GlobalDialog() {
  const isGlobalDialogShow = useSelector((state: RootState) => state.GUI.showGlobalDialog);
  return <>{isGlobalDialogShow && <div id="globalDialogContainer" />}</>;
}

interface IShowGlobalDialogProps {
  title: string;
  leftText: string;
  rightText: string;
  leftFunc: Function;
  rightFunc: Function;
}

export function showGlogalDialog(props: IShowGlobalDialogProps) {
  const { playSeClick, playSeEnter } = useSEByWebgalStore();
  webgalStore.dispatch(setVisibility({ component: 'showGlobalDialog', visibility: true }));
  const handleLeft = () => {
    playSeClick();
    props.leftFunc();
    hideGlobalDialog();
  };
  const handleRight = () => {
    playSeClick();
    props.rightFunc();
    hideGlobalDialog();
  };
  const renderElement = (
    <div className={styles.GlobalDialog_main}>
      <div className={styles.glabalDialog_container}>
        <div className={styles.glabalDialog_container_inner}>
          <div className={styles.title}>{props.title}</div>
          <div className={styles.button_list}>
            <div className={styles.button} onClick={handleLeft} onMouseEnter={playSeEnter}>
              {props.leftText}
            </div>
            <div className={styles.button} onClick={handleRight} onMouseEnter={playSeEnter}>
              {props.rightText}
            </div>
          </div>
        </div>
      </div>
    </div>
  );
  setTimeout(() => {
    // eslint-disable-next-line react/no-deprecated
    ReactDOM.render(renderElement, document.getElementById('globalDialogContainer'));
  }, 100);
}

export function hideGlobalDialog() {
  webgalStore.dispatch(setVisibility({ component: 'showGlobalDialog', visibility: false }));
}

export function showControls() {
  webgalStore.dispatch(setVisibility({ component: 'showControls', visibility: true }));
}

export function hideControls() {
  webgalStore.dispatch(setVisibility({ component: 'showControls', visibility: false }));
}

export function switchControls() {
  if (webgalStore.getState().GUI.showControls === true) {
    hideControls();
  } else {
    showControls();
  }
}



================================================
FILE: webgal/src/UI/Logo/logo.module.scss
================================================
.Logo_main {
  width: 100%;
  height: 100%;
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  animation: change-img-anim 5s forwards;
  background-size: cover;
  z-index: 14;
}
@keyframes change-img-anim {
  0%{
    opacity: 0;
  }
  35%{
    opacity: 1;
  }
  65%{
    opacity: 1;
  }
  99%{
    opacity: 0;
  }
  100%{
    opacity: 0;
    display: none;
  }
}
.Logo_Back {
  width: 100%;
  height: 100%;
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  opacity: 1;
  bottom: 0;
  background-size: cover;
  z-index: 14;
  background: white;
}

.animationActive{
  animation: fadeout 5s forwards;
}

@keyframes fadeout {
  0%{
    opacity: 1;
  }
  99%{
    opacity: 0;
  }
  100%{
    opacity: 0;
    display: none;
  }
}



================================================
FILE: webgal/src/UI/Logo/Logo.tsx
================================================
import { FC, useEffect, useRef } from 'react';
import styles from './logo.module.scss';
import { useSelector } from 'react-redux';
import { RootState } from '@/store/store';
import { useValue } from '@/hooks/useValue';

/**
 * 标识
 * @constructor
 */
const Logo: FC = () => {
  const GUIState = useSelector((state: RootState) => state.GUI);
  const logoImage = GUIState.logoImage;
  const isEnterGame = GUIState.isEnterGame;
  const currentLogoIndex = useValue(-1);
  const currentTimeOutId = useValue<any>(-1);
  const animationDuration = 5000;

  const nextImg = () => {
    clearTimeout(currentTimeOutId.value);
    if (currentLogoIndex.value < logoImage.length - 1) {
      currentLogoIndex.set(currentLogoIndex.value + 1);
      currentTimeOutId.set(setTimeout(nextImg, animationDuration));
    } else {
      currentLogoIndex.set(-1);
    }
  };

  useEffect(() => {
    if (isEnterGame && logoImage.length > 0) {
      /**
       * 启动 Enter Logo
       */
      currentLogoIndex.set(0);
      currentTimeOutId.set(setTimeout(nextImg, animationDuration));
    }
  }, [isEnterGame]);

  const currentLogoUrl = currentLogoIndex.value === -1 ? '' : logoImage[currentLogoIndex.value];
  return (
    <>
      {currentLogoIndex.value !== -1 && (
        <div
          key={currentLogoIndex.value + 'wh'}
          className={
            styles.Logo_Back + ' ' + (currentLogoIndex.value === logoImage.length - 1 ? styles.animationActive : '')
          }
          style={{
            animationDuration: `${animationDuration}ms`,
          }}
        />
      )}
      {currentLogoUrl !== '' && (
        <div
          className={styles.Logo_main}
          key={currentLogoIndex.value + 'bg'}
          onClick={nextImg}
          style={{ backgroundImage: `url("${currentLogoUrl}")`, animationDuration: `${animationDuration}ms` }}
        />
      )}
    </>
  );
};

export default Logo;



================================================
FILE: webgal/src/UI/Menu/menu.module.scss
================================================
.Menu_main {
  width: 100%;
  height: 100%;
  position: absolute;
  z-index: 16;
  //backdrop-filter: blur(1px);
  animation: Menu_ShowSoftly 0.5s forwards;
  background-image: linear-gradient(to top, #accbee 0%, #e7f0fd 100%);
}

.Menu_TagContent {
  width: 100%;
  height: 90%;
}


@keyframes Menu_ShowSoftly {
  0% {
    opacity: 0;
  }
  100% {
    opacity: 1;
  }
}



================================================
FILE: webgal/src/UI/Menu/Menu.tsx
================================================
import { FC } from 'react';
import styles from './menu.module.scss';
import { MenuPanel } from './MenuPanel/MenuPanel';
import { Save } from './SaveAndLoad/Save/Save';
import { Load } from './SaveAndLoad/Load/Load';
import { Options } from './Options/Options';
import { useSelector } from 'react-redux';
import { RootState } from '@/store/store';
import { MenuPanelTag } from '@/store/guiInterface';

/**
 * Menu 页面，包括存读档、选项等
 * @constructor
 */
const Menu: FC = () => {
  const GUIState = useSelector((state: RootState) => state.GUI);
  let currentTag;
  // let menuBgColor = 'linear-gradient(135deg, rgba(253,251,251,0.95) 0%, rgba(235,237,238,1) 100%)';
  switch (GUIState.currentMenuTag) {
    case MenuPanelTag.Save:
      currentTag = <Save />;
      // menuBgColor = 'linear-gradient(135deg, #fdfbfb 0%, #ebedee 100%)';
      break;
    case MenuPanelTag.Load:
      currentTag = <Load />;
      // menuBgColor = 'linear-gradient(135deg, #fdfbfb 0%, #ebedee 100%)';
      break;
    case MenuPanelTag.Option:
      currentTag = <Options />;
      // menuBgColor = 'linear-gradient(135deg, #fdfbfb 0%, #ebedee 100%)';
      break;
  }
  return (
    <>
      {GUIState.showMenuPanel && (
        <div className={styles.Menu_main}>
          <div className={styles.Menu_TagContent}>{currentTag}</div>
          <MenuPanel />
        </div>
      )}
    </>
  );
};

export default Menu;



================================================
FILE: webgal/src/UI/Menu/MenuPanel/MenuIconMap.tsx
================================================
import { IMenuPanel } from '@/UI/Menu/MenuPanel/menuPanelInterface';
import { FolderOpen, Home, Logout, Save, SettingTwo } from '@icon-park/react';

/**
 * 通过图标名称返回正确的图标
 * @param props
 * @constructor
 */
export const MenuIconMap = (props: IMenuPanel) => {
  let returnIcon;
  switch (props.iconName) {
    case 'save':
      returnIcon = <Save theme="outline" size="1.2em" fill={props.iconColor} strokeWidth={2} />;
      break;
    case 'load':
      returnIcon = <FolderOpen theme="outline" size="1.2em" fill={props.iconColor} strokeWidth={2} />;
      break;
    case 'option':
      returnIcon = <SettingTwo theme="outline" size="1.2em" fill={props.iconColor} strokeWidth={2} />;
      break;
    case 'title':
      returnIcon = <Home theme="outline" size="1.2em" fill={props.iconColor} strokeWidth={2} />;
      break;
    case 'exit':
      returnIcon = <Logout theme="outline" size="1.2em" fill={props.iconColor} strokeWidth={2} />;
      break;
    default:
      returnIcon = <div />;
  }

  return returnIcon;
};



================================================
FILE: webgal/src/UI/Menu/MenuPanel/menuPanel.module.scss
================================================
.MenuPanel_main {
  width: 100%;
  height: 10%;
  display: flex;
  justify-content: center;
  align-items: center;
  //background-color: rgba(255, 255, 255, 1);
  //box-shadow: 0 0 45px 15px rgba(0, 0, 0, 0.05);
  padding: 0 55px;
}

.MenuPanel_button {
  padding: 0.25em 15px 0 15px;
  margin-right: 15px;
  display: flex;
  justify-content: center;
  font-size: 200%;
  text-align: center;
  //font-weight: bold;
  border-radius: 6px;
  //width: 20%;
  min-width: 12.5%;
  cursor: pointer;
  color: rgba(123,144,169, 1);
  background: rgba(0, 0, 0, 0);
  overflow: hidden;
  //border-right: 1.5px solid rgba(0, 0, 0, 0.15);
  transition: text-shadow 0.7s, background-color 0.7s;
}

.MenuPanel_button:last-child{
  margin-right: 0;
}

.MenuPanel_button:hover {
  background-color: rgba(245, 246, 247, 0.15);
}

.MenuPanel_button:last-child {
  border-right: none;
}

.MenuPanel_button_icon {
  transform: translate(0, 0.125em);
  padding: 0 0.15em 0 0;
  margin: 0 0.15em 0 0;
}

.MenuPanel_button_hl{
  background-color: rgba(245, 246, 247, 0.35) !important;
}



================================================
FILE: webgal/src/UI/Menu/MenuPanel/MenuPanel.tsx
================================================
import styles from './menuPanel.module.scss';
import { MenuPanelButton } from './MenuPanelButton';
import { playBgm } from '@/Core/controller/stage/playBgm';
import { MenuPanelTag } from '@/store/guiInterface';
import { useDispatch, useSelector } from 'react-redux';
import { RootState } from '@/store/store';
import { setMenuPanelTag, setVisibility } from '@/store/GUIReducer';
import { backToTitle } from '@/Core/controller/gamePlay/backToTitle';
import useTrans from '@/hooks/useTrans';
import useSoundEffect from '@/hooks/useSoundEffect';
import { showGlogalDialog } from '@/UI/GlobalDialog/GlobalDialog';

/**
 * Menu页的底栏
 * @constructor
 */
export const MenuPanel = () => {
  // 国际化
  const t = useTrans('menu.');

  const { playSeClick, playSeDialogOpen, playSePageChange } = useSoundEffect();
  const GUIState = useSelector((state: RootState) => state.GUI);
  const dispatch = useDispatch();
  // 设置Menu按钮的高亮
  const SaveTagOn = GUIState.currentMenuTag === MenuPanelTag.Save ? ` ${styles.MenuPanel_button_hl}` : ``;
  const LoadTagOn = GUIState.currentMenuTag === MenuPanelTag.Load ? ` ${styles.MenuPanel_button_hl}` : ``;
  const OptionTagOn = GUIState.currentMenuTag === MenuPanelTag.Option ? ` ${styles.MenuPanel_button_hl}` : ``;

  // 设置Menu按钮的颜色
  const SaveTagColor = GUIState.currentMenuTag === MenuPanelTag.Save ? `rgba(74, 34, 93, 0.9)` : `rgba(123,144,169,1)`;
  const LoadTagColor = GUIState.currentMenuTag === MenuPanelTag.Load ? `rgba(11, 52, 110, 0.9)` : `rgba(123,144,169,1)`;
  const OptionTagColor =
    GUIState.currentMenuTag === MenuPanelTag.Option ? `rgba(81, 110, 65, 0.9)` : `rgba(123,144,169,1)`;

  // 设置Menu图标的颜色
  const SaveIconColor = GUIState.currentMenuTag === MenuPanelTag.Save ? `rgba(74, 34, 93, 0.9)` : `rgba(123,144,169,1)`;
  const LoadIconColor =
    GUIState.currentMenuTag === MenuPanelTag.Load ? `rgba(11, 52, 110, 0.9)` : `rgba(123,144,169,1)`;
  const OptionIconColor =
    GUIState.currentMenuTag === MenuPanelTag.Option ? `rgba(81, 110, 65, 0.9)` : `rgba(123,144,169,1)`;

  return (
    <div className={styles.MenuPanel_main}>
      <MenuPanelButton
        iconName="save"
        buttonOnClassName={SaveTagOn}
        iconColor={SaveIconColor}
        tagColor={SaveTagColor}
        clickFunc={() => {
          playSePageChange();
          if (GUIState.showTitle) return;
          dispatch(setMenuPanelTag(MenuPanelTag.Save));
        }}
        tagName={t('saving.title')}
        key="saveButton"
      />
      <MenuPanelButton
        iconName="load"
        buttonOnClassName={LoadTagOn}
        iconColor={LoadIconColor}
        tagColor={LoadTagColor}
        clickFunc={() => {
          playSePageChange();
          dispatch(setMenuPanelTag(MenuPanelTag.Load));
        }}
        tagName={t('loadSaving.title')}
        key="loadButton"
      />
      <MenuPanelButton
        iconName="title"
        iconColor="rgba(123,144,169,1)"
        tagColor="rgba(123,144,169,1)"
        clickFunc={() => {
          playSeDialogOpen();
          showGlogalDialog({
            title: t('$gaming.buttons.titleTips'),
            leftText: t('$common.yes'),
            rightText: t('$common.no'),
            leftFunc: () => {
              backToTitle();
              dispatch(setVisibility({ component: 'showMenuPanel', visibility: false }));
            },
            rightFunc: () => {},
          });
        }}
        tagName={t('title.title')}
        key="titleIcon"
      />
      <MenuPanelButton
        iconName="option"
        style={{ marginLeft: 'auto' }}
        buttonOnClassName={OptionTagOn}
        iconColor={OptionIconColor}
        tagColor={OptionTagColor}
        clickFunc={() => {
          playSePageChange();
          dispatch(setMenuPanelTag(MenuPanelTag.Option));
        }}
        tagName={t('options.title')}
        key="optionButton"
      />

      <MenuPanelButton
        iconName="exit"
        iconColor="rgba(123,144,169,1)"
        tagColor="rgba(123,144,169,1)"
        clickFunc={() => {
          playSeClick();
          dispatch(setVisibility({ component: 'showMenuPanel', visibility: false }));
        }}
        tagName={t('exit.title')}
        key="exitIcon"
      />
    </div>
  );
};



================================================
FILE: webgal/src/UI/Menu/MenuPanel/MenuPanelButton.tsx
================================================
import styles from './menuPanel.module.scss';
import { MenuIconMap } from './MenuIconMap';
import { IMenuPanel } from '@/UI/Menu/MenuPanel/menuPanelInterface';
import useSoundEffect from '@/hooks/useSoundEffect';

/**
 * 菜单标签页切换按钮
 * @param props
 * @constructor
 */
export const MenuPanelButton = (props: IMenuPanel) => {
  const { playSePageChange, playSeEnter } = useSoundEffect();
  let buttonClassName = styles.MenuPanel_button;
  if (props.hasOwnProperty('buttonOnClassName')) {
    buttonClassName = buttonClassName + props.buttonOnClassName;
  }
  return (
    <div
      className={buttonClassName}
      onClick={() => {
        props.clickFunc();
        // playSePageChange();
      }}
      onMouseEnter={playSeEnter}
      style={{ ...props.style, color: props.tagColor }}
    >
      <div className={styles.MenuPanel_button_icon}>
        <MenuIconMap iconName={props.iconName} iconColor={props.iconColor} />
      </div>
      {props.tagName}
    </div>
  );
};



================================================
FILE: webgal/src/UI/Menu/MenuPanel/menuPanelInterface.ts
================================================
import { CSSProperties } from 'react';

/**
 * @interface IMenuPanel Menu页面的按钮的参数接口
 */
export interface IMenuPanel {
  clickFunc?: any; // 点击事件触发的函数
  buttonOnClassName?: string; // 按钮激活（在当前按钮对应页面）时的className
  tagColor?: string; // 标签颜色
  iconColor?: string; // 图标颜色
  tagName?: string; // 标签显示名称
  iconName: string; // 图标名称
  style?: CSSProperties;
}



================================================
FILE: webgal/src/UI/Menu/Options/normalButton.module.scss
================================================
.NormalButton {
  font-size: 150%;
  box-sizing: border-box;
  padding: 0.2em 1em 0.2em 1em;
  background-color: rgba(50, 50, 50, 0.05);
  margin: 0 0.4em 0 0;
  color: rgba(160, 170, 160, 1);
  cursor: pointer;
  border-bottom: 2px solid transparent;
}

.NormalButton:hover {
  border-bottom: 2px solid rgba(81, 110, 65, 0.9);
  color: rgba(81, 110, 65, 0.9);
  font-weight: bold;
}

.NormalButtonChecked {
  background-color: rgba(81, 110, 65, 0.15);
  border-bottom: 2px solid rgba(81, 110, 65, 0.9);
  color: rgba(81, 110, 65, 0.9);
  font-weight: bold;
}



================================================
FILE: webgal/src/UI/Menu/Options/NormalButton.tsx
================================================
import { ReactElement } from 'react';
import { INormalButton } from '@/UI/Menu/Options/OptionInterface';
import styles from './normalButton.module.scss';
import useSoundEffect from '@/hooks/useSoundEffect';

export const NormalButton = (props: INormalButton) => {
  const len: number = props.textList.length;
  const buttonList: Array<ReactElement> = [];
  const { playSeEnter, playSeSwitch } = useSoundEffect();
  for (let i = 0; i < len; i++) {
    if (i === props.currentChecked) {
      const t = (
        <div
          key={props.textList[i] + i + props}
          className={styles.NormalButton + ' ' + styles.NormalButtonChecked}
          onClick={() => {
            playSeSwitch();
            props.functionList[i]();
          }}
          onMouseEnter={playSeEnter}
        >
          {props.textList[i]}
        </div>
      );
      buttonList.push(t);
    } else {
      const t = (
        <div
          key={props.textList[i] + i}
          className={styles.NormalButton}
          onClick={() => {
            playSeSwitch();
            props.functionList[i]();
          }}
          onMouseEnter={playSeEnter}
        >
          {props.textList[i]}
        </div>
      );
      buttonList.push(t);
    }
  }
  return <>{buttonList}</>;
};



================================================
FILE: webgal/src/UI/Menu/Options/normalOption.module.scss
================================================
.NormalOption {
  margin: 0.2em 1em 0.2em 1em;
  padding: 0.2em 0.2em 0.2em 0.2em;
  display: flex;
  flex-flow: column;
  align-items: flex-start;
  animation: Elements_in ease-out 0.7s forwards;
}

.NormalOption_title {
  //color: rgba(81, 110, 65, 0.9);
  color: transparent;
  background: linear-gradient(to left, #227D51, rgba(81, 110, 65, 1));
  -webkit-background-clip: text;
  font-size: 200%;
  //border-bottom: 2px solid rgba(81, 110, 65, 0.9);
  padding: 0.15em 0.5em 0.15em 0.1em;
  font-weight: bold;
}

.NormalOption_title_bef {
  font-weight: bold;
  font-size: 200%;
  content: attr(data-text);
  position: absolute;
  -webkit-text-stroke: 3px rgba(0, 0, 0, 1);
  z-index: -1;
  padding: 0.15em 0.5em 0.15em 0.1em;
}

.NormalOption_title_sd {
  font-weight: bold;
  color: rgba(0, 0, 0, 0);
  font-size: 200%;
  position: absolute;
  z-index: -1;
  padding: 0.15em 0.5em 0.15em 0.1em;
  text-shadow: 0.04em 0.04em rgba(81, 110, 65, 0.9),
    0.05em 0.05em rgba(81, 110, 65, 0.9),
    0.06em 0.06em rgba(81, 110, 65, 0.9),
    0.07em 0.07em rgba(81, 110, 65, 0.9),
    0.08em 0.08em rgba(81, 110, 65, 0.9),
    0.09em 0.09em rgba(81, 110, 65, 0.9),
    0.10em 0.10em rgba(81, 110, 65, 0.9);
  //0.11em 0.11em rgba(81, 110, 65, 0.9),
  //0.12em 0.12em rgba(81, 110, 65, 0.9);
}

.NormalOption_buttonList {
  padding: 0.5em 0 0.5em 0;
  display: flex;
}

@keyframes Elements_in {
  0% {
    opacity: 0;
    transform: scale(1.03, 1.03) translate(-25px, -20px);
  }

  100% {
    opacity: 1;
    transform: scale(1, 1) translate(0, 0);
  }
}


================================================
FILE: webgal/src/UI/Menu/Options/NormalOption.tsx
================================================
import styles from './normalOption.module.scss';

export const NormalOption = (props: any) => {
  return (
    <div className={styles.NormalOption} style={{ width: props.full ? '100%' : 'auto' }}>
      {/* <div className={styles.NormalOption_title_sd}>{props.title}</div> */}
      {/* <div className={styles.NormalOption_title_bef}>{props.title}</div> */}
      <div className={styles.NormalOption_title}>{props.title}</div>
      <div
        className={styles.NormalOption_buttonList}
        style={{ width: props.full ? '100%' : 'auto', overflow: props.full ? 'hidden' : undefined }}
      >
        {props.children}
      </div>
    </div>
  );
};



================================================
FILE: webgal/src/UI/Menu/Options/OptionInterface.ts
================================================
/**
 * @interface INormalButton 普通按钮的参数
 */
import { ChangeEvent } from 'react';

export interface INormalButton {
  textList: Array<string>;
  functionList: Array<any>;
  currentChecked: number;
}

export interface ISlider {
  uniqueID: string;
  onChange: (event: ChangeEvent<HTMLInputElement>) => void;
  initValue: number;
  min?: number;
  max?: number;
}



================================================
FILE: webgal/src/UI/Menu/Options/options.module.scss
================================================
.Options_main {
  position: absolute;
  cursor: default;
  height: 90%;
  width: 100%;
  //background: rgba(255, 255, 255, 0.65);
}

.Options_top {
  height: 15%;
  width: 100%;
  display: flex;
  align-items: flex-start;
}

.Options_title {
  font-family: "思源宋体", serif;
  letter-spacing: 0.1em;
  font-size: 225%;
  margin: 0.5em 0 0.5em 0;
  padding: 0.2em 2em 0.2em 1.1em;
  box-sizing: border-box;
  //background-color: rgba(255, 255, 255, 0.99);
  //border-right: .2em solid rgba(81, 110, 65, 0.9);
  //box-shadow: .1em .1em .8em .2em rgba(0, 0, 0, 0.07);
}

.Option_title_text {
  font-size: 165%;
  font-weight: bold;
  color: transparent;
  background: linear-gradient(to left, #227D51, rgba(81, 110, 65, 1));
  -webkit-background-clip: text;
  animation: Elements_in ease-out 0.7s forwards;
}

.Option_title_text_shadow {
  position: absolute;
  color: rgba(0, 0, 0, 0);
  -webkit-text-stroke: 3px rgba(0, 0, 0, 1);
  z-index: -1;
}

.Option_title_text_ts {
  position: absolute;
  color: rgba(0, 0, 0, 0);
  text-shadow: 0.04em 0.04em rgba(81, 110, 65, 0.9),
    0.05em 0.05em rgba(81, 110, 65, 0.9),
    0.06em 0.06em rgba(81, 110, 65, 0.9),
    0.07em 0.07em rgba(81, 110, 65, 0.9);
  //0.08em 0.08em rgba(81, 110, 65, 0.9),
  //0.09em 0.09em rgba(81, 110, 65, 0.9),
  //0.10em 0.10em rgba(81, 110, 65, 0.9),
  //0.11em 0.11em rgba(81, 110, 65, 0.9),
  //0.12em 0.12em rgba(81, 110, 65, 0.9);
  z-index: -1;
}

.Options_main_content {
  display: flex;
  flex: 1;
  padding: 0 0 0 3em;
  overflow: auto;
}

.Options_main_content_half {
  width: 95%;
  display: flex;
  flex-flow: row;
  align-items: flex-start;
  align-content: flex-start;
  flex-wrap: wrap;
  padding: 0 1em 0 1em;
  position: relative;
}

.About_title_text {
  margin: 0.2em 1em 0.2em 1em;
  padding: 0.2em 0.2em 0.2em 0.2em;
  //width: 100%;
  position: absolute;
  top: 10px;
  right: 10px;
  animation: Elements_in ease-out 0.7s forwards;
  cursor: pointer;
}

.About_text {
  font-weight: bold;
  color: transparent;
  background: linear-gradient(to left, rgba(34, 125, 81, 0.65), rgba(81, 110, 65, 0.65));
  -webkit-background-clip: text;
  font-size: 135%;
  text-decoration: underline;

}

@keyframes Elements_in {
  0% {
    opacity: 0;
    transform: scale(1.03, 1.03) translate(-25px, -20px);
  }

  100% {
    opacity: 1;
    transform: scale(1, 1) translate(0, 0);
  }
}

.Options_page_container {
  height: 85%;
  display: flex;
  padding: 1em 3.75em 1em 3.75em;
}

.Options_button_list {
  animation: Elements_in ease-out 0.7s forwards;
}

.Options_page_button {
  font-family: "思源宋体", serif;
  font-size: 300%;
  font-weight: bold;
  color: transparent;
  background: linear-gradient(to left, #227D51, rgba(81, 110, 65, 1));
  opacity: 0.35;
  -webkit-background-clip: text;
  transition: color 0.33s, background-image 0.33s, opacity 0.33s;
  cursor: pointer;
}

.Options_page_button_active {
  background-image: linear-gradient(to left, #227D51, rgba(81, 110, 65, 1));
  -webkit-background-clip: text;
  opacity: 1;
}

.Options_page_button:hover {
  opacity: 1;
}



================================================
FILE: webgal/src/UI/Menu/Options/Options.tsx
================================================
import { FC, useEffect } from 'react';
import styles from './options.module.scss';
import { getStorage } from '@/Core/controller/storage/storageController';
import { useValue } from '@/hooks/useValue';
import { System } from '@/UI/Menu/Options/System/System';
import { Display } from '@/UI/Menu/Options/Display/Display';
import { Sound } from '@/UI/Menu/Options/Sound/Sound';
import useTrans from '@/hooks/useTrans';
import useSoundEffect from '@/hooks/useSoundEffect';

enum optionPage {
  'System',
  'Display',
  'Sound',
}

export const Options: FC = () => {
  const { playSeEnter, playSeSwitch } = useSoundEffect();
  const currentOptionPage = useValue(optionPage.System);
  useEffect(getStorage, []);

  function getClassName(page: optionPage) {
    if (page === currentOptionPage.value) {
      return styles.Options_page_button + ' ' + styles.Options_page_button_active;
    } else return styles.Options_page_button;
  }

  const t = useTrans('menu.options.');

  return (
    <div className={styles.Options_main}>
      <div className={styles.Options_top}>
        <div className={styles.Options_title}>
          <div className={styles.Option_title_text}>{t('title')}</div>
        </div>
      </div>
      <div className={styles.Options_page_container}>
        <div className={styles.Options_button_list}>
          <div
            onClick={() => {
              currentOptionPage.set(optionPage.System);
              playSeSwitch();
            }}
            className={getClassName(optionPage.System)}
            onMouseEnter={playSeEnter}
          >
            {t('pages.system.title')}
          </div>
          <div
            onClick={() => {
              currentOptionPage.set(optionPage.Display);
              playSeSwitch();
            }}
            className={getClassName(optionPage.Display)}
            onMouseEnter={playSeEnter}
          >
            {t('pages.display.title')}
          </div>
          <div
            onClick={() => {
              currentOptionPage.set(optionPage.Sound);
              playSeSwitch();
            }}
            className={getClassName(optionPage.Sound)}
            onMouseEnter={playSeEnter}
          >
            {t('pages.sound.title')}
          </div>
        </div>
        <div className={styles.Options_main_content}>
          {currentOptionPage.value === optionPage.Display && <Display />}
          {currentOptionPage.value === optionPage.System && <System />}
          {currentOptionPage.value === optionPage.Sound && <Sound />}
        </div>
      </div>
    </div>
  );
};



================================================
FILE: webgal/src/UI/Menu/Options/OptionSlider.tsx
================================================
import './slider.css';
import { ISlider } from '@/UI/Menu/Options/OptionInterface';
import { useEffect, useState, useRef } from 'react';
import useSoundEffect from '@/hooks/useSoundEffect';

export const OptionSlider = (props: ISlider) => {
  const { playSeEnter } = useSoundEffect();
  const [currentValue, setCurrentValue] = useState(props.initValue);
  const [isHovered, setIsHovered] = useState(false);
  const [isDragging, setIsDragging] = useState(false);
  const inputRef = useRef<HTMLInputElement>(null);

  useEffect(() => {
    const handleMouseUp = () => setIsDragging(false);
    document.addEventListener('mouseup', handleMouseUp);
    return () => document.removeEventListener('mouseup', handleMouseUp);
  }, []);

  useEffect(() => {
    setCurrentValue(props.initValue);
  }, [props.initValue]);

  const calculateBubblePosition = () => {
    if (!inputRef.current) return 0;
    const input = inputRef.current;
    const min = props.min || 0;
    const max = props.max || 100;
    const ratio = (currentValue - min) / (max - min);
    const sliderWidth = input.offsetWidth;
    const thumbWidth = sliderWidth * 0.072;
    return ratio * (sliderWidth - thumbWidth) + thumbWidth / 2;
  };

  return (
    <div className="Option_WebGAL_slider">
      <input
        id={props.uniqueID}
        ref={inputRef}
        type="range"
        value={currentValue}
        min={props.min}
        max={props.max}
        onChange={(e) => {
          const value = parseFloat(e.target.value);
          setCurrentValue(value);
          props.onChange(e);
        }}
        onMouseEnter={() => setIsHovered(true)}
        onMouseLeave={() => !isDragging && setIsHovered(false)}
        onMouseDown={() => setIsDragging(true)}
        onFocus={playSeEnter}
        onMouseOver={playSeEnter}
        onTouchStart={() => {
          setIsDragging(true);
          setIsHovered(true);
        }}
        onTouchEnd={() => {
          setIsDragging(false);
          setIsHovered(false);
        }}
      />
      {(isHovered || isDragging) && (
        <div
          className="bubble"
          style={{
            left: `${calculateBubblePosition()}px`,
          }}
        >
          {Number(currentValue.toFixed(1))}
        </div>
      )}
    </div>
  );
};



================================================
FILE: webgal/src/UI/Menu/Options/slider.css
================================================
input[type=range] {
  -webkit-appearance: none; /* 去掉底部的 track 默认样式，就是整个灰条 */
  width: 500px; /* Firefox 需要指定明确的宽度 */
  height: 50px;
  background: transparent; /* 否则在 Chrome 中是白色背景 */
  font-size: 100%;
}

/* 去掉 webkit 内核 滑块 的样式 */
input[type=range]::-webkit-slider-thumb {
  -webkit-appearance: none;
}

input[type=range]:focus {
  outline: none; /* 去除获取焦点时蓝色的外边框，你也可以自己定制其他你想要的效果 */
}

/*以下是自定义样式*/

/*滑块样式*/
input[type=range]::-webkit-slider-thumb {
  -webkit-appearance: none;
  /*border: 1px solid #000000;*/
  height: 375%;
  width: 7.2%;
  border-radius: 5em;
  background: #ffffff;
  cursor: pointer;
  margin-top: -14px; /* 在 Chrome 中你需要给定一个明确的 margin，但是在 Firefox 和 IE 中这个是固定的 */
  box-shadow: 0 0 5px rgba(0, 0, 0, 0.5); /* 添加一条炫酷的效果为你的 thumb */
}

/*轨道样式*/
input[type=range]::-webkit-slider-runnable-track {
  width: 100%;
  height: 20%;
  cursor: pointer;
  box-shadow: 1px 1px 7px rgba(0, 0, 0, 0.3);
  background: rgba(81, 110, 65, 0.9);
  border-radius: 2em;
}

input[type=range]:focus::-webkit-slider-runnable-track {
  background: rgba(81, 110, 65, 0.9);
}

/* Firefox 同上 */
input[type=range]::-moz-range-thumb {
  height: 36px;
  width: 7.2%;
  border-radius: 5em;
  background: #ffffff;
  cursor: pointer;
  /*margin-top: -14px; !* 在 Chrome 中你需要给定一个明确的 margin，但是在 Firefox 和 IE 中这个是固定的 *!*/
  box-shadow: 0 0 5px rgba(0, 0, 0, 0.5); /* 添加一条炫酷的效果为你的 thumb */
}

input[type=range]::-moz-range-track {
  width: 100%;
  height: 20%;
  cursor: pointer;
  box-shadow: 1px 1px 7px rgba(0, 0, 0, 0.3);
  background: rgba(81, 110, 65, 0.9);
  border-radius: 2em;
}

.Option_WebGAL_slider {
  position: relative;
}

.bubble {
  position: absolute;
  bottom: calc(100% + 10px);
  transform: translateX(-50%);
  background: rgba(0, 0, 0, 0.85);
  color: white;
  padding: 6px 12px;
  border-radius: 6px;
  font-weight: bold;
  white-space: nowrap;
  pointer-events: none;
  opacity: 0;
  animation: bubbleFadeIn 0.2s ease-out forwards;
}

.bubble::after {
  content: '';
  position: absolute;
  top: 100%;
  left: 50%;
  transform: translateX(-50%);
  border-width: 6px;
  border-style: solid;
  border-color: rgba(0, 0, 0, 0.85) transparent transparent transparent;
}

@keyframes bubbleFadeIn {
  from {
    opacity: 0;
    transform: translateX(-50%) translateY(4px);
  }
  to {
    opacity: 1;
    transform: translateX(-50%) translateY(0);
  }
}



================================================
FILE: webgal/src/UI/Menu/Options/Display/Display.tsx
================================================
import { setStorage } from '@/Core/controller/storage/storageController';
import { NormalButton } from '@/UI/Menu/Options/NormalButton';
import { NormalOption } from '@/UI/Menu/Options/NormalOption';
import { TextPreview } from '@/UI/Menu/Options/TextPreview/TextPreview';
import styles from '@/UI/Menu/Options/options.module.scss';
import useFullScreen from '@/hooks/useFullScreen';
import useTrans from '@/hooks/useTrans';
import { RootState } from '@/store/store';
import { textFont, textSize } from '@/store/userDataInterface';
import { setOptionData } from '@/store/userDataReducer';
import { useDispatch, useSelector } from 'react-redux';
import { OptionSlider } from '../OptionSlider';

export function Display() {
  const userDataState = useSelector((state: RootState) => state.userData);
  const dispatch = useDispatch();
  const t = useTrans('menu.options.pages.display.options.');
  const { isSupported: isFullscreenSupported, enter: enterFullscreen, exit: exitFullscreen } = useFullScreen();

  return (
    <div className={styles.Options_main_content_half}>
      {isFullscreenSupported && (
        <NormalOption key="fullScreen" title={t('fullScreen.title')}>
          <NormalButton
            textList={t('fullScreen.options.on', 'fullScreen.options.off')}
            functionList={[enterFullscreen, exitFullscreen]}
            currentChecked={userDataState.optionData.fullScreen}
          />
        </NormalOption>
      )}
      <NormalOption key="textSize" title={t('textSize.title')}>
        <NormalButton
          textList={t('textSize.options.small', 'textSize.options.medium', 'textSize.options.large')}
          functionList={[
            () => {
              dispatch(setOptionData({ key: 'textSize', value: textSize.small }));
              setStorage();
            },
            () => {
              dispatch(setOptionData({ key: 'textSize', value: textSize.medium }));
              setStorage();
            },
            () => {
              dispatch(setOptionData({ key: 'textSize', value: textSize.large }));
              setStorage();
            },
          ]}
          currentChecked={userDataState.optionData.textSize}
        />
      </NormalOption>
      <NormalOption key="textFont" title={t('textFont.title')}>
        <NormalButton
          textList={t('textFont.options.siYuanSimSun', 'textFont.options.SimHei', 'textFont.options.lxgw')}
          functionList={[
            () => {
              dispatch(setOptionData({ key: 'textboxFont', value: textFont.song }));
              setStorage();
            },
            () => {
              dispatch(setOptionData({ key: 'textboxFont', value: textFont.hei }));
              setStorage();
            },
            () => {
              dispatch(setOptionData({ key: 'textboxFont', value: textFont.lxgw }));
              setStorage();
            },
          ]}
          currentChecked={userDataState.optionData.textboxFont}
        />
      </NormalOption>
      <NormalOption key="textSpeed" title={t('textSpeed.title')}>
        <OptionSlider
          initValue={userDataState.optionData.textSpeed}
          uniqueID={t('textSpeed.title')}
          onChange={(event) => {
            const newValue = event.target.value;
            dispatch(setOptionData({ key: 'textSpeed', value: Number(newValue) }));
            setStorage();
          }}
        />
      </NormalOption>
      <NormalOption key="textboxOpacity" title={t('textboxOpacity.title')}>
        <OptionSlider
          initValue={userDataState.optionData.textboxOpacity}
          uniqueID={t('textboxOpacity.title')}
          onChange={(event) => {
            const newValue = event.target.value;
            dispatch(setOptionData({ key: 'textboxOpacity', value: Number(newValue) }));
            setStorage();
          }}
        />
      </NormalOption>
      <NormalOption full key="textPreview" title={t('textPreview.title')}>
        {/* 这是一个临时的组件，用于模拟文本预览的效果 */}
        <TextPreview />
      </NormalOption>
    </div>
  );
}



================================================
FILE: webgal/src/UI/Menu/Options/Sound/Sound.tsx
================================================
import styles from '@/UI/Menu/Options/options.module.scss';
import { NormalOption } from '@/UI/Menu/Options/NormalOption';
import { OptionSlider } from '@/UI/Menu/Options/OptionSlider';
import { NormalButton } from '@/UI/Menu/Options//NormalButton';
import { setOptionData } from '@/store/userDataReducer';
import { setStorage } from '@/Core/controller/storage/storageController';
import { useDispatch, useSelector } from 'react-redux';
import { RootState } from '@/store/store';
import useTrans from '@/hooks/useTrans';
import { voiceOption } from '@/store/userDataInterface';

export function Sound() {
  const userDataState = useSelector((state: RootState) => state.userData);
  const dispatch = useDispatch();
  const t = useTrans('menu.options.pages.sound.options.');

  return (
    <div className={styles.Options_main_content_half}>
      <NormalOption key="option4" title={t('volumeMain.title')}>
        <OptionSlider
          initValue={userDataState.optionData.volumeMain}
          uniqueID={t('volumeMain.title')}
          onChange={(event) => {
            const newValue = event.target.value;
            dispatch(setOptionData({ key: 'volumeMain', value: Number(newValue) }));
            setStorage();
          }}
        />
      </NormalOption>
      <NormalOption key="option5" title={t('vocalVolume.title')}>
        <OptionSlider
          initValue={userDataState.optionData.vocalVolume}
          uniqueID={t('vocalVolume.title')}
          onChange={(event) => {
            const newValue = event.target.value;
            dispatch(setOptionData({ key: 'vocalVolume', value: Number(newValue) }));
            setStorage();
          }}
        />
      </NormalOption>
      <NormalOption key="option6" title={t('bgmVolume.title')}>
        <OptionSlider
          initValue={userDataState.optionData.bgmVolume}
          uniqueID={t('bgmVolume.title')}
          onChange={(event) => {
            const newValue = event.target.value;
            dispatch(setOptionData({ key: 'bgmVolume', value: Number(newValue) }));
            setStorage();
          }}
        />
      </NormalOption>
      <NormalOption key="option7" title={t('seVolume.title')}>
        <OptionSlider
          initValue={userDataState.optionData.seVolume}
          uniqueID={t('seVolume.title')}
          onChange={(event) => {
            const newValue = event.target.value;
            dispatch(setOptionData({ key: 'seVolume', value: Number(newValue) }));
            setStorage();
          }}
        />
      </NormalOption>
      <NormalOption key="option8" title={t('uiSeVolume.title')}>
        <OptionSlider
          initValue={userDataState.optionData.uiSeVolume}
          uniqueID={t('uiSeVolume.title')}
          onChange={(event) => {
            const newValue = event.target.value;
            dispatch(setOptionData({ key: 'uiSeVolume', value: Number(newValue) }));
            setStorage();
          }}
        />
      </NormalOption>
      <NormalOption key="option9" title={t('voiceOption.title')}>
        <NormalButton
          textList={t('voiceStop.title', 'voiceContinue.title')}
          functionList={[
            () => {
              dispatch(setOptionData({ key: 'voiceInterruption', value: voiceOption.yes }));
              setStorage();
            },
            () => {
              dispatch(setOptionData({ key: 'voiceInterruption', value: voiceOption.no }));
              setStorage();
            },
          ]}
          currentChecked={userDataState.optionData.voiceInterruption}
        />
      </NormalOption>
    </div>
  );
}



================================================
FILE: webgal/src/UI/Menu/Options/System/about.module.scss
================================================
.backButton{
  display: flex;
  justify-content: center;
  align-items: center;
  width: 50px;
  height: 50px;
  background: rgba(0,0,0,0.1);
  border-radius: 4px;
  cursor: pointer;
}

.backButton:hover{
  background: rgba(0,0,0,0.2);
}

.about{
  padding: 10px 0 0 0;
}

.icon{
  display: inline-flex;
}

.title{
  color: transparent;
  background: linear-gradient(to left, #227D51, rgba(81, 110, 65, 1));
  -webkit-background-clip: text;
  font-size: 200%;
  //border-bottom: 2px solid rgba(81, 110, 65, 0.9);
  padding: 0.15em 0.5em 0.15em 0.1em;
  font-weight: bold;
  margin-top: 20px;
}

.text{
  color: rgba(81, 110, 65, 1);
  padding: 0 0 0 10px;
  font-size: 135%;
  a{
    color: rgba(81, 110, 65, 1);
  }
}

.contributor{
  padding: 0 10px 0 0;
}



================================================
FILE: webgal/src/UI/Menu/Options/System/About.tsx
================================================
import useTrans from '@/hooks/useTrans';
import { Left } from '@icon-park/react';
import s from './about.module.scss';
import { __INFO } from '@/config/info';

export default function About(props: { onClose: () => void }) {
  const t = useTrans('menu.options.pages.system.options.about.');
  return (
    <div className={s.about}>
      <div className={s.backButton} onClick={props.onClose}>
        <Left className={s.icon} theme="outline" size="35" strokeWidth={3} fill="#333" />
      </div>
      <div className={s.title}>{t('subTitle')}</div>
      <div className={s.title}>{t('version')}</div>
      <div className={s.text}>{__INFO.version}</div>
      <div className={s.title}>{t('source')}</div>
      <div className={s.text}>
        <a target="_blank" href="https://github.com/OpenWebGAL/WebGAL">
          https://github.com/OpenWebGAL/WebGAL
        </a>
      </div>
      <div className={s.title}>{t('contributors')}</div>
      <div className={s.text}>
        <a target="_blank" href="https://github.com/OpenWebGAL/WebGAL/graphs/contributors">
          https://github.com/OpenWebGAL/WebGAL/graphs/contributors
        </a>
      </div>
      <div className={s.title}>{t('website')}</div>
      <div className={s.text}>
        <a target="_blank" href="https://openwebgal.com/">
          https://openwebgal.com/
        </a>
      </div>
    </div>
  );
}



================================================
FILE: webgal/src/UI/Menu/Options/System/System.tsx
================================================
import styles from '@/UI/Menu/Options/options.module.scss';
import { NormalOption } from '@/UI/Menu/Options/NormalOption';
import { NormalButton } from '@/UI/Menu/Options/NormalButton';
import { resetAllData, resetOptionSet, setOptionData } from '@/store/userDataReducer';
import { IUserData, playSpeed } from '@/store/userDataInterface';
import { getStorage, setStorage, dumpToStorageFast } from '@/Core/controller/storage/storageController';
import { useDispatch, useSelector } from 'react-redux';
import { RootState, webgalStore } from '@/store/store';
import { showGlogalDialog } from '@/UI/GlobalDialog/GlobalDialog';
import localforage from 'localforage';
import { logger } from '@/Core/util/logger';
import useTrans from '@/hooks/useTrans';
import useLanguage from '@/hooks/useLanguage';
import languages, { language } from '@/config/language';
import { useState } from 'react';
import About from '@/UI/Menu/Options/System/About';
import { WebGAL } from '@/Core/WebGAL';
import useSoundEffect from '@/hooks/useSoundEffect';
import savesReducer, { ISavesData, saveActions } from '@/store/savesReducer';
import { dumpFastSaveToStorage, dumpSavesToStorage } from '@/Core/controller/storage/savesController';
import { OptionSlider } from '@/UI/Menu/Options/OptionSlider';
import { Info } from '@icon-park/react';

interface IExportGameData {
  userData: IUserData;
  saves: ISavesData;
}

export function System() {
  const userDataState = useSelector((state: RootState) => state.userData);
  const userSavesState = useSelector((state: RootState) => state.saveData);
  const dispatch = useDispatch();
  const setLanguage = useLanguage();
  const t = useTrans('menu.options.pages.system.options.');
  const { playSeDialogOpen } = useSoundEffect();

  function exportSaves() {
    const gameData: IExportGameData = {
      userData: userDataState,
      saves: userSavesState,
    };

    const saves = JSON.stringify(gameData);
    if (saves !== null) {
      // @ts-ignore
      const blob = new Blob([saves], { type: 'application/json' });
      const blobUrl = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = blobUrl;
      a.download = 'saves.json';
      a.click();
      a.remove();
    }
  }

  function importSavesEventHandler(ev: any) {
    // const t = useTrans('menu.options.pages.system.options.');

    const file = ev.target.files[0];
    const reader = new FileReader();
    reader.onload = (evR) => {
      const saves = evR!.target!.result as string;
      try {
        const saveAsObj: IExportGameData = JSON.parse(saves);
        playSeDialogOpen();
        showGlogalDialog({
          title: t('gameSave.dialogs.import.title'),
          leftText: t('$common.yes'),
          rightText: t('$common.no'),
          leftFunc: async () => {
            await localforage.setItem(WebGAL.gameKey, saveAsObj.userData).then(() => {
              logger.info(t('gameSave.dialogs.import.tip'));
            });
            getStorage();
            webgalStore.dispatch(saveActions.replaceSaveGame(saveAsObj.saves.saveData));
            webgalStore.dispatch(saveActions.setFastSave(saveAsObj.saves.quickSaveData));
            dumpFastSaveToStorage();
            dumpSavesToStorage(0, 200);
          },
          rightFunc: () => {},
        });
      } catch (e) {
        logger.error(t('gameSave.dialogs.import.error'), e);
      }
      // window.location.reload(); // dirty: 强制刷新 UI
    };
    reader.readAsText(file, 'UTF-8');
  }

  function importSaves() {
    const inputElement = document.createElement('input');
    inputElement.type = 'file';
    inputElement.onchange = importSavesEventHandler;
    inputElement.click();
  }

  const [showAbout, setShowAbout] = useState(false);

  function toggleAbout() {
    setShowAbout(!showAbout);
  }

  return (
    <div className={styles.Options_main_content_half}>
      {showAbout && <About onClose={toggleAbout} />}
      {!showAbout && (
        <>
          <NormalOption key="option1" title={t('autoSpeed.title')}>
            <OptionSlider
              initValue={userDataState.optionData.autoSpeed}
              uniqueID={t('autoSpeed.title')}
              onChange={(event) => {
                const newValue = event.target.value;
                dispatch(setOptionData({ key: 'autoSpeed', value: Number(newValue) }));
                setStorage();
              }}
            />
          </NormalOption>
          <NormalOption key="option7" title={t('language.title')}>
            <NormalButton
              currentChecked={userDataState.optionData.language}
              textList={Object.values(languages)}
              functionList={Object.keys(languages).map(
                (k) => () => setLanguage(language[k as unknown as number] as unknown as language),
              )}
            />
          </NormalOption>
          <NormalOption key="option2" title={t('resetData.title')}>
            <NormalButton
              textList={t(
                'resetData.options.clearGameSave',
                'resetData.options.resetSettings',
                'resetData.options.clearAll',
              )}
              functionList={[
                () => {
                  playSeDialogOpen();
                  showGlogalDialog({
                    title: t('resetData.dialogs.clearGameSave'),
                    leftText: t('$common.yes'),
                    rightText: t('$common.no'),
                    leftFunc: () => {
                      dispatch(saveActions.resetSaves());
                      dumpSavesToStorage(0, 200);
                      dumpFastSaveToStorage();
                    },
                    rightFunc: () => {},
                  });
                },
                () => {
                  playSeDialogOpen();
                  showGlogalDialog({
                    title: t('resetData.dialogs.resetSettings'),
                    leftText: t('$common.yes'),
                    rightText: t('$common.no'),
                    leftFunc: () => {
                      dispatch(resetOptionSet());
                      dumpToStorageFast();
                    },
                    rightFunc: () => {},
                  });
                },
                () => {
                  playSeDialogOpen();
                  showGlogalDialog({
                    title: t('resetData.dialogs.clearAll'),
                    leftText: t('$common.yes'),
                    rightText: t('$common.no'),
                    leftFunc: () => {
                      dispatch(resetAllData());
                      dumpToStorageFast();
                      dispatch(saveActions.resetSaves());
                      dumpSavesToStorage(0, 200);
                      dumpFastSaveToStorage();
                    },
                    rightFunc: () => {},
                  });
                },
              ]}
              currentChecked={3}
            />
          </NormalOption>
          <NormalOption key="option3" title={t('gameSave.title')}>
            <NormalButton
              textList={t('gameSave.options.export', 'gameSave.options.import')}
              functionList={[exportSaves, importSaves]}
              currentChecked={2}
            />
          </NormalOption>
          <div className={styles.About_title_text} onClick={toggleAbout}>
            <Info theme="outline" size="32" fill="#227D515F" />
          </div>
        </>
      )}
    </div>
  );
}



================================================
FILE: webgal/src/UI/Menu/Options/TextPreview/textPreview.module.scss
================================================
.textPreviewMain {
  z-index: 1;
  padding: 1em;
  min-height: 480px;
  width: 100%;
}

.textbox {
  width: 100%;
  height: 100%;
  position: relative;
}


================================================
FILE: webgal/src/UI/Menu/Options/TextPreview/TextPreview.tsx
================================================
import styles from './textPreview.module.scss';
import { useSelector } from 'react-redux';
import { RootState } from '@/store/store';
import { useFontFamily } from '@/hooks/useFontFamily';
import { useTextAnimationDuration, useTextDelay } from '@/hooks/useTextOptions';
import useTrans from '@/hooks/useTrans';
import { getTextSize } from '@/UI/getTextSize';
import IMSSTextbox from '@/Stage/TextBox/IMSSTextbox';
import { compileSentence } from '@/Stage/TextBox/TextBox';
import { useState } from 'react';

export const TextPreview = (props: any) => {
  const t = useTrans('menu.options.pages.display.options.');
  const userDataState = useSelector((state: RootState) => state.userData);
  const stageState = useSelector((state: RootState) => state.stage);
  const previewBackground = stageState.bgName;
  const textDelay = useTextDelay(userDataState.optionData.textSpeed);
  const textDuration = useTextAnimationDuration(userDataState.optionData.textSpeed);
  const textboxOpacity = userDataState.optionData.textboxOpacity;
  const size = getTextSize(userDataState.optionData.textSize) + '%';
  const font = useFontFamily();
  const userAgent = navigator.userAgent;
  const isFirefox = /firefox/i.test(userAgent);
  const isSafari = /^((?!chrome|android).)*safari/i.test(userAgent);
  const previewText = t('textPreview.text');
  const previewTextArray = compileSentence(previewText, 3);
  const showNameText = t('textPreview.title');
  const showNameArray = compileSentence(showNameText, 3);
  const isHasName = showNameText !== '';

  const Textbox = IMSSTextbox;

  const [previewKey, setPreviewKey] = useState<number>(0);

  const forcePreviewUpdate = () => {
    setPreviewKey((prevKey) => prevKey + 1);
  };

  const textboxProps = {
    textArray: previewTextArray,
    isText: true,
    textDelay: textDelay,
    isHasName: isHasName,
    showName: showNameArray,
    currentConcatDialogPrev: '',
    fontSize: size,
    currentDialogKey: String(previewKey),
    isSafari: isSafari,
    isFirefox: isFirefox,
    miniAvatar: '',
    textDuration: textDuration,
    font: font,
    textSizeState: size as unknown as number,
    lineLimit: 3,
    isUseStroke: true,
    textboxOpacity: textboxOpacity,
  };

  return (
    <div
      className={styles.textPreviewMain}
      style={{
        background: previewBackground ? `bottom / cover no-repeat url(${previewBackground})` : 'rgba(0, 0, 0, 0.1)',
      }}
      onClick={forcePreviewUpdate}
    >
      <div key={`previewTextbox-${textDelay}`} className={styles.textbox}>
        <Textbox {...textboxProps} />
      </div>
    </div>
  );
};



================================================
FILE: webgal/src/UI/Menu/SaveAndLoad/SaveAndLoad.module.scss
================================================
.Save_Load_main {
  height: 90%;
  width: 100%;
  position: absolute;
  cursor: default;
}

.Save_Load_top {
  height: 10%;
  width: 100%;
  display: flex;
  //background-color: rgba(255, 255, 255, 1);
  //box-shadow: 0 0 1.5em 0.1em rgba(0, 0, 0, 0.05);
  animation: Elements_in ease-out 1s forwards;
  //border-bottom: 1px solid rgba(0, 0, 0, 0.1);
  justify-content: center;
}

.Save_Load_title {
  font-family: "思源宋体", serif;
  letter-spacing: 0.1em;
  width: auto;
  font-size: 500%;
  min-width: 350px;
  //margin: 0 0 0 0.8em;
  //padding: 0 0.8em 0 0.8em;
  box-sizing: border-box;
  //border-bottom: 4px solid #77428D;
  display: flex;
  justify-content: center;
  align-items: center;
  position: absolute;
  left: 20px;
  top:0;
  z-index: -1;
  opacity: 0.2;
  transform: translateY(-10px);
}

.Save_title_text {
  font-weight: bold;
  color: transparent;
  background: linear-gradient(135deg, #77428D 0%, #B28FCE 100%);
  text-shadow: 2px 2px 15px rgba(255, 255, 255, 0.5);
  -webkit-background-clip: text;
}


.Load_title_text {
  font-weight: bold;
  color: transparent;
  background: linear-gradient(135deg, #005CAF 0%, #2EA9DF 100%);
  text-shadow: 2px 2px 15px rgba(255, 255, 255, 0.5);
  -webkit-background-clip: text;
}

.Save_Load_top_buttonList {
  height: 100%;
  display: flex;
  //padding: 0 0 0 2em;
}

.Save_Load_top_button {
  cursor: pointer;
  font-size: 200%;
  width: 2.05em;
  text-align: center;
  color: rgba(0, 0, 0, 0.5);
  box-sizing: border-box;
  display: flex;
  align-items: center;
  border-bottom: 4px solid rgba(0, 0, 0, 0);
  transition: background-color 0.7s, border-bottom-width 0.7s;
}

.Save_Load_top_button_text {
  text-align: center;
  width: 100%;
  padding: 0 0 3px 0;
  border-left: 2px solid rgba(0, 0, 0, 0.1);
}

.Save_Load_top_button:first-child > div {
  border-left: 2px solid rgba(0, 0, 0, 0);
}

.Save_Load_top_button_on {
  font-weight: bold;
  border-bottom: 4px solid #77428D;
  color: #77428D;
  background-color: rgba(119, 66, 141, 0.05);
}

.Save_Load_top_button:hover {
  color: #77428D;
  font-weight: bold;
  border-bottom: 4px solid #77428D;
}

.Load_top_button_on {
  font-weight: bold;
  border-bottom: 5px solid #005CAF;
  color: #005CAF;
  background-color: rgba(0, 92, 175, 0.1);
}

.Load_top_button:hover {
  color: #005CAF;
  font-weight: bold;
  border-bottom: 5px solid #005CAF;
}

.Save_Load_content {
  height: 90%;
  width: 100%;
  display: flex;
  flex-wrap: wrap;
  justify-content: space-evenly;
  align-items: center;
}

.Save_Load_content_element {
  //background: linear-gradient(-45deg, rgba(255,255,255,0.9) 0%, rgba(255,255,255,0.5) 100%);
  background: linear-gradient(-45deg, rgba(0, 0, 0, 0.05), rgba(0, 0, 0, 0.075));
  overflow: hidden;
  //border: 1px solid rgba(255, 255, 255, 1);
  width: 17.5%;
  height: 45%;
  //box-shadow: 0 0 15px rgba(0, 0, 0, 0.1);
  animation: Elements_in 1s ease-out forwards, Elements_in_transform 1s ease-out;
  opacity: 0;
  border-radius: 4px;
  transition: transform 0.25s, box-shadow 0.25s;
  cursor: pointer;
}

.Save_Load_content_element:hover {
  //box-shadow: 0 0 25px 8px rgba(0, 0, 0, 0.1);
  transform: scale(1.05, 1.05) translate(-0.2em, -0.2em);
}


.Save_Load_content_element_top {
  font-family: "思源宋体", serif;
  width: 100%;
  height: 12%;
  display: flex;
}

.Save_Load_content_element_top_index {
  color: rgba(255, 255, 255, 1);
  text-align: center;
  font-size: 155%;
  height: 100%;
  width: 20%;
  background-color: #B28FCE;
}

.Load_content_elememt_top_index {
  background-color: #51A8DD;
}

.Save_Load_content_element_top_date {
  padding: 0.425em 0 0 0.5em;
  background-color: #77428D;
  color: rgba(255, 255, 255, 1);
  font-size: 115%;
  height: 100%;
  width: 80%;
  font-family: WebgalUI, serif;
  letter-spacing: 0.1em;
}

.Load_content_element_top_date {
  background-color: #005CAF;
}

.Save_Load_content_text {
  font-family: "WebgalUI", sans-serif;
  letter-spacing: 0.05em;
  color: #373C38;
  background: linear-gradient(-45deg, rgba(255, 255, 255, 0.75) 0%, rgba(255, 255, 255, 1) 100%);
  //background: rgba(255,255,255,1);
  font-size: 120%;
  height: 40%;
  width: 100%;
  //box-sizing: border-box;
  display: flex;
  flex-flow: column;
  justify-content: flex-start;
  align-items: flex-start;
}

.Save_Load_content_text_padding {
  padding: 0.2em 0.75em 0.2em 0.75em;
}

.Save_Load_content_speaker {
  box-sizing: border-box;
  //margin: 0.35em 0 0 0;
  //background: rgba(0, 0, 0, 0.04);
  font-weight: bold;
  color: #77428D;
  padding: 0.35em 0.8em 0.25em 0.8em;
  width: 100%;
  //border-radius: 4px;
  border-bottom: 1px solid rgba(0, 0, 0, 0.1);
}

.Load_content_speaker {
  color: #005caf;
}


.Load_content_text {
  background-color: rgba(0, 92, 175, 0.75);
}

.Save_Load_content_miniRen {
  width: 100%;
  height: 48%;
  position: relative;
  background-size: cover;
}

.Save_Load_content_miniRen_bg {
  background-size: cover;
  height: 100%;
  width: 100%;
  background-position: center;
}

.Save_Load_content_miniRen_figure {
  height: 100%;
  max-height: 100%;
  max-width: 100%;
  position: absolute;
  bottom: 0;
}

.Save_Load_content_miniRen_figLeft {
  bottom: 0;
  left: 0;
}

.Save_Load_content_miniRen_figRight {
  bottom: 0;
  right: 0;
}

@keyframes Elements_in {
  0% {
    opacity: 0;
  }
  100% {
    opacity: 1;
  }
}

@keyframes Elements_in_transform {
  0% {
    transform: scale(1.05, 1.05) translate(-25px, -20px) rotateY(15deg) rotateX(-15deg);
  }
  100% {
    transform: scale(1, 1) translate(0, 0);
  }
}



================================================
FILE: webgal/src/UI/Menu/SaveAndLoad/Load/Load.tsx
================================================
import { CSSProperties, FC, useEffect } from 'react';
import { loadGame } from '@/Core/controller/storage/loadGame';
import styles from '../SaveAndLoad.module.scss';
// import {saveGame} from '@/Core/controller/storage/saveGame';
import { setStorage } from '@/Core/controller/storage/storageController';
import { useDispatch, useSelector } from 'react-redux';
import { RootState } from '@/store/store';
import { setSlPage } from '@/store/userDataReducer';
import useTrans from '@/hooks/useTrans';
import { useTranslation } from 'react-i18next';
import useSoundEffect from '@/hooks/useSoundEffect';
import { getSavesFromStorage } from '@/Core/controller/storage/savesController';
import { easyCompile } from '@/UI/Menu/SaveAndLoad/Save/Save';

export const Load: FC = () => {
  const { playSeClick, playSeEnter, playSePageChange } = useSoundEffect();
  const userDataState = useSelector((state: RootState) => state.userData);
  const saveDataState = useSelector((state: RootState) => state.saveData);
  const dispatch = useDispatch();
  const page = [];
  for (let i = 1; i <= 20; i++) {
    let classNameOfElement = styles.Save_Load_top_button + ' ' + styles.Load_top_button;
    if (i === userDataState.optionData.slPage) {
      classNameOfElement = classNameOfElement + ' ' + styles.Save_Load_top_button_on + ' ' + styles.Load_top_button_on;
    }
    const element = (
      <div
        onClick={() => {
          dispatch(setSlPage(i));
          setStorage();
          playSePageChange();
        }}
        onMouseEnter={playSeEnter}
        key={'Load_element_page' + i}
        className={classNameOfElement}
      >
        <div className={styles.Save_Load_top_button_text}>{i}</div>
      </div>
    );
    page.push(element);
  }

  const showSaves = [];
  // 现在尝试设置10个存档每页
  const start = (userDataState.optionData.slPage - 1) * 10 + 1;
  const end = start + 9;

  useEffect(() => {
    getSavesFromStorage(start, end);
  }, [start, end]);

  let animationIndex = 0;
  for (let i = start; i <= end; i++) {
    animationIndex++;
    const saveData = saveDataState.saveData[i];
    let saveElementContent = <div />;
    if (saveData) {
      const speaker = saveData.nowStageState.showName === '' ? '\u00A0' : `${saveData.nowStageState.showName}`;
      const speakerView = easyCompile(speaker);
      saveElementContent = (
        <>
          <div className={styles.Save_Load_content_element_top}>
            <div className={styles.Save_Load_content_element_top_index + ' ' + styles.Load_content_elememt_top_index}>
              {saveData.index}
            </div>
            <div className={styles.Save_Load_content_element_top_date + ' ' + styles.Load_content_element_top_date}>
              {saveData.saveTime}
            </div>
          </div>
          <div className={styles.Save_Load_content_miniRen}>
            <img className={styles.Save_Load_content_miniRen_bg} alt="Save_img_preview" src={saveData.previewImage} />
          </div>
          <div className={styles.Save_Load_content_text}>
            <div className={styles.Save_Load_content_speaker + ' ' + styles.Load_content_speaker}>{speakerView}</div>
            <div className={styles.Save_Load_content_text_padding}>{easyCompile(saveData.nowStageState.showText)}</div>
          </div>
        </>
      );
    }
    // else {

    // }
    const saveElement = (
      <div
        onClick={() => {
          loadGame(i);
          playSeClick();
        }}
        onMouseEnter={playSeEnter}
        key={'loadElement_' + i}
        className={styles.Save_Load_content_element}
        style={{ animationDelay: `${animationIndex * 30}ms` }}
      >
        {saveElementContent}
      </div>
    );
    showSaves.push(saveElement);
  }

  const t = useTrans('menu.');

  return (
    <div className={styles.Save_Load_main}>
      <div className={styles.Save_Load_top}>
        <div className={styles.Save_Load_title}>
          <div className={styles.Load_title_text}>{t('loadSaving.title')}</div>
        </div>
        <div className={styles.Save_Load_top_buttonList}>{page}</div>
      </div>
      <div className={styles.Save_Load_content} id={'Load_content_page_' + userDataState.optionData.slPage}>
        {showSaves}
      </div>
    </div>
  );
};



================================================
FILE: webgal/src/UI/Menu/SaveAndLoad/Save/Save.tsx
================================================
import { FC, useEffect } from 'react';
import styles from '../SaveAndLoad.module.scss';
import { saveGame } from '@/Core/controller/storage/saveGame';
import { setStorage } from '@/Core/controller/storage/storageController';
import { useDispatch, useSelector } from 'react-redux';
import { RootState } from '@/store/store';
import { setSlPage } from '@/store/userDataReducer';
import { showGlogalDialog } from '@/UI/GlobalDialog/GlobalDialog';
import useTrans from '@/hooks/useTrans';
import useSoundEffect from '@/hooks/useSoundEffect';
import { getSavesFromStorage } from '@/Core/controller/storage/savesController';
import { compileSentence } from '@/Stage/TextBox/TextBox';
import { mergeStringsAndKeepObjects } from '@/UI/Backlog/Backlog';

export const Save: FC = () => {
  const { playSePageChange, playSeEnter, playSeDialogOpen } = useSoundEffect();
  const userDataState = useSelector((state: RootState) => state.userData);
  const savesDataState = useSelector((state: RootState) => state.saveData);
  const dispatch = useDispatch();
  const page = [];
  for (let i = 1; i <= 20; i++) {
    let classNameOfElement = styles.Save_Load_top_button;
    if (i === userDataState.optionData.slPage) {
      classNameOfElement = classNameOfElement + ' ' + styles.Save_Load_top_button_on;
    }
    const element = (
      <div
        onClick={() => {
          dispatch(setSlPage(i));
          setStorage();
          playSePageChange();
        }}
        onMouseEnter={playSeEnter}
        key={'Save_element_page' + i}
        className={classNameOfElement}
      >
        <div className={styles.Save_Load_top_button_text}>{i}</div>
      </div>
    );
    page.push(element);
  }

  const tCommon = useTrans('common.');

  const showSaves = [];
  // 现在尝试设置10个存档每页
  const start = (userDataState.optionData.slPage - 1) * 10 + 1;
  const end = start + 9;

  useEffect(() => {
    getSavesFromStorage(start, end);
  }, [start, end]);

  let animationIndex = 0;
  for (let i = start; i <= end; i++) {
    animationIndex++;
    const saveData = savesDataState.saveData[i];
    let saveElementContent = <div />;
    if (saveData) {
      const speaker = saveData.nowStageState.showName === '' ? '\u00A0' : `${saveData.nowStageState.showName}`;
      const speakerView = easyCompile(speaker);
      saveElementContent = (
        <>
          <div className={styles.Save_Load_content_element_top}>
            <div className={styles.Save_Load_content_element_top_index}>{saveData.index}</div>
            <div className={styles.Save_Load_content_element_top_date}>{saveData.saveTime}</div>
          </div>
          <div className={styles.Save_Load_content_miniRen}>
            <img className={styles.Save_Load_content_miniRen_bg} alt="Save_img_preview" src={saveData.previewImage} />
          </div>
          <div className={styles.Save_Load_content_text}>
            <div className={styles.Save_Load_content_speaker}>{speakerView}</div>
            <div className={styles.Save_Load_content_text_padding}>{easyCompile(saveData.nowStageState.showText)}</div>
          </div>
        </>
      );
    }
    // else {

    // }
    const saveElement = (
      <div
        onClick={() => {
          if (savesDataState.saveData[i]) {
            playSeDialogOpen();
            showGlogalDialog({
              title: t('saving.isOverwrite'),
              leftText: tCommon('yes'),
              rightText: tCommon('no'),
              leftFunc: () => {
                saveGame(i);
                setStorage();
              },
              rightFunc: () => {},
            });
          } else {
            playSePageChange();
            saveGame(i);
          }
        }}
        onMouseEnter={playSeEnter}
        key={'saveElement_' + i}
        className={styles.Save_Load_content_element}
        style={{ animationDelay: `${animationIndex * 30}ms` }}
      >
        {saveElementContent}
      </div>
    );
    showSaves.push(saveElement);
  }

  const t = useTrans('menu.');

  return (
    <div className={styles.Save_Load_main}>
      <div className={styles.Save_Load_top}>
        <div className={styles.Save_Load_title}>
          <div className={styles.Save_title_text}>{t('saving.title')}</div>
        </div>
        <div className={styles.Save_Load_top_buttonList}>{page}</div>
      </div>
      <div className={styles.Save_Load_content} id={'Save_content_page_' + userDataState.optionData.slPage}>
        {showSaves}
      </div>
    </div>
  );
};

export function easyCompile(sentence: string) {
  const compiledNodes = compileSentence(sentence, 3, true);
  const rnodes = compiledNodes.map((line) => {
    return line.map((c) => {
      return c.reactNode;
    });
  });
  const showNameArrayReduced = mergeStringsAndKeepObjects(rnodes);
  return showNameArrayReduced.map((line, index) => {
    return (
      <div key={`backlog-line-${index}`}>
        {line.map((e, index) => {
          if (e === '<br />') {
            return <br key={`br${index}`} />;
          } else {
            return e;
          }
        })}
      </div>
    );
  });
}



================================================
FILE: webgal/src/UI/PanicOverlay/panicOverlay.module.scss
================================================
.panic_overlay_main {
  margin: 0;
  position: fixed;
  //display: none;
  width: 100%;
  height: 100%;
  background-color: white;
  z-index: 256;
}



================================================
FILE: webgal/src/UI/PanicOverlay/PanicOverlay.tsx
================================================
import { useEffect, useState } from 'react';
import ReactDOM from 'react-dom';
import { useSelector } from 'react-redux';
import { RootState } from '@/store/store';
import PanicYoozle from './PanicYoozle/PanicYoozle';
import styles from './panicOverlay.module.scss';

export default function PanicOverlay() {
  const GUIStore = useSelector((state: RootState) => state.GUI);
  const [showOverlay, setShowOverlay] = useState(false);
  const globalVars = useSelector((state: RootState) => state.userData.globalGameVar);
  const panic = globalVars['Show_panic'];
  const hidePanic = panic === false;
  useEffect(() => {
    const isShowOverlay = GUIStore.showPanicOverlay && !hidePanic;
    setShowOverlay(isShowOverlay);
  }, [GUIStore.showPanicOverlay, hidePanic]);
  return ReactDOM.createPortal(
    <div className={showOverlay ? styles.panic_overlay_main : ''}>{showOverlay && <PanicYoozle />}</div>,
    document.querySelector('#html-body__panic-overlay')!,
  );
}



================================================
FILE: webgal/src/UI/PanicOverlay/PanicImage/panicImage.module.scss
================================================



================================================
FILE: webgal/src/UI/PanicOverlay/PanicImage/PanicImage.tsx
================================================
import { useSelector } from 'react-redux';
import { RootState } from '@/store/store';

/**
 * @todo Allow custom panic image from config
 */
export const PanicImage = () => {
  return (
    <div>
      <img alt="Panic Image" />
    </div>
  );
};



================================================
FILE: webgal/src/UI/PanicOverlay/PanicYoozle/panicYoozle.module.scss
================================================
.yoozle_blue {
  color: #4285f4;
}

.yoozle_red {
  color: #db4437;
}

.yoozle_yellow {
  color: #f4b400;
}

.yoozle_green {
  color: #0f9d58;
}

.yoozle_e_rotate {
  display: inline-block;
  transform: rotate(-12deg);
}

.yoozle_container {
  display: flex;
  flex-direction: column;
  height: 100%;
}

.yoozle_title {
  display: flex;
  flex-direction: column;
  align-items: center;
  padding-top: 80px;
  font-family: arial, sans-serif;
  font-size: 90px;
}

.yoozle_search {
  display: flex;
  flex-direction: column;
  align-items: center;
  padding: 20px 10px;
}

.yoozle_search_bar {
  width: 40%;
  line-height: 32px;
  font-family: arial, sans-serif;
  font-size: 18px;
}

.yoozle_search_buttons {
  padding-top: 13px;
}

.yoozle_button {
  background-color: #f8f9fa;
  border: 1px solid #f8f9fa;
  border-radius: 4px;
  color: #3c4043;
  font-family: arial, sans-serif;
  font-size: 14px;
  margin: 11px 4px;
  padding: 0 16px;
  line-height: 27px;
  height: 36px;
  min-width: 54px;
  text-align: center;
  cursor: pointer;
  user-select: none;
}

.yoozle_button:hover {
  box-shadow: 0 1px 1px rgba(0, 0, 0, .1);
  border: 1px solid #dadce0;
  color: #202124;
}

.yoozle_button:focus {
  border: 1px solid #4285f4;
  outline: none;
}



================================================
FILE: webgal/src/UI/PanicOverlay/PanicYoozle/PanicYoozle.tsx
================================================
import { useEffect } from 'react';
import styles from './panicYoozle.module.scss';

export default function PanicYoozle() {
  useEffect(() => {
    const panicTitle = 'Yoozle Search';
    const originalTitle = document.title;
    document.title = panicTitle;
    return () => {
      document.title = originalTitle;
    };
  }, []);
  return (
    <div className={styles.yoozle_container}>
      <div className={styles.yoozle_title}>
        <span>
          <span className={styles.yoozle_blue} style={{ marginRight: '1px' }}>
            W
          </span>
          <span className={`${styles.yoozle_red}`}>e</span>
          <span className={styles.yoozle_yellow}>b</span>
          <span className={styles.yoozle_blue}>g</span>
          <span className={`${styles.yoozle_green} ${styles.yoozle_e_rotate}`}>a</span>
          <span className={`${styles.yoozle_red}`}>l</span>
        </span>
      </div>
      <div className={styles.yoozle_search}>
        <input className={styles.yoozle_search_bar} type="text" defaultValue="" />
        <div className={styles.yoozle_search_buttons}>
          <input className={styles.yoozle_button} type="submit" value="WebGAL Search" />
          <input className={styles.yoozle_button} type="submit" value="Feeling Lucky" />
        </div>
      </div>
    </div>
  );
}



================================================
FILE: webgal/src/UI/Title/title.module.scss
================================================
.Title_main {
  width: 100%;
  height: 100%;
  position: absolute;
  z-index: 13;
}

.Title_buttonList {
  display: flex;
  position: absolute;
  left: 0;
  min-width: 25%;
  height: 100%;
  justify-content: center;
  align-items: flex-start;
  flex-flow: column;
  transition: background 0.75s;
  padding-left: 120px;
}

.Title_button {
  font-weight: bold;
  text-align: center;
  flex: 0 1 auto;
  cursor: pointer;
  padding: 1em 2em 1em 2em;
  margin: 20px 0;
  transition: all 0.33s;
  background: rgba(255, 255, 255, 0.15);
  backdrop-filter: blur(5px);
  border-radius: 4px;
  transform: skewX(-10deg);
  background: linear-gradient(to right, rgba(0, 0, 0, 0.3), rgba(0, 0, 0, 0.1));
}

.Title_button:hover {
  text-shadow: 0 0 10px rgba(255, 255, 255, 1);
  padding: 1em 6em 1em 3em;
}

.Title_button_text {
  font-size: 165%;
  color: #fbfbfb;
  padding: 0 0.5em 0 0.5em;
  letter-spacing: 0.2em;
}

.Title_backup_background {
  width: 100%;
  height: 100%;
  position: absolute;
  z-index: 13;
  background: linear-gradient(135deg, #fdfbfb 0%, #dcddde 100%);
}

.Title_button_disabled {
  cursor: not-allowed !important;
  opacity: 0.5;
}



================================================
FILE: webgal/src/UI/Title/Title.tsx
================================================
import { useDispatch, useSelector } from 'react-redux';
import { RootState } from '@/store/store';
import { fullScreenOption } from '@/store/userDataInterface';
import { setMenuPanelTag, setVisibility } from '@/store/GUIReducer';
import { MenuPanelTag } from '@/store/guiInterface';
import useTrans from '@/hooks/useTrans';
import useSoundEffect from '@/hooks/useSoundEffect';
import useApplyStyle from '@/hooks/useApplyStyle';
import { keyboard } from '@/hooks/useHotkey';
import useConfigData from '@/hooks/useConfigData';
import { playBgm } from '@/Core/controller/stage/playBgm';
import { continueGame, startGame } from '@/Core/controller/gamePlay/startContinueGame';
import { showGlogalDialog } from '../GlobalDialog/GlobalDialog';
import styles from './title.module.scss';

/** 标题页 */
export default function Title() {
  const userDataState = useSelector((state: RootState) => state.userData);
  const GUIState = useSelector((state: RootState) => state.GUI);
  const dispatch = useDispatch();
  const fullScreen = userDataState.optionData.fullScreen;
  const background = GUIState.titleBg;
  const showBackground = background === '' ? 'rgba(0,0,0,1)' : `url("${background}")`;
  const t = useTrans('title.');
  const tCommon = useTrans('common.');
  const { playSeEnter, playSeClick } = useSoundEffect();

  const applyStyle = useApplyStyle('UI/Title/title.scss');
  useConfigData(); // 监听基础ConfigData变化

  const appreciationItems = useSelector((state: RootState) => state.userData.appreciationData);
  const hasAppreciationItems = appreciationItems.bgm.length > 0 || appreciationItems.cg.length > 0;

  return (
    <>
      {GUIState.showTitle && <div className={applyStyle('Title_backup_background', styles.Title_backup_background)} />}
      <div
        className="title__enter-game-target"
        onClick={() => {
          playBgm(GUIState.titleBgm);
          dispatch(setVisibility({ component: 'isEnterGame', visibility: true }));
          if (fullScreen === fullScreenOption.on) {
            document.documentElement.requestFullscreen();
            if (keyboard) keyboard.lock(['Escape', 'F11']);
          }
        }}
        onMouseEnter={playSeEnter}
      />
      {GUIState.showTitle && (
        <div
          className={applyStyle('Title_main', styles.Title_main)}
          style={{
            backgroundImage: showBackground,
            backgroundSize: 'cover',
          }}
        >
          <div className={applyStyle('Title_buttonList', styles.Title_buttonList)}>
            <div
              className={applyStyle('Title_button', styles.Title_button)}
              onClick={() => {
                startGame();
                playSeClick();
              }}
              onMouseEnter={playSeEnter}
            >
              <div className={applyStyle('Title_button_text', styles.Title_button_text)}>{t('start.title')}</div>
            </div>
            <div
              className={applyStyle('Title_button', styles.Title_button)}
              onClick={async () => {
                playSeClick();
                dispatch(setVisibility({ component: 'showTitle', visibility: false }));
                continueGame();
              }}
              onMouseEnter={playSeEnter}
            >
              <div className={applyStyle('Title_button_text', styles.Title_button_text)}>{t('continue.title')}</div>
            </div>
            <div
              className={applyStyle('Title_button', styles.Title_button)}
              onClick={() => {
                playSeClick();
                dispatch(setVisibility({ component: 'showMenuPanel', visibility: true }));
                dispatch(setMenuPanelTag(MenuPanelTag.Option));
              }}
              onMouseEnter={playSeEnter}
            >
              <div className={applyStyle('Title_button_text', styles.Title_button_text)}>{t('options.title')}</div>
            </div>
            <div
              className={applyStyle('Title_button', styles.Title_button)}
              onClick={() => {
                playSeClick();
                dispatch(setVisibility({ component: 'showMenuPanel', visibility: true }));
                dispatch(setMenuPanelTag(MenuPanelTag.Load));
              }}
              onMouseEnter={playSeEnter}
            >
              <div className={applyStyle('Title_button_text', styles.Title_button_text)}>{t('load.title')}</div>
            </div>
            {GUIState.enableAppreciationMode && (
              <div
                className={`${applyStyle('Title_button', styles.Title_button)} ${
                  !hasAppreciationItems ? styles.Title_button_disabled : ''
                }`}
                onClick={() => {
                  if (hasAppreciationItems) {
                    playSeClick();
                    dispatch(setVisibility({ component: 'showExtra', visibility: true }));
                  }
                }}
                onMouseEnter={playSeEnter}
              >
                <div className={applyStyle('Title_button_text', styles.Title_button_text)}>{t('extra.title')}</div>
              </div>
            )}
            <div
              className={applyStyle('Title_button', styles.Title_button)}
              onClick={() => {
                playSeClick();
                showGlogalDialog({
                  title: t('exit.tips'),
                  leftText: tCommon('yes'),
                  rightText: tCommon('no'),
                  leftFunc: () => {
                    window.close();
                  },
                  rightFunc: () => {},
                });
              }}
              onMouseEnter={playSeEnter}
            >
              <div className={applyStyle('Title_button_text', styles.Title_button_text)}>{t('exit.title')}</div>
            </div>
          </div>
        </div>
      )}
    </>
  );
}



================================================
FILE: webgal/src/UI/Translation/translation.module.scss
================================================
.trans {
  height: 100%;
  width: 100%;
  background-image: linear-gradient(225deg, #a3bded 0%, #6991c7 100%);
  position: absolute;
  z-index: 20;
}

.langWrapper{
  display: flex;
  justify-content: center;
  align-items: center;
  width: 100%;
  height: 100%;
  flex-flow: column;
}

.lang {
  width: 100%;
  text-align: center;
  font-family: "思源宋体", serif;
  color: transparent;
  font-size: 300%;
  background: linear-gradient(150deg, rgb(255, 255, 255) 0%, rgb(255, 255, 255) 75%, #51A8DD 100%);
  -webkit-background-clip: text;
}

.langSelect{
  display: flex;
  gap: 50px;
  padding: 50px;
}

.langSelectButton{
  font-family: "思源宋体", serif;
  cursor: pointer;
  font-size: 200%;
  color: #FFFFFF;
  border-radius: 4px;
  border: 1px solid rgba(255,255,255,0.8);
  padding: 10px 50px;
  transition: color 0.33s, background-color 0.33s;
}

.langSelectButton:hover{
  background: white;
  color: #93a5cf;
}



================================================
FILE: webgal/src/UI/Translation/Translation.tsx
================================================
import useLanguage from '@/hooks/useLanguage';
import { useEffect, useState } from 'react';
import s from './translation.module.scss';
import languages, { language } from '@/config/language';
import { useSelector } from 'react-redux';
import { RootState } from '@/store/store';

export default function Translation() {
  const setLanguage = useLanguage();

  const [isShowSelectLanguage, setIsShowSelectLanguage] = useState(false);
  const globalVar = useSelector((state: RootState) => state.userData.globalGameVar);
  const defaultLang = globalVar['Default_Language'] ?? '';

  const setLang = (langId: language) => {
    setIsShowSelectLanguage(false);
    setLanguage(langId);
  };

  useEffect(() => {
    const lang = window?.localStorage.getItem('lang');
    if (!lang) {
      setIsShowSelectLanguage(true);
      if (defaultLang) {
        switch (defaultLang) {
          case 'zh_CN':
            setLang(language.zhCn);
            break;
          case 'zh_TW':
            setLang(language.zhTw);
            break;
          case 'en':
            setLang(language.en);
            break;
          case 'ja':
            setLang(language.jp);
            break;
          case 'fr':
            setLang(language.fr);
            break;
          case 'de':
            setLang(language.de);
            break;
          default:
            setLang(language.zhCn);
            break;
        }
      }
    } else {
      setLanguage(Number(window?.localStorage.getItem('lang')), false);
    }
  }, [defaultLang]);

  return (
    <>
      {isShowSelectLanguage && (
        <div className={s.trans}>
          <div className={s.langWrapper}>
            <div className={s.lang}>LANGUAGE SELECT</div>
            <div className={s.langSelect}>
              {Object.keys(languages).map((key) => (
                <div
                  key={key}
                  className={s.langSelectButton}
                  onClick={() => setLang(language[key as unknown as language] as unknown as language)}
                >
                  {languages[key]}
                </div>
              ))}
            </div>
          </div>
        </div>
      )}
    </>
  );
}



================================================
FILE: yukimi/libwebgal-base.ykm
================================================
# Dialog
- extern say content speaker vocal %
@__type content string
@__type speaker string
@__type vocal string
^


# Background and figure
-extern changeBg content %
@__type content string
^

-extern changeFigure content left center right id %
@__type conetnt string
@__type left boolean
@__type center boolean
@__type right boolean
@__type id string
^


#bgm, effect sound, video
-extern bgm conetnt %
@__type conetnt string
^

-extern playVideo conetnt %
@__type content string
^

-extern playEffects conetnt %
@__type conetnt string
^

#


# Demo
- scene "main"
@say "你好" "WebGAL" "v1.ogg"

